[
  {
    "ver": "0.1",
    "info": {
      "id": "3dSXzm",
      "date": "1553373978",
      "viewed": 2878,
      "name": "Data Surge",
      "username": "shau",
      "description": "Inspired by Beeple",
      "likes": 34,
      "published": 1,
      "flags": 32,
      "tags": [
        "3d",
        "beeple"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime\n#define R iResolution.xy\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nfloat noise(vec2 uv, float s1, float s2, float t1, float t2, float c1) {\n\treturn clamp(hash33(vec3(uv.xy * s1, t1)).x +\n\t\thash33(vec3(uv.xy * s2, t2)).y, c1, 1.);\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec2 uv = U / R;\n\tvec3 pc = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.).xyz;\n    float n = noise(uv, 64., 32., float(iFrame), float(iFrame), .96);\n    pc *= n;\n    pc *= sin((uv.y + T * 0.05) * 800.0) * 0.2 + 0.9; \n    \n    C = vec4(pc, 1.);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define PI 3.141592\n#define EPS .005\n#define FAR 30.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define BUF(C, P, R) texture(C, P / R)\n#define BPOS(P) vec2(P + .5, .5)\n\n#define LP vec3(5., 6., -5.)\n\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\nvec2 path(float p, float T) {\n    return vec2(sin(p * .2 + T * .2), cos(p * .3 + T * .1));\n}\n\n//noise IQ - Shane\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nvec3 camera(vec2 U, vec2 R, vec3 ro, vec3 la, float fl) {\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}",
        "name": "Common",
        "description": "",
        "type": "common"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    C = texture(iChannel0, U / iResolution.xy);\n    \n    if (C == vec4(0) || C.x < -20.) {\n        //initialise particle\n        vec3 r = 5. * (hash33(vec3(U + 4. + T, iFrame)) - vec3(.5));\n        C = vec4(20. + r.x * 4., r.y, r.z, clamp(r.y * .5, .1, .4));        \n    }\n    \n    //move particle\n    C.x -= clamp(C.w * .4, .3, .5); \n    C.yz += path(C.x + C.w * 100., T) * clamp(C.w * .1, .01, .05);\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XsXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define T iTime\n\nstruct Surface{\n    float t; //nearest\n    float b; //bands\n    float bl; //band lights\n    float c; //core\n    float cl; //core lights\n};\nconst Surface MISS = Surface(-1., 0., 0., 0., 0.);\n\nvec3 kali(vec3 rd) {\n    vec3 pc = vec3(0);\n    float k = 0.;\n    for (float i = 0.; i < 6.; i++) {\n        rd = abs(rd) / dot(rd, rd) - .63;\n        k += length(rd) * length(hash33(rd + T*.2));\n        pc += mix(vec3(1.,.5,0.), vec3(0.,1.,0.), i/6.) * k*k*k * .0003;\n    }\n    return pc;\n}\n\n//IQ\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h) - r;\n}\n\n//IQ\nfloat sdBox(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n//Dr 2\nfloat sdSquareHelix(vec3 p, float r1, float r2, vec2 b, float m, float o) {\n  float halfm = m * .5,\n        a = 0.5 * sign(p.z) - atan(p.z,p.y) / (2.*PI);\n  p.x = mod(-p.x + m * a + o, m) - halfm;\n  return max(sdBox(vec2(length(p.yz) - r1, p.x), vec2(b + r2)), \n            -sdBox(vec2(length(p.yz) - r1, p.x), vec2(b - r2))); \n}\n\n//Eiffie\nfloat sdHelix(vec3 p, float r1, float r2, float m, float o) {\n    float halfm = m*.5,\n          b = mod(p.x + o, PI*m) - PI*halfm,\n          a = abs(atan(p.y, p.z) * halfm - b);\n    if (a > PI*halfm) a = PI*m - a;\n    return length(vec2(length(p.zy) - r1, a)) - r2;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdBall(vec3 p, float i, float r) {\n    vec4 cp = BUF(iChannel0, BPOS(i), iResolution.xy);\n    return length(cp.xyz - p) - (1. / (1. + dot(cp.yz, cp.yz) * r));\n}\n\nvec2 dfCore(vec3 p) {\n    \n    vec3 q = p;\n    q.yz += path(q.x, T);\n    float qt = length(q.yz);\n    vec3 h = hash33(q * qt * qt * 1.1);\n    float nz = n3D(q * 1. + (vec3(T*8., T*.3, T*.3) + h)) -.5;\n    float core = sdCapsule(q, vec3(100., 0., 0.), vec3(-100., 0., 0.), 1.4 + nz * qt * 1.3); \n\n    p.x = mod(p.x - 16., 40.) - 20.;    \n    float ts = FAR, tsl = FAR;\n    \n    for (float i = 0.; i < 10.; i++) {\n        float bt = sdBall(p, i, .2 + nz * .6);\n        ts = (bt < ts) ? bt : ts;\n    }\n    \n    for (float i = 10.; i < 24.; i++) {\n        float bt = sdBall(p, i, .6);\n        tsl = (bt < tsl) ? bt : tsl;\n    }\n    \n    return vec2(smin(ts, core, .9), tsl);    \n}\n\nSurface map(vec3 p) {\n\n    p.yz *= rot(T * .3);\n\n    vec2 core = dfCore(p);\n    \n    float bands = sdSquareHelix(p, 3., .01, vec2(.01,.7), 4. * PI, 0.);\n    float bandLights = min(sdHelix(p, 3.06, .06, 4., -PI-.35),\n                       sdHelix(p, 3.06, .06, 4., -PI+.35));\n    bands = min(bands, sdSquareHelix(p, 2.4, .01, vec2(.01,.9), 4.6 * PI, -1.4));\n    bandLights = min(bandLights, min(sdHelix(p, 2.46, .06, 4.6, .9-PI-.4),\n                             sdHelix(p, 2.46, .06, 4.6, .9-PI+.4)));\n    bands = min(bands, sdSquareHelix(p, 3.6, .01, vec2(.01,.2), 3. * PI, -3.4));\n    bandLights = min(bandLights, sdHelix(p, 3.68, .04, 3., 4.6-PI-.4));\n\n    return Surface(min(core.x, min(bands, min(bandLights, core.y))), \n                   bands, \n                   bandLights, \n                   core.x, \n                   core.y);\n}\n\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).t + e.xxy * map(p + e.xxy).t + \n\t\t\t\t\t e.xyx * map(p + e.xyx).t + e.yyy * map(p + e.yyy).t);   \n}\n\nfloat AO(vec3 p, vec3 n) {\n\n    float r = 0.0,\n          w = 1.0,\n          d = 0.0;\n\n    for (float i = 1.0; i < 5.0; i += 1.0){\n        d = i / 5.0;\n        r += w * (d - map(p + n * d).t);\n        w *= 0.5;\n    }\n\n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\nSurface march(vec3 ro, vec3 rd, inout float t, inout vec3 gc) {\n    \n   for (int i = 0; i < 96; i++) {\n        \n        Surface s = map(ro + rd * t);\n        \n        if (s.t < EPS) return s;\n        if (t > FAR) break;\n        \n        //core lights\n        float ltsg = 1. / (1. + s.cl * s.cl * 12.);\n        gc += vec3(0., 1., 0.) * ltsg * .1;\n       \n        //band glow\n        float ltbg = 1. / (1. + s.bl * s.bl * 400.);\n        gc += vec3(0., 1., 0.) * ltbg * .1;\n        \n        t += s.t * .5;\n    }\n    t = -1.;\n    return MISS;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n\n\tvec3 ro = vec3(1., 3. + (sin(T * .2) + 1.) * 1.2, -4.5 + (sin(T * .1) + 1.) * .2), \n         gc = vec3(0.);\n    \n    ro.xz *= rot(sin(T * .2) * .1);\n    vec3 rd = camera(U, R, ro, vec3(0.), 2.4);\n\n    vec3 pc = kali(-rd * 1.4) * .5;\n    \n    float t = 0., dof = 0.;\n    Surface s = march(ro, rd, t, gc);\n    if (t > 0.) {\n        vec3 p = ro + rd * t;\n        dof = length(p) * .05;\n        vec3 n = normal(p);\n        float ao = AO(p, n);\n        vec3 ld = normalize(LP - p);\n        float df = max(.05, dot(ld, n));\n        float sp = pow(max(dot(reflect(-ld, n), -rd), 0.), 32.);\n        float fres = pow(clamp(dot(n, rd) + 1., 0., 1.), 8.);\n        if (s.t == s.b) {\n            //band\n            pc = vec3(.1) * df * ao;    \n            pc += vec3(1.) * sp;\n            pc += vec3(1.) * fres;\n            \n        } else if (s.t == s.c) {\n            //core    \n            pc = vec3(.2) * df * ao;\n            //dof = .9;\n            \n        } else if (s.t == s.cl || s.t == s.bl) {\n            //lights    \n            pc = vec3(0., 1.8, 0.) * ao;\n        }\n    }\n    pc += gc;\n    //pc = mix(pc, vec3(0), t * t * .08 / FAR);\n\n    C = vec4(pc, dof);\n}",
        "name": "Buffer B",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "Thanks Shane. Beeple/Mike Winkleman is a CG artist with an interesting work ethic. His VJ clips and short films are very cool :)   ",
        "date": "1554281627",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "MtlyWf",
        "hidden": 0
      },
      {
        "text": "I missed this. Very nice. I've never quite been sure what Beeple is exactly, but I've always loved the imagery associated with the term. Great for inspiration.",
        "date": "1554246876",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "ltlyDX",
        "hidden": 0
      },
      {
        "text": "Suprised (pleasantly) to this is SOTW. Thanks",
        "date": "1554067176",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "llXcWf",
        "hidden": 0
      },
      {
        "text": ":nabla: :love: :nabla:",
        "date": "1553795262",
        "username": "balkhan",
        "userpicture": "/img/profile.jpg",
        "id": "MtlyD2",
        "hidden": 0
      },
      {
        "text": "Thank you",
        "date": "1553627415",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "XtlcWj",
        "hidden": 0
      },
      {
        "text": "Very nice!",
        "date": "1553540921",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MtXyWj",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3l23Rh",
      "date": "1558990029",
      "viewed": 14040,
      "name": "Protean clouds",
      "username": "nimitz",
      "description": "Fully procedural 3D animated volume with three evaluations per step (for shading) running fast enough for 1080p rendering.\n\nFeaturing simple mouse interaction.",
      "likes": 321,
      "published": 1,
      "flags": 0,
      "tags": [
        "procedural",
        "3d",
        "fast",
        "volumetric"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Super nice, will study. Like right out of a Disney movie",
        "date": "1560048963",
        "username": "KylBlz",
        "userpicture": "/media/users/KylBlz/profile.jpeg",
        "id": "MljyDy",
        "hidden": 0
      },
      {
        "text": "wow :)",
        "date": "1559680093",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "4lSyDG",
        "hidden": 0
      },
      {
        "text": "Amazing work",
        "date": "1559642930",
        "username": "hjd3481",
        "userpicture": "/img/profile.jpg",
        "id": "4tSyWG",
        "hidden": 0
      },
      {
        "text": "WOW this looks amazing!!!!!",
        "date": "1559642878",
        "username": "TobberH",
        "userpicture": "/media/users/TobberH/profile.jpeg",
        "id": "Ml2czd",
        "hidden": 0
      },
      {
        "text": "holy aaaaaa",
        "date": "1559617039",
        "username": "FMS_Cat",
        "userpicture": "/media/users/FMS_Cat/profile.png",
        "id": "lt2yzd",
        "hidden": 0
      },
      {
        "text": "Simply beautiful, no other words for this, would be lovely if this was available as API to work with Virtual DJ",
        "date": "1559576042",
        "username": "rivvumevents",
        "userpicture": "/img/profile.jpg",
        "id": "ll2yzt",
        "hidden": 0
      },
      {
        "text": "six six six",
        "date": "1559527308",
        "username": "gongzixiaobai",
        "userpicture": "/img/profile.jpg",
        "id": "4l2czd",
        "hidden": 0
      },
      {
        "text": "Great mapping idea, and it looks looks amazing.\n",
        "date": "1559377459",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4t2yRt",
        "hidden": 0
      },
      {
        "text": "Absolutely stunning!",
        "date": "1559365402",
        "username": "Hadyn",
        "userpicture": "/img/profile.jpg",
        "id": "ltSczd",
        "hidden": 0
      },
      {
        "text": "OMG!!! Gorgeous!",
        "date": "1559362666",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "MlByzd",
        "hidden": 0
      },
      {
        "text": "[b]best[/b]",
        "date": "1559343525",
        "username": "patu",
        "userpicture": "/media/users/patu/profile.jpeg",
        "id": "MlSyzd",
        "hidden": 0
      },
      {
        "text": "This is insanely inspirational!",
        "date": "1559327670",
        "username": "mmerchante",
        "userpicture": "/media/users/mmerchante/profile.jpeg",
        "id": "MlByRd",
        "hidden": 0
      },
      {
        "text": "Wow, thats beautiful!",
        "date": "1559313461",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "MtSczt",
        "hidden": 0
      },
      {
        "text": "amazing !!",
        "date": "1559312818",
        "username": "polymonster",
        "userpicture": "/media/users/polymonster/profile.png",
        "id": "ltSczt",
        "hidden": 0
      },
      {
        "text": "huh, excellent!!!",
        "date": "1559297359",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "ltSyzt",
        "hidden": 0
      },
      {
        "text": "This is insane nimitz ! :)",
        "date": "1559292451",
        "username": "Draedrus",
        "userpicture": "/media/users/Draedrus/profile.png",
        "id": "MlBcRt",
        "hidden": 0
      },
      {
        "text": "This is super cool",
        "date": "1559248529",
        "username": "Raphael188",
        "userpicture": "/img/profile.jpg",
        "id": "MlByRt",
        "hidden": 0
      },
      {
        "text": "amazing work!",
        "date": "1559244374",
        "username": "teadrinker",
        "userpicture": "/media/users/teadrinker/profile.jpeg",
        "id": "llByRt",
        "hidden": 0
      },
      {
        "text": "Thanks everyone! it means a lot to get thumbs ups by such a remarkable collection of shader coders.\n\nFabrice: Cleaned up the code, I like that way of setting up coordinates too, will use a variation of it, thanks!\n\n",
        "date": "1559230482",
        "username": "nimitz",
        "userpicture": "/media/users/nimitz/profile.png",
        "id": "MlSyRt",
        "hidden": 0
      },
      {
        "text": "OUTSTANDING!!!!",
        "date": "1559228346",
        "username": "Flavio",
        "userpicture": "/media/users/Flavio/profile.jpeg",
        "id": "ltSyRt",
        "hidden": 0
      },
      {
        "text": "Awesome",
        "date": "1559228302",
        "username": "mantra",
        "userpicture": "/img/profile.jpg",
        "id": "4lBczd",
        "hidden": 0
      },
      {
        "text": "here's an attempt I made at speeding it up : https://www.shadertoy.com/view/wlSGWR ",
        "date": "1559175080",
        "username": "granito",
        "userpicture": "/img/profile.jpg",
        "id": "4tByRd",
        "hidden": 0
      },
      {
        "text": "nimitz, could you save as \"public + API\" so it shows up in the shadertoy ios app ?",
        "date": "1559146115",
        "username": "elenzil",
        "userpicture": "/media/users/elenzil/profile.jpeg",
        "id": "4lSczt",
        "hidden": 0
      },
      {
        "text": "wow, so cool !\n\nsome remarks:\n\nrot_x , y , z functions not used ;-)\nmg2() unused\n\nmag2: note that overloading can be avoided using #define mag2(p) dot(p,p)\nwhy is mg2() a separate func ?\n\ncoordinate normalization:\nI personnaly find this more easy to read: ;-)\n[code]\tvec2 R = iResolution.xy,\n         q = fragCoord/R,\n         p = (fragCoord - .5*R ) / R.y,\n        mo = iMouse.xy;\n    mo = ( mo==vec2(0) ) \n            ? vec2(.15)\n            : ( mo - .5*R ) / R.y;\n[/code]\n",
        "date": "1559115255",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4lScRt",
        "hidden": 0
      },
      {
        "text": "wow, so cool !\n\nsome remarks:\n\nrot_x , y , z functions not used ;-)\nmg2() unused\n\nmag2: note that overloading can be avoided using #define mag2(p) dot(p,p)\nwhy is mg2() a separate func ?\n\ncoordinate normalization:\nI personnaly find this more easy to read: ;-)\n[code]\tvec2 R = iResolution.xy,\n         q = fragCoord/R,\n         p = (fragCoord - .5*R ) / R.y,\n        mo = iMouse.xy;\n    mo = ( mo==vec2(0) ) \n            ? vec2(.15)\n            : ( mo - .5*R ) / R.y;\n[/code]\n",
        "date": "1559115190",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XlScRt",
        "hidden": 0
      },
      {
        "text": "wow, so cool !\n\nsome remarks:\n\nrot_x , y , z functions not used ;-)\nmg2() unused\n\nmag2: note that overloading can be avoided using #define mag2(p) dot(p,p)\nwhy is mg2() a separate func ?\n\ncoordinate normalization:\nI personnaly find this more easy to read:\n[code]\tvec2 R = iResolution.xy,\n         q = fragCoord/R,\n         p = (fragCoord - .5*R ) / R.y,\n        mo = iMouse.xy;\n    mo = ( mo==vec2(0) ) \n            ? vec2(.15)\n            : ( mo - .5*R ) / R.y;\n[/code]\n",
        "date": "1559114555",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4tScRt",
        "hidden": 0
      },
      {
        "text": "wow, so cool !\n\nsome remarks:\n\nrot_x , y , z functions not used ;-)\nmg2() unused\n\nmag2: note that overloading can be avoided using #define mag2(p) dot(p,p)\nwhy is mg2() a separate func ?\n\ncoordinate normalization:\nI personnaly find this more easy to read:\n[code]\tvec2 R = iResolution.xy,\n         q = fragCoord/R,\n         p = (fragCoord - .5*R ) / R.y,\n        mo = iMouse.xy;\n    mo = ( mo==vec2(0) ) \n            ? vec2(.15)\n            : ( mo - .5*R ) / R.y;\n[/code]\n",
        "date": "1559114536",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XtScRt",
        "hidden": 0
      },
      {
        "text": "wow, so cool !\n\nsome remarks:\n\nrot_x , y , z functions not used ;-)\nmg2() unused\n\nmag2: note that overloading can be avoided using #define mag2(p) dot(p,p)\nwhy is mg2() a separate func ?\n\ncoordinate normalization:\nI personnaly find this more easy to read:\n[code]\tvec2 R = iResolution.xy,\n         q = fragCoord/R,\n         p = (fragCoord - .5*R ) / R.y,\n        mo = iMouse.xy;\n    mo = ( mo==vec2(0) ) \n            ? vec2(.15)\n            : ( mo - .5*R ) / R.y;\n[/code]\n",
        "date": "1559114428",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4lByRt",
        "hidden": 0
      },
      {
        "text": "wow, so cool !\n\nsome remarks:\n\nrot_x , y , z functions not used ;-)\nmg2() unused\n\nmag2: note that overloading can be avoided using #define mag2(p) dot(p,p)\nwhy is mg2() a separate func ?\n\ncoordinate normalization:\nI personnaly find this more easy to read:\n[code]\tvec2 R = iResolution.xy,\n         q = fragCoord/R,\n         p = (fragCoord - .5*R ) / R.y,\n        mo = iMouse.xy;\n    mo = ( mo==vec2(0) ) \n            ? vec2(.15)\n            : ( mo - .5*R ) / R.y;\n[/code]\n",
        "date": "1559114369",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XlByRt",
        "hidden": 0
      },
      {
        "text": "wow, so cool !\n\nsome remarks:\n\nrot_x , y , z functions not used ;-)\nmg2() unused\n\nmag2: note that overloading can be avoided using #define mag2(p) dot(p,p)\nwhy is mg2() a separate func ?\n\ncoordinate normalization:\nI personnaly find this more easy to read:\n[code]\tvec2 R = iResolution.xy,\n         q = fragCoord/R,\n         p = (fragCoord - .5*R ) / R.y,\n        mo = iMouse.xy;\n    mo = ( mo==vec2(0) ) \n            ? vec2(.15)\n            : ( mo - .5*R ) / R.y;\n[/code]\n",
        "date": "1559114332",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4tByRt",
        "hidden": 0
      },
      {
        "text": "So short, so fast and so good... the first seconds triggered a sort of brain stimulation wave of goodness, thanks for sharing!",
        "date": "1559089922",
        "username": "blackjero",
        "userpicture": "/img/profile.jpg",
        "id": "XlSyRt",
        "hidden": 0
      },
      {
        "text": "Incredible!",
        "date": "1559081208",
        "username": "saidwho12",
        "userpicture": "/img/profile.jpg",
        "id": "XtSyRt",
        "hidden": 0
      },
      {
        "text": "Beautiful work!",
        "date": "1559071717",
        "username": "tehsauce",
        "userpicture": "/media/users/tehsauce/profile.jpeg",
        "id": "Mtjczc",
        "hidden": 0
      },
      {
        "text": "Probably the prettiest shader in this site, especially the first 8 seconds when all is orange/yellow. So good!",
        "date": "1559068531",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "Ml2yzc",
        "hidden": 0
      },
      {
        "text": "wow!",
        "date": "1559058242",
        "username": "elenzil",
        "userpicture": "/media/users/elenzil/profile.jpeg",
        "id": "lt2cRc",
        "hidden": 0
      },
      {
        "text": "wow i wish i had this kind of talent. Why am I a good programmer but not so good when it comes to complex mathematics? I've been researching game development and programming for 10-12 years and i can't figure this shit out. Goddamn.",
        "date": "1559057278",
        "username": "Carandiru",
        "userpicture": "/media/users/Carandiru/profile.png",
        "id": "lljcRc",
        "hidden": 0
      },
      {
        "text": ":O",
        "date": "1559055171",
        "username": "TinyTexel",
        "userpicture": "/media/users/TinyTexel/profile.png",
        "id": "MtjcRc",
        "hidden": 0
      },
      {
        "text": "amazing",
        "date": "1559047073",
        "username": "granito",
        "userpicture": "/img/profile.jpg",
        "id": "Mt2yRc",
        "hidden": 0
      },
      {
        "text": ":love: Very nice, and clever, as always.",
        "date": "1559045803",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "lljyRc",
        "hidden": 0
      },
      {
        "text": "This is amazing!",
        "date": "1559045125",
        "username": "Klems",
        "userpicture": "/media/users/Klems/profile.png",
        "id": "MtjyRc",
        "hidden": 0
      },
      {
        "text": "amazing, both artistically and technically \\o/",
        "date": "1559037591",
        "username": "hornet",
        "userpicture": "/img/profile.jpg",
        "id": "lt2cz3",
        "hidden": 0
      },
      {
        "text": "Super beautiful! ",
        "date": "1559035126",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "Mljcz3",
        "hidden": 0
      },
      {
        "text": "wow wow wow",
        "date": "1559033311",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "Mtjcz3",
        "hidden": 0
      },
      {
        "text": "entering Jupiter cloud layer ? ;-p",
        "date": "1559031051",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ll2yz3",
        "hidden": 0
      },
      {
        "text": "beautiful!",
        "date": "1559026521",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "lljyz3",
        "hidden": 0
      },
      {
        "text": "This is so beautiful! Even a still frame looks like an awesome painting.",
        "date": "1559014941",
        "username": "bitnenfer",
        "userpicture": "/media/users/bitnenfer/profile.jpeg",
        "id": "ll2cR3",
        "hidden": 0
      },
      {
        "text": "Shader of the week?",
        "date": "1559010736",
        "username": "felipunkerito",
        "userpicture": "/img/profile.jpg",
        "id": "lt2cR3",
        "hidden": 0
      },
      {
        "text": "One of the best shaders I've seen lately! WOW!",
        "date": "1559007230",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "MljcR3",
        "hidden": 0
      },
      {
        "text": "Really nice!",
        "date": "1558999093",
        "username": "belfry",
        "userpicture": "/img/profile.jpg",
        "id": "ll2yR3",
        "hidden": 0
      },
      {
        "text": "Wow!!",
        "date": "1558993976",
        "username": "fizzer",
        "userpicture": "/media/users/fizzer/profile.jpeg",
        "id": "Mt2yR3",
        "hidden": 0
      },
      {
        "text": "amazing",
        "date": "1558992550",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "lt2yR3",
        "hidden": 0
      },
      {
        "text": "totally mindblowing, and artistically perfect! \u2764\ufe0f",
        "date": "1558992367",
        "username": "rez",
        "userpicture": "/media/users/rez/profile.png",
        "id": "MljyR3",
        "hidden": 0
      },
      {
        "text": "WOW, Very nice!",
        "date": "1558991518",
        "username": "Duke",
        "userpicture": "/img/profile.jpg",
        "id": "lljyR3",
        "hidden": 0
      },
      {
        "text": "This is by far one of the most beautiful shaders I've ever seen, and it's so smooth! :O",
        "date": "1558991422",
        "username": "farazfp",
        "userpicture": "/img/profile.jpg",
        "id": "MtjyR3",
        "hidden": 0
      },
      {
        "text": "Gorgeous!",
        "date": "1558991138",
        "username": "bignobody",
        "userpicture": "/media/users/bignobody/profile.jpeg",
        "id": "ltjyR3",
        "hidden": 0
      },
      {
        "text": "Astounding!",
        "date": "1558990752",
        "username": "crocidb",
        "userpicture": "/media/users/crocidb/profile.jpeg",
        "id": "4l2czc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3lB3Rc",
      "date": "1560496059",
      "viewed": 182,
      "name": "Double Simplex Truchet Weave",
      "username": "Shane",
      "description": "Continuing on from BigWIngs's double simplex Truchet weave pattern.",
      "likes": 18,
      "published": 3,
      "flags": 0,
      "tags": [
        "simplex",
        "truchet",
        "pattern",
        "double",
        "weave"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n\n\n\tDouble Simplex Truchet Weave\n\t----------------------------\n\n\tAll too often, I'll be in the middle of coding something, then someone on \n    Shadertoy will post some interesting concept that sends me off on a tangent. \n\tBigWIngs puts up a lot of examples along those lines.\n\n    The other day, he posted a double quad Truchet that resulted in a really \n\tintense looking weave pattern -- The link is below. The basic premise was to \n\tdouble the usual amount of connecting points per side, then run\trandom \n\tsegments between them. It's such a simple idea, but opens up a heap of \n\tpossibilities.\n\n\tAnyway, BigWIngs also sketched up a very basic double sided simplex weave as \n\ta proof of concept, so this is just an extension on it.\n\n\tI was pleasantly surprised by how quickly it came together. Most of the time,\n\tthings that should take five minutes wind up taking much longer. The process\n\twas relatively quick because I was able to repurpose my quad version without\n\ttoo many incidents.\n\n\tIn regard to the lighting, I basically hacked away with a few samples to get \n\tthe look I wanted. There's very little science in there, so I wouldn't take \n\tany of it seriously... And I hope you like a monochrome palette -- It's the\n\tone I choose when I'm too lazy to make colors work. :D Either way, there's a\n\t\"CENTER_STRIPE\" define there for anyone who requires a splash of color.\n\n    Like the quad variation, if you wanted to produce a 3D extruded version,\n\tyou'd probably have to replace the Bezier curves with a mixture of arcs and \n\tlines, as it would be much faster.\n\n\tAt some point, I'd like to put together a proper 3D version, but I should \n\tprobably get back to what I'm supposed to be coding at the moment. :)\n\n\n\n\tBased On:\n\n    Double Triangle Truchet Doodle- BigWIngs\n\thttps://www.shadertoy.com/view/Ml2yzD\n\n\tCube-mapped Double Quad Truchet - BigWIngs\n\thttps://www.shadertoy.com/view/wlSGDD\n\n    Double Sided Quad Truchet - Shane\n\thttps://www.shadertoy.com/view/wl2GRG\n\n\n*/\n\n// I was undecided as to whether I wanted color, or not. Perhaps too busy?\n// Anyway, I've included it as an option.\n//#define CENTER_STRIPE\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.197)))*43758.5453); }\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n    \n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worse coding ever. :D\n    float l = length(b.xy - a.xy)*(1.4142 - 1.)/1.4142;\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary.\n    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to from the smooth Bezier arc from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :D\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n \n\nvec4 triPattern(vec2 p){\n    \n    \n    \n    // Scaling constant.\n    const float gSc = 4.;\n    p *= gSc;\n    \n    // Keeping a copy of the orginal position.\n    vec2 oP = p;\n    \n    // Smoothing factor: This can do my head in, sometimes. If you don't take screen\n    // resolution into account, the fullscree image can look too blurry. If you do, the\n    // image can look too crisp and lose something in the translation... Then there's PPI\n    // to consider... Damned if you do, damned if you don't. :D\n    float sf = 4./450.*gSc;\n    //float sf = 4./min(750., iResolution.y)*gSc;\n    \n    \n     \n    // SIMPLEX GRID SETUP\n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    //float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    //vec2 ioffs = vec2(1. - i, i);\n    \n    // Amalgamating to the two lines above into this.\n    vec2 ioffs = p.x < p.y? vec2(0, 1) : vec2(1, 0);\n    \n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269);\n    \n    // Make the vertices match up by swapping two of the vertices on alternate triangles. \n    // Actually, it's not really necessary here, but if you want to check neighboring\n    // properties, etc, it's a habit worth getting into.\n    if(ioffs.x<.5) { vec2 tmp = ip0; ip0 = ip2; ip2 = tmp; }\n    \n    \n    // Centralize everything, so that vec2(0) is in the center of the triangle.\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n    //\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\n    \n   \n    \n    \n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges. There are faster ways to achieve this, but this will do.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    \n    // Connecting points around the triangles. Two for each side. I should probably\n    // use a bit of trigonometry and hard code these, but I was feeling lazy. :)\n    const float offs = 1./6.;\n    vec2 m01s = mix(ip0, ip1, .5 + offs);\n    vec2 m01t = mix(ip0, ip1, .5 - offs);\n    vec2 m12s = mix(ip1, ip2, .5 + offs);\n    vec2 m12t = mix(ip1, ip2, .5 - offs);\n    vec2 m20s = mix(ip2, ip0, .5 + offs);\n    vec2 m20t = mix(ip2, ip0, .5 - offs);\n    \n    // The boundary normals for each point. I should probably hardcode these as well.\n    vec2 n01 = -normalize(mix(ip0, ip1, .5));\n    vec2 n12 = -normalize(mix(ip1, ip2, .5));\n    vec2 n20 = -normalize(mix(ip2, ip0, .5));\n    \n    // Points, and their respective normals, to pass to the segment function.\n    vec4[6] pnt = vec4[6](vec4(m01s, n01), vec4(m01t, n01), \n                          vec4(m12s, n12), vec4(m12t, n12),\n                          vec4(m20s, n20), vec4(m20t, n20));\n    \n    \n    \n    // Shuffling the 6 array points and normals. I think this is the Fisher\u2013Yates method, \n    // but don't quote me on it. It's been a while since I've used a shuffling algorithm, \n    // so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    for(int i = 5; i>0; i--){\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each triangle: The figure \"s*3 + ioffs + 1\" is unique for\n        // each triangle... I can't remember why I felt it necessary to divide by 3,\n        // but I'll leave it in there. :)\n        float rs = hash21((s*3. + ioffs + 1.)/3. + fi/6.);\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*6e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n        \n    }    \n\n    \n    vec3 d; // Distances for all three triangle cell segments.\n    \n    float dPnt = 1e5; // Distance for the edge points.\n    \n    for(int i = 0; i<3; i++){\n        \n        // The Bezier segments for each layer.\n        d[i] =  doSeg(p,  pnt[i*2], pnt[i*2 + 1], offs);\n        \n        // The two edge points for each side.\n        dPnt = min(dPnt, length(p - pnt[2*i].xy));\n        dPnt = min(dPnt, length(p - pnt[2*i + 1].xy));\n    }\n    \n    \n    d -= .05; // Giving the segment some width.\n    dPnt -= .0125; // Edge point size.\n    \n  \n    // Overall cell color and bump value.\n    vec3 col = vec3(.5);\n    float bump = .5;\n    \n    // Concentric triangle background pattern.\n    float pat = clamp(cos(tri*96.)*.5 + .5, 0., 1.);\n    \n    // Background triangle borders.\n    col = mix(col, col*1.5, 1. - smoothstep(0., sf, tri - .01));\n    col = mix(col, col*.5, 1. - smoothstep(0., sf, tri - .0));\n \t\n    // Applying the background pattern to the color and bump value.\n    col *= (1. - pat*.5);\n \tbump *= (1. - pat);\n\n     \n    // Extra base shadowing for the bump pass.\n    bump = mix(bump, 0., (1. - smoothstep(0., sf*3., min(min(d.x, d.y), d.z) - .03))*.5);\n\n    \n    // Rendering the layers. The bump value is similar to the color value, but differs slightly,\n    // in places so ultimately needs its own variable. Obviously, this means double up on \n    // calculations, but thankfully, this is a 2D... ish example.\n    for(int i = 0; i<3; i++){\n        \n        // Shadows, stroke, color, etc.\n        col = mix(col, vec3(.0), (1. - smoothstep(0., sf*3., d[i] - .03))*.85);\n        col = mix(col, vec3(.0), 1. - smoothstep(0., sf, d[i] - .02));\n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, d[i]));\n        col = mix(col, vec3(.03), 1. - smoothstep(0., sf, d[i] + .01));\n        #ifdef CENTER_STRIPE\n        col = mix(col, vec3(1, .05, .2), 1. - smoothstep(0., sf, d[i] + .065));\n        #endif\n        \n        // Bump shadow, stroke, etc.\n        bump = mix(bump, 0., (1. - smoothstep(0., sf*2., d[i] - .02))*.5);\n        bump = mix(bump, 0., (1. - smoothstep(0., sf, d[i] - .01)));\n        bump = mix(bump, .8, 1. - smoothstep(0., sf, d[i]));\n        bump = mix(bump, .5, 1. - smoothstep(0., sf, d[i] + .01));\n        #ifdef CENTER_STRIPE\n        bump = mix(bump, 0., 1. - smoothstep(0., sf, d[i] + .06));\n        bump = mix(bump, 1., 1. - smoothstep(0., sf, d[i] + .065));\n        #endif\n        \n    }\n    \n    // The edge points -- Tweaked a little to resemble rivots, or somthing like that.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dPnt));\n    col = mix(col, vec3(.4), 1. - smoothstep(0., sf, dPnt + .01));\n    \n    // Edge point bump values.\n    bump = mix(bump, 1., 1. - smoothstep(0., sf, dPnt - .01));\n    bump = mix(bump, 0., 1. - smoothstep(0., sf, dPnt));\n    bump = mix(bump, 1., 1. - smoothstep(0., sf, dPnt + .01));\n\n    \n    // Return the color and bump value.\n    return vec4(col, bump);\n    \n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*.5)/min(750., iResolution.y);\n    \n    // Scaling and translation.\n\tuv = rot2(3.14159/12.)*(uv + vec2(.1, .05)*iTime);\n     \n    // Three color samples.\n    vec4 col = triPattern(uv);\n    vec2 eps = normalize(vec2(1.732, 3))*.002;\n    vec4 col2 = triPattern(uv - eps);\n    vec2 eps2 = normalize(vec2(-1.732, 3))*.002;\n    vec4 col3 = triPattern(uv - eps2);\n    \n    // Using the samples for a bit of highlighting.\n    float b = max(col2.w - col.w, 0.)/length(eps)*.025;\n    float b2 = max(col3.w - col.w, 0.)/length(eps2)*.025;\n    \n    // Adding blue and reddish highlights. Mostly fake, but vaguely based on the\n    // concept of directional derivative lighting.\n    col.xyz += col2.xyz*(.15 + vec3(.25, .5, 1)*pow(b, 2.)/2.);\n    col.xyz += col3.xyz*(.15 + vec3(1, .3, .1)*pow(b2, 2.)/2.);\n    \n    // Mixing in some extra blue and red. Also fake. :)\n    col = mix(col*vec4(.75, 1, 1.25, 1), col*vec4(1.6, .9, .75, 1),(b + b2)*.5);\n    \n        // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.xzyw, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625));\n\n \n    // Rough gamma correction, then output to the screen.\n    fragColor = sqrt(max(col, 0.));\n    \n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "@BigWIngs\nThat idea of yours was a fun diversion. The triangular version probably has more 3D surface applications, but I think I like the quad pattern more. On a side note, I'm tempted to put together a Wang tile variation, but I'd imagine everyone's a little Trucheted out for now. :)\n\n@flockaroo\nI was thinking about how this would apply to some of your examples whilst making this.",
        "date": "1560741202",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "MtSyW3",
        "hidden": 0
      },
      {
        "text": "wow, this is pretty!!",
        "date": "1560618556",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "XlByW3",
        "hidden": 0
      },
      {
        "text": "really nice",
        "date": "1560528650",
        "username": "elenzil",
        "userpicture": "/media/users/elenzil/profile.jpeg",
        "id": "Ml2yWV",
        "hidden": 0
      },
      {
        "text": "Beautiful as always!",
        "date": "1560526575",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "ll2yWV",
        "hidden": 0
      },
      {
        "text": "Cool! I like how outlining highlights all the arcs.",
        "date": "1560504674",
        "username": "Yusef28",
        "userpicture": "/img/profile.jpg",
        "id": "ll2cDK",
        "hidden": 0
      },
      {
        "text": "Nice. Colours are greeat",
        "date": "1560503513",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "lt2cDK",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3lS3Wy",
      "date": "1560865595",
      "viewed": 65,
      "name": "ChromaMax colorspace",
      "username": "robobo1221",
      "description": "little colorspace project im working on",
      "likes": 1,
      "published": 3,
      "flags": 32,
      "tags": [
        "colorspace",
        "chromamax"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define max3(a) max(a.x, max(a.y, a.z))\n\nvec4 rgb2cm(vec3 rgb){\n\tfloat maximum = max3(rgb);\n    return vec4(rgb / max(maximum, 1e-32) - maximum, exp2(-maximum));\n}\n\nvec3 cm2rgb(vec4 cm){\n    float maximum = -log2(cm.a);\n\treturn clamp(cm.rgb + maximum, 0.0, 1.0) * maximum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 chromaMaxTex = texture(iChannel0, uv);\n    vec3 color = cm2rgb(chromaMaxTex);\n        \n    fragColor = vec4(color,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4dfGRn",
            "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
            "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "#define max3(a) max(a.x, max(a.y, a.z))\n\nvec4 rgb2cm(vec3 rgb){\n\tfloat maximum = max3(rgb);\n    return vec4(rgb / max(maximum, 1e-32) - maximum, exp2(-maximum));\n}\n\nvec3 cm2rgb(vec4 cm){\n    float maximum = -log2(cm.a);\n\treturn clamp(cm.rgb + maximum, 0.0, 1.0) * maximum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.0);\n         color = texture(iChannel0, uv).rgb;\n    \n    vec4 chromaMax = rgb2cm(color);\n        \n    fragColor = chromaMax;\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3lj3WG",
      "date": "1560951420",
      "viewed": 59,
      "name": "Volumetric Lighting Experiment",
      "username": "SSHantaram",
      "description": "Volumetric absorption and scattering",
      "likes": 0,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching",
        "volume",
        "lighting"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\nconst float VOLUME_STEP = 0.03;\nconst float VOLUME_STEP_LIGHT = 0.1;\nconst float VOLUME_DENSITY = 0.04;\nconst float LIGHT_INTESITY = 0.03;\n\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    // interpolate between hashes of adjacent grid points\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// 3D noise layered in several octaves\nfloat layeredNoise(in vec3 x) {\n    x += vec3(10.0, 5.0, 6.0);\n    return 0.6*noise(x*5.0) + 0.4*noise(x*10.0) + 0.2*noise(x*16.0) - 0.2;\n}\n\n// singed distance function of the y=0 plane\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float r) {\n    return length(center - p) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n// singed distance function to enire scene\nfloat sceneSDF(vec3 samplePoint) {\n   \t//float sphere = sphereSDF(samplePoint, vec3(0.0, 0.0, 0.0), 1.0);\n    float box = boxSDF(samplePoint, vec3(1.5, 1.0, 1.5));\n    //return sphere;\n    return box;\n}\n\nfloat sampleVolume(vec3 p, float densityMultiplier) {\n    return layeredNoise(p)*densityMultiplier;\n}\n\n// integrate density along ray\nfloat marchDensity(vec3 startPoint, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float density = 0.0;\n    float d;\n    vec3 samplePoint;\n    \n    while (depth < end) {\n        samplePoint = startPoint + depth * marchingDirection;\n    \td = sceneSDF(samplePoint);\n        // outside volume\n        if (d > EPSILON) {\n            depth += d;\n        }\n        // inside volume\n        else {\n            // sum desity values\n         \tdensity += sampleVolume(samplePoint, VOLUME_DENSITY)*min(-d, VOLUME_STEP_LIGHT);\n            depth += VOLUME_STEP_LIGHT;\n        }\n        // opaque: stop early\n        if (density >= 1.0) return 1.0;\n    }\n    return density;\n}\n\nfloat volumeAbsorption(float lightIntensity, float acumulatedDensityToPoint) {\n    return max(0.0, lightIntensity - acumulatedDensityToPoint);\n}\n\n// integrate illumination along ray\nfloat marchVolumetricLighting(vec3 eye, vec3 marchingDirection, vec3 lightPos, float start, float end) {\n    float depth = start;\n    float accumulatedDensity = 0.0;\n    float brightness = 0.0;\n    float d;\n    vec3 samplePoint;\n    \n    while (depth < end) {\n        samplePoint = eye + depth * marchingDirection;\n    \td = sceneSDF(samplePoint);\n        // outside volume\n        if (d > EPSILON) {\n            depth += d;\n        }\n        // inside volume\n        else {\n            float densityAtPosition = sampleVolume(samplePoint, VOLUME_DENSITY);\n            // integrated density between eye and point\n            accumulatedDensity += densityAtPosition*min(-d, VOLUME_STEP);\n            // get integrated density between point and light\n            vec3 lightRay = vec3(lightPos - samplePoint);\n            float acumulatedDensityToLight = marchDensity(samplePoint, normalize(lightRay), start, end);\n            // point brightness is dimmed by volume between eye and point\n            float pointBrightness = volumeAbsorption(LIGHT_INTESITY, acumulatedDensityToLight);\n            // sum up brightness values along ray\n            brightness += volumeAbsorption(pointBrightness, accumulatedDensity);\n            depth += VOLUME_STEP;\n        }\n        if (brightness >= 1.0) return 1.0;\n    }\n    return brightness;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// estimate normal by aproximatind the first deriviative of the sceneSDF\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// generate camera transform\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n   \t//vec3 eye = vec3(0.0, -5.0, -6.0);\n    vec3 eye = vec3(6.0*cos(iTime*0.1), -3.0, 6.0*sin(iTime*0.1));\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * viewDir;\n    vec3 lightPos = vec3(1.2*cos(iTime), 1.0, 1.2*sin(iTime));\n    \n    float brightness = marchVolumetricLighting(eye, worldDir, lightPos, MIN_DIST, MAX_DIST);\n\n    \n    vec3 color = vec3(1.0, 1.0, 1.0)*brightness;\n    \n    fragColor = vec4(color, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3lj3zt",
      "date": "1560867159",
      "viewed": 175,
      "name": "Contoured Layers",
      "username": "Shane",
      "description": "Constructing some concise contoured layers, then applying various edge and shading effects to produce some faux depth.",
      "likes": 22,
      "published": 3,
      "flags": 0,
      "tags": [
        "noise",
        "shadow",
        "gradient",
        "edge",
        "derivative",
        "contour",
        "layer"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4sXGRn",
            "filepath": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
            "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n\n\tContoured Layers\n\t----------------\n\n\tConstructing some concise contoured layers, then applying various edge and shading \n\teffects to produce some faux depth. Technically, that's what is happening here, but\n\tthis example was mainly put together as a means to demonstrate various layering\n    effects, like strokes, highlights, shadows, etc. No 3D was harmed during the making\n\tof this example. :)\n\n\tI love those contoured noise-based paper layer images that various graphic artists\n\tfrom places like Adobe distribute with their applications. Most consist of some\n\tantialiased noise layers rendered in a flat tone with drop shadows for each. The \n\tfancier ones sometimes include highlighted edges, etc, which is what I've put \n\ttogether here. None of it is difficult to produce, provided you're happy with\n\tconcept of smoothing layers at a particular threshold with respect to the field\n\tderivative.\n\n\tI put in a few diferent aesthetic options to try, just to show how much something\n\tlike a simple palette change, drop shadow, etc, can effect the overall feel. I've\n    tuned most settings on by default, but turning them off can give a cleaner look. \n\tTurning everything off, except the shadows will give the minimal contoured images\n\tyou see around, which I happen to like also.\n\n\tAnyway, feel free to play around with the defines below. At some stage, I might\n    render some icons and allow the various options to be manipulated via the mouse,\n\tbut for now, this will suffice.\n\n\tI also have a few raymarched 3D versions that I'll put up at a later date.\t\n\n\n*/\n\n// Dropping down a blurry dark layer to give a fake ambient occlusion effect.\n// It's subtle, but gives things a bit more depth. However, turning it off gives\n// a crisper look. I guess it depends what you're after.\n#define FAKE_AO\n\n// Controur strokes are great for that hand drawn look, or just to give some definition\n// to geometry. This one is dark, but it can be any color.\n#define STROKE\n\n// Highlights, to give the impression that light is hitting the surface.\n#define HILIGHT\n\n// Shadows: There aren't too many times when I wouldn't want shadows, but I can think\n// of a few. If expense if a problem, you can fake it with a thicker AO layer, but it's\n// not quite the same.\n#define SHADOW\n\n// Include the metallic texture. I overuse this particular texture, but it's the only\n// one on Shadertoy with a fine enough grade on it. I'm hoping more subtle textures\n// will get added at some stage. :)\n#define TEXTURED\n\n// Running a cheap hatch-like algorithm over the layers for a bit of extra texture.\n// Come to think of it, it's probably more of a stipple pattern... Either way, it's\n// just a little extra texture.\n#define HATCH\n\n// Very subtle paper grain. It's pretty simple, and I think it came from one of\n// Flockaroo's examples.\n//#define PAPER_GRAIN\n\n// Palette: It's amazing how something as simple as color choice can effect the feel\n// of an image.\n// Settings: Greyscale: 0, Red: 1, Blue: 2, Earth: 3, Pink and grey: 4.\n#define PALETTE 0\n\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// vec3 to float hash.\nfloat hash21( vec2 p ){ \n     \n    return fract(sin(dot(p, vec2(41, 289)))*45758.5453); \n   \n    //p.x = fract(sin(dot(p, vec2(1, 113)))*45758.5453);\n    //return sin(p.x*6.2831853 + iTime); \n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime); \n    \n}\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values, but that's not an issue here.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n\n\n// The map function. Just two layers of gradient noise. Way more interesting\n// functions are possible, but we're keeping things simple.\nfloat map(vec3 p, float i){\n    \n    return n2D3G(p.xy*3.)*.66 + n2D3G(p.xy*6.)*.34 + i/10.*1. - .15;\n  \n}\n\n\n// 2D derivative function.\nvec3 getNormal(in vec3 p, float m, float i) {\n\t\n    vec2 e = vec2(.001, 0);\n    \n    // Four extra samples. Slightly better, but not really needed here.\n\t//return (vec3(map(p + e.xyy, i) - map(p - e.xyy, i), map(p + e.yxy, i) - map(p - e.yxy, i),\t0.))/e.x*.7071;\n\n    // Three samples, but only two extra sample calculations. \n    return (vec3(m - map(p - e.xyy, i), m - map(p - e.yxy, i),\t0.))/e.x*1.4142;\n}\n\n// The map layer and its derivative. To produce constant width layer edges, the derivative\n// is necessary, so the distance field value and the derivative at the point is returned.\nvec4 mapLayer(in vec3 p, float i){\n    \n    vec4 d;\n    \n    d.x = map(p, i); // Distance field value.\n    \n    d.yzw = getNormal(p, d.x, i); // Derivative.\n    \n    return d;\n    \n}\n\n\n\n// Layer color. Based on the shade, layer number and smoothing factor.\nvec3 getCol(vec2 p, float sh, float fi, float sf){\n     \n    // Color.\n    vec3 col;\n\n    \n    #if PALETTE == 0\n        // Light attenuation palette.\n    \tcol = vec3(1)*(1. - .75/(1. + sh*sh*2.));\n    \t//col = vec3(sh*sh*.65 + .22);\n        //col = vec3(sh*.5 + .2); \n        // Etc.\n    #elif PALETTE == 1\n        col = pow(min(vec3(1.5, 1, 1)*(sh*.35 + .6), 1.), vec3(1, 3, 16));\n        if(fi==0.) col = vec3(.35, .05, .3);\n        col = mix(col.xzy, col, sh*.5 + .5);\n    #elif PALETTE == 2\n        col = pow(min(vec3(1.5, 1, 1)*(sh*.35 + .6), 1.), vec3(1, 3, 16));\n        if(fi==0.) col = vec3(.6, .2, .07);\n        col = mix(col.xzy, col, sh*.5 + .5).zyx;\n    #elif PALETTE == 3\n        if(fi==0.) col = vec3(.25, .52, .75);\n        if(fi==1.) col = vec3(.8, .8, .6);\n        if(fi==2.) col = vec3(.75, .6, .5);\n        if(fi==3.) col = vec3(.6, .58, .5);\n        if(fi==4.) col = vec3(.5, .72, .4);\n        if(fi==5.) col = vec3(.65, .85, .5);\n    #else\n    \tif(mod(fi, 2.)<.5) col = vec3(.25, .15, .2);\n    \telse col = vec3(1, .15, .4)*.8;\n    #endif\n    \n      \n    #ifdef TEXTURED\n    vec3 tx = texture(iChannel0, p + hash21(vec2(sh, fi))).xyz; tx *= tx;\n    col = min(col*tx*3., 1.);\n    #endif\n\n    \n    return col;\n    \n}\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    // If the \"HATCH\" define is on, produce the pattern.\n    #ifdef HATCH\n    \n        // The pattern is physically based, so needs to factor in screen resolution.\n        p *= res/16.;\n\n        // Random looking diagonal hatch lines.\n        float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n        // Slight randomization of the diagonal lines, but the trick is to do it with\n        // tiny squares instead of pixels.\n        float hRnd = hash21(floor(p*6.) + .73);\n        if(hRnd>.66) hatch = hRnd;  \n\n        #ifdef TEXTURED\n        hatch = hatch*.75 + .5; // Stronger hatching for the textured version.\n        #else\n        hatch = hatch*.5 + .75;\n        #endif\n\n        return hatch;\n    \n    // If the hatch define is off, cancel it out.\n    #else\n    \n    \treturn 1.;\n    \n    #endif \n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates. Setting a minumum resolution on the\n    // fullscreen setting in an attempt to keep things relatively crisp.\n    float res = min(iResolution.y, 700.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    \n    // Scaling and translation.\n    vec2 p = uv;// + vec2(1, 0)*iTime;\n\n    // Resolution based smoothing factor. Later, the contour derivative will\n    // be factored in.\n    float sf = 1./iResolution.y;\n \n    // Initialize to the first layer color.\n    vec3 col = getCol(p, 0., 0., sf);\n    \n    // Previous layer variable.\n    float pL = 0.;\n    \n    \n    // Random looking diagonal hatch lines.\n    float hatch = doHatch(p, res);\n    \n\t\n    \n    // Applying the cross hatch.\n    col *= hatch;\n    \n    // Number of layers.\n    int lNum = 5;\n    float flNum = 5.;\n    \n    \n    for(int i = 0; i<lNum; i++){\n        \n        \n        float fi = float(i);\n        \n        // Repositioning the hatch lines on each layer to reduce the \"shower screen effect,\" \n        // as per Fabrice Neyret's suggestion. :)\n        hatch = doHatch(p + sin(vec2(41, 289)*fi), res);\n       \n        // The map layer value (just some gradient noise), and its derivative.\n        vec4 c = mapLayer(vec3(p, 1.), fi);\n        // Offset noise layer value with derivative. It's offset so as to coincide with\n        // to the directional lighting.\n        vec4 cSh = mapLayer(vec3(p - vec2(.03, -.03)*((flNum - fi)/flNum*.5 + .5), 1.), fi);\n         \n        // Shade.\n        float sh = (fi + 1.)/(flNum);\n         \n        // Layer color.\n        vec3 lCol = getCol(p, sh, fi + 1., sf);\n\n        // Some standard direct lighting to apply to the edge layer. It's set in a\n        // direction to compliment the shadow layer.\n        vec3 ld = normalize(vec3(-1, 1, -.25));\n        vec3 n = normalize(vec3(0, 0, -1) + c.yzw);\n        float diff = max(dot(ld, n), 0.);\n        #ifdef TEXTURED\n        diff *= 2.5; // Add a bit more light to the edges for the textured version.\n        #else\n        diff *= 2.;\n        #endif\n        \n        \n        // Applying the diffuse lighting to the edge layer.\n        vec3 eCol = lCol*(diff + 1.);\n        \n        // Apply the layers.\n    \n        // Smoothing factor, based on the distance field derivative.\n    \tfloat sfL = sf*length(c.yzx)*2.;\n    \tfloat sfLSh = sf*length(cSh.yzx)*6.;\n        \n        // Drop shadow.\n        #ifdef SHADOW\n        #ifdef TEXTURED\n        const float shF = .5;\n        #else\n        const float shF = .35;\n        #endif\n        col = mix(col, vec3(0), (1. - smoothstep(0., sfLSh, max(cSh.x, pL)))*shF);\n        #endif\n        \n        // Dark blurred layer.\n        #ifdef FAKE_AO\n\t\tcol = mix(col, vec3(0), (1. - smoothstep(0., sfL*3., c.x))*.25);\n        #endif\n        \n        // Dark edge stroke.\n        #ifdef STROKE\n        col = mix(col, vec3(0), (1. - smoothstep(0., sfL, c.x))*.85);\n        #endif\n        \n        // Hilight and color layer.\n        #ifdef HILIGHT\n        col = mix(col, eCol*hatch, (1. - smoothstep(0., sfL, c.x + length(c.yzx)*.003)));\n        col = mix(col, lCol*hatch, (1. - smoothstep(0., sfL, c.x + length(c.yzx)*.006)));\n        #else\n        col = mix(col, lCol*hatch, (1. - smoothstep(0., sfL, c.x + length(c.yzx)*.0025)));\n        #endif\n        \n        // Previous layer, to take away from the shadow.\n        pL = c.x;\n        \n    }\n    \n    \n    \n    // Mixing in a little extra noisy color for the default greyscale textured setting.\n    #ifdef TEXTURED\n    #if PALETTE == 0\n\tcol *= mix(vec3(1.8, 1, .7).zyx, vec3(1.8, 1, .7).xzy, n2D(p*2.));\n    #endif\n    #endif\n\n\n    \n    // Paper.\n    #ifdef PAPER_GRAIN\n    vec3 rn3 = vec3(n2D((uv*iResolution.y/1. + 1.7)) - n2D(vec2(uv*iResolution.y/1. + 3.4)));\n    col *= .93 + .07*rn3.xyz  + .07*dot(rn3, vec3(.299, .587, .114));\n    #endif\n    \n            \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col*vec3(.3, 0, 1), col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Very niice! great color choices and the texture reminds me of denim. Also I like how you did the edges.",
        "date": "1560893536",
        "username": "Yusef28",
        "userpicture": "/img/profile.jpg",
        "id": "XljyD3",
        "hidden": 0
      },
      {
        "text": "I love the comics style of this shader, it looks really nice :D",
        "date": "1560889682",
        "username": "jaszunio15",
        "userpicture": "/img/profile.jpg",
        "id": "4tjyD3",
        "hidden": 0
      },
      {
        "text": "Very pretty",
        "date": "1560873876",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4l2yW3",
        "hidden": 0
      },
      {
        "text": "nice (as always :-) )\nsuggestion:  there is a shower door effect since the small pattern is the same in screen space whatever the layer. -> you could add a layer-dependent offset in the pattern.\n",
        "date": "1560871593",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4t2yW3",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3lj3zy",
      "date": "1560052580",
      "viewed": 349,
      "name": "Give it Moire",
      "username": "willstall",
      "description": "Just a simple wallpaper screensaver w/ too much moire",
      "likes": 3,
      "published": 3,
      "flags": 0,
      "tags": [
        "moire"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#ifdef GL_ES\n    precision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n#define SECONDS 60.0\n\nfloat random(vec2 st){ return fract(sin(dot(st.yx,vec2(14.7891,43.123)))*312991.41235); }\nfloat random (in float x) { return fract(sin(x)*43758.5453123); }\n\nfloat cell_random(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    return mix(random(iPos), random(iPos + 1.0), smoothstep(0.,1.,fract(x*scale)));\n}\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nfloat lines(vec2 st)\n{\n    st -= st.y-st.x;    // go diagonal\n    return sin(st.x*10.0);\n}\n\nvec2 map(vec2 st, float t)\n{\n    vec2 pos = vec2(0.0);\n        pos += vec2(0.4)*rotate(TWO_PI*t);\n    \n    st = st-pos;\n\n    float freq = mix(1.5,2.25,cell_random(sin(PI + iTime*.15),5.0));\n    float amount = mix(0.08,0.35,cell_random(sin(TWO_PI*.75+iTime*.0025),10.0));\n    float c = length(st);\n    float sq = mix(1.0,10.0, cell_random(sin(PI + iTime*.005),50.0));\n    float scale = mix(sq,4.0,0.5+0.5*sin(st.x*st.y*st.y*4.0));\n    vec2 uv = st + (c)*freq*cos(c*scale-TWO_PI*4.0)*amount;\n\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = fragCoord/iResolution.xy;\n    float t = fract(iTime/SECONDS);\n\n    st = center(st);\n    st = st * 2.0 - 1.0;\n    st *= rotate(PI*0.25);\n\tst *= rotate(TWO_PI*iTime*0.0015);\n\n    vec2 m = map(st,t);\n\n    float r = cell_random(length(m)+iTime*0.023,10.0);\n\n    float stripes = sin(m.x*50.0);\n    float d = dot(m,st)+0.1;\n\n    float c_repeats = mix(20.0,100.0,cell_random(sin(iTime*.035),10.0));\n\n    vec3 c_sin = cos(vec3(0.15,.32,0.3)+d*c_repeats + iTime );\n    vec3 color = c_sin-d-stripes;\n        color += r;\n\n    fragColor = vec4(color,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3ljGzd",
      "date": "1560770450",
      "viewed": 98,
      "name": "Fl_ow",
      "username": "klk",
      "description": "Sine plasma in polar coordinates\nMouse click to unsmooth",
      "likes": 3,
      "published": 3,
      "flags": 0,
      "tags": [
        "plasma",
        "sine",
        "polar"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define PI 3.141592654\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.yy*2.;\n    float a=(atan(uv.x,uv.y)/2./PI)+.5;\n    float l=length(uv);\n    float w=0.1/(1.+l);\n/*    \n    a=uv.x*0.05;\n    l=uv.y*0.05+.4;\n    w=0.1;\n*/    \n    l*=(1.+w*sin(a*10.*PI));\n    a+=w*sin(l*1.1*PI)-iTime*0.05;\n    l*=(1.+w*sin(a*16.*PI));\n    a+=w*sin(l*2.6*PI)+iTime*0.05;\n    l*=(1.+w*sin(a*22.*PI));\n    a+=w*sin(l*4.1*PI)-iTime*0.05;\n    l*=(1.+w*sin(a*28.*PI));\n    a+=w*sin(l*5.6*PI)+iTime*0.05;\n\n    float r=a*12.+l-iTime*.2;\n    float g=l*3.+a+iTime*.3;\n    float b=-a*6.+l*2.+iTime*.25;\n    \n    vec3 c=vec3(\n        fract(r)>.5?0.:1.,\n        fract(g)>.5?0.:1.,\n        fract(b)>.5?0.:1.\n    );\n    \n    if(iMouse.z<0.1)\n        c=(vec3(\n    \t    sin(r*2.*PI),\n\t        sin(g*2.*PI),\n        \tsin(b*2.*PI)\n        )+1.)*0.5;\n    \n    c=mix(vec3(.7,.9,1),vec3(.2,.5,1),sqrt(dot(c,c)))*(1.2-c*.2);\n    \n    fragColor = vec4(c,1);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3sSSzG",
      "date": "1560938690",
      "viewed": 21,
      "name": "Oak foise2",
      "username": "deerfeeder",
      "description": "A mirrored noise/",
      "likes": 1,
      "published": 1,
      "flags": 0,
      "tags": [
        "swirl",
        "perlin",
        "curl",
        "simplex"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [],
        "code": "// Fork of \"Oak foise\" by deerfeeder. https://shadertoy.com/view/MtKcD3\n// 2019-04-01 13:33:55\n\n\nconst int noiseSwirlSteps = 8;\nconst float noiseSwirlValue = 0.5;\nconst float noiseSwirlStepValue = noiseSwirlValue / float(noiseSwirlSteps);\n\nconst float noiseScale = 2.;\nconst float noiseTimeScale = 0.1;\n\n\nfloat simplex(vec3 v);\nfloat getNoise(vec3 v);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 0.5-fragCoord.xy / iResolution.xy;\n  \tuv = abs(uv);\n\tfloat noise = getNoise(vec3(uv * noiseScale, iTime*noiseTimeScale));\n    noise = noise * noise * noise * noise * 0.5;  //more contrast\n    fragColor = vec4(noise, noise, noise, 1.0);\n}\n\n\n\nfloat fbm3(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result /= (1. + 1./2. + 1./4.);\n    return result;\n}\n\nfloat fbm5(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result += simplex(v * 8.) / 8.;\n    result += simplex(v * 16.) / 16.;\n    result /= (1. + 1./2. + 1./4. + 1./8. + 1./16.);\n    return result;\n}\n\nfloat getNoise(vec3 v) {\n    //  make it curl\n    for (int i=0; i<noiseSwirlSteps; i++) {\n    \tv.xy += vec2(fbm3(v), fbm3(vec3(v.xy, v.z + 1000.))) * noiseSwirlStepValue;\n    }\n    //  normalize\n    return fbm5(v) / 2. + 0.5;\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 219.0)) * 219.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 299.0)) * 299.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*4.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.790159 - 0.3095314 * r;\n}\n\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.00, 1.0/3.00) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 3.22);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 200.0 *sin(iTime * 0.1) * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3t23Dy",
      "date": "1560978901",
      "viewed": 17,
      "name": "ray-roundbox intersection",
      "username": "bernie_freidin",
      "description": "This is a testbed for ray-roundbox intersection code.\nCurrently I'm doing a convex optimized sphere trace, but I wonder if there is an analytic solution?",
      "likes": 0,
      "published": 1,
      "flags": 16,
      "tags": [
        "raytrace",
        "analytic",
        "roundbox"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGRr",
            "filepath": "/presets/tex00.jpg",
            "previewfilepath": "/presets/tex00.jpg",
            "type": "keyboard",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "//$INPUT0=KEYBOARD\n//$OUTPUT=IMAGE\n\n// =====================================================\n// This is a testbed for ray-roundbox intersection code.\n// Currently I'm doing a convex optimized sphere trace,\n// but I wonder if there is an analytic solution?\n// \n// The function to optimize is \"RayRoundBoxIntersect\"\n// \n// keyboard controls:\n// 'C' toggles convex optimization (without this, the sphere trace is pretty inefficient)\n// 'S' toggles an 8x multiplier for numSteps\n// 'E' toggles error visualization (we want this to show nothing)\n// =====================================================\n\n#define RAY_ROUNDBOX_MAX_STEPS (6)\n#define NUM_BOXES (20)\n\n#define PI 3.14159265359\n#define FLT_REALLY_BIG 1e9;\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\nfloat max3(vec3 v) { return max(max2(v.xy), v.z); }\nfloat max4(vec4 v) { return max(max2(v.xy), max2(v.zw)); }\nfloat min2(vec2 v) { return min(v.x, v.y); }\nfloat min3(vec3 v) { return min(min2(v.xy), v.z); }\nfloat min4(vec4 v) { return min(min2(v.xy), min2(v.zw)); }\n\nfloat seed = 0.0;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\nvec2 rand2() { return vec2(rand(), rand()); }\nvec3 rand3() { return vec3(rand2(), rand()); }\nvec3 randV(vec2 s)\n{\n\tfloat cosTheta = fract(2.0*s.y);\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\tfloat phi = 2.0*PI*s.x;\n   \tfloat sinPhi = sin(phi);\n\tfloat cosPhi = cos(phi);\n    return vec3(vec2(cosPhi, sinPhi)*sinTheta, cosTheta*(s.y > 0.5 ? -1.0 : 1.0));\n}\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 dir;\n};\n\n// if roundRadius=0 then this is a box\n// if roundRadius=extent then this is a sphere\nstruct RoundBox\n{\n    mat3 localToWorld; // ortho\n    vec3 center;\n    vec3 extent;\n    float roundRadius;\n    vec3 albedo;\n};\n\nvec3 WorldToLocal(vec3 P, RoundBox box)\n{\n\treturn (P - box.center)*box.localToWorld;\n}\n\nmat3 MakeOrthoBasis(vec3 N)\n{\n\tvec3 basisX = normalize(cross(N.yzx, N));\n\tvec3 basisY = cross(N, basisX);\n\treturn mat3(basisX, basisY, N);\n}\n\nvec3 SampleHemisphere(vec3 N, float sinTheta, float cosTheta, float s_x)\n{\n\tfloat phi = 2.0*PI*s_x;\n\tfloat sinPhi = sin(phi);\n\tfloat cosPhi = cos(phi);\n\treturn MakeOrthoBasis(N)*vec3(vec2(cosPhi, sinPhi)*sinTheta, cosTheta);\n}\n\nvec3 SampleHemisphereCosineWeighted(vec3 N, vec2 s)\n{\n    float sinThetaSqr = s.y;\n\tfloat sinTheta = sqrt(sinThetaSqr);\n\tfloat cosTheta = sqrt(1.0 - sinThetaSqr);\n\treturn SampleHemisphere(N, sinTheta, cosTheta, s.x);\n}\n\n// same as distance gradient\nvec3 GetNormalAtSurfacePoint(vec3 P, RoundBox box)\n{\n\tP = WorldToLocal(P, box);\n\tif (box.roundRadius == 0.0) {\n\t\tvec3 V = P/box.extent;\n\t\tvec3 A = abs(V);\n\t\tfloat Amax = max3(A);\n\t\tvec3 N = vec3(0);\n\t\tif      (Amax == A.x) N.x = sign(V.x);\n\t\telse if (Amax == A.y) N.y = sign(V.y);\n\t\telse                  N.z = sign(V.z);\n\t\treturn N;\n\t} else {\n\t\tvec3 E = box.extent - box.roundRadius;\n\t\treturn normalize(P - clamp(P, -E, E));\n\t}\n}\n\nfloat LocalDistanceToRoundBox(vec3 P, RoundBox box)\n{\n\treturn length(max(vec3(0), abs(P) - box.extent + box.roundRadius)) - box.roundRadius;\n}\n\n// TODO -- explicit closed-form intersection test would be preferrable here, maybe?\nfloat RayRoundBoxIntersect(Ray ray, RoundBox box, bool convex, int numSteps)\n{\n\tvec3 origin = WorldToLocal(ray.origin, box);\n    vec3 dir = WorldToLocal(ray.origin + ray.dir, box) - origin;\n\tfloat t0 = 0.0;\n\tfloat t1 = FLT_REALLY_BIG;\n\tconst float thresh = 0.0001; // fixed for now .. not even sure this is useful\n\tfloat dlen = length(dir);\n\tfloat q = 1.0/dlen;\n\tvec3 P = origin;\n\tvec3 V = dir*q;\n\tt0 *= q;\n\tt1 *= q;\n\tfloat d0 = FLT_REALLY_BIG;\n\tvec3 E = box.extent - box.roundRadius;\n\tfor (int i = 0; i < numSteps; i++) {\n\t\tfloat d1 = LocalDistanceToRoundBox(P, box);\n\t\tif (d1 <= thresh)\n\t\t\tbreak;\n\t\tfloat dt = d1;\n\t\tif (convex) {\n\t\t\tvec3 G = normalize(clamp(P, -E, E) - P); // negative gradient vector\n\t\t\tdt /= dot(V, G);\n\t\t}\n\t\tt0 += dt;\n\t\tif (d1 > d0 || t0 >= t1)\n\t\t\treturn 0.0; // distance is increasing (since object is convex, we know we missed), or we extended past the end of the ray\n\t\tP = origin + V*t0;\n\t\td0 = d1;\n\t}\n\treturn t0*dlen;\n}\n\nRoundBox boxes[NUM_BOXES];\n\nint IntersectScene(Ray ray, int ignoreObjId, bool convex, int numSteps, out float out_t, out RoundBox out_box)\n{\n\tint boxId = -1;\n\tout_t = 1e5;\n\tout_box = boxes[0]; // none\n\tfor (int i = 0; i < min(0, iFrame) + NUM_BOXES; i++) {\n\t\tRoundBox box = boxes[i];\n\t\tfloat t = RayRoundBoxIntersect(ray, box, convex, numSteps);\n\t\tif (i != ignoreObjId && t != 0.0 && t < out_t) {\n\t\t\tboxId = i;\n\t\t\tout_t = t;\n\t\t\tout_box = box;\n\t\t}\n\t}\n\treturn boxId;\n}\n\nvoid InitScene()\n{\n    vec3 sceneCenter = vec3(0,0,0);\n    float sceneRadius = 20.0;\n    for (int i = 0; i < min(0, iFrame) + NUM_BOXES; i++) {\n        boxes[i].localToWorld = MakeOrthoBasis(randV(rand2()));\n        boxes[i].center = sceneCenter + sceneRadius*randV(rand2());\n        boxes[i].extent = mix(vec3(2), vec3(4), rand3());\n\t\tboxes[i].roundRadius = 1.0;\n        boxes[i].albedo = mix(vec3(0.7), vec3(0.9), rand3());\n    }\n}\n\nvec3 CreateScreenRay(vec2 screenPos, float screenAspect)\n{\n    float VFOV = 80.0;\n\tfloat tanVFOV = tan(VFOV*0.5*PI/180.0); // could precompute this\n    return normalize(vec3(screenPos*vec2(screenAspect, 1)*tanVFOV, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    fragColor = vec4(1);\n\n    vec2 sceneRes = iResolution.xy; // resolution of this buffer\n\tvec2 screenPos = 2.0*fragCoord/sceneRes - 1.0; // [-1..1]\n\n\tfloat theta = 2.0*PI*iMouse.x/iResolution.x;//2.0*PI*iTime * 0.1;\n\tvec3 camPos = vec3(sin(theta), 0, cos(theta))*50.0;\n\tvec3 lookAt = vec3(0);\n\tvec3 camZ = normalize(lookAt - camPos);\n\tvec3 camX = normalize(cross(camZ, vec3(0,1,0)));\n\tvec3 camY = cross(camX, camZ);\n\tmat3 camM = mat3(camX, camY, camZ);\n\n    Ray cameraRay;\n    cameraRay.origin = camPos;\n\tcameraRay.dir = camM*CreateScreenRay(screenPos, sceneRes.x/sceneRes.y);\n\n\t#define KEY_0 48\n\t#define KEY_C 67\n\t#define KEY_E 69\n\t#define KEY_S 83\n\tbool convexOpt = texelFetch(iChannel0, ivec2(KEY_C,2), 0).x == 0.0; // 'C' toggles convex optimization\n\tbool manySteps = texelFetch(iChannel0, ivec2(KEY_S,2), 0).x >  0.0; // 'S' toggles step multiplier x8\n\tbool showError = texelFetch(iChannel0, ivec2(KEY_E,2), 0).x == 0.0; // 'E' toggles error visualization\n\tint numSteps = 4;\n\tif (manySteps)\n\t\tnumSteps *= 8;\n\n\tRoundBox box[2];\n\tint boxId[2];\n    float t[2];\n\tboxId[0] = IntersectScene(cameraRay, -1, convexOpt, numSteps, t[0], box[0]);\n\tboxId[1] = IntersectScene(cameraRay, -1, true, 32, t[1], box[1]); // reference\n\n\tvec3 P = cameraRay.origin + cameraRay.dir*t[0];\n\tvec3 N = GetNormalAtSurfacePoint(P, box[0]);\n\tfragColor.rgb = mix(box[0].albedo, N*0.5 + 0.5, 0.3);\n\n\tif (showError && boxId[1] != boxId[0])// || abs(t[1] - t[0]) > 0.01)\n\t\tfragColor.rgb = vec3(1,0,0);\n\n\t// show the toggles\n\tfloat r = 10.0;\n\tfloat x = 24.0;\n    if (convexOpt) fragColor.rgb = mix(fragColor.rgb, vec3(1,0,0), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n    if (manySteps) fragColor.rgb = mix(fragColor.rgb, vec3(0,1,0), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n    if (showError) fragColor.rgb = mix(fragColor.rgb, vec3(0,0,1), max(0.0, 1.0 - length(fragCoord - iResolution.xy + vec2(x,24))/r)); x += 24.0;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3t23WG",
      "date": "1560942443",
      "viewed": 84,
      "name": "Cosine - distance",
      "username": "iq",
      "description": "Exact euclidean distance to a cosine wave of arbitrary amplitude, frequency, phase and offset. It is exact indeed but requires 12 iterations to get full floating point precision.",
      "likes": 7,
      "published": 3,
      "flags": 0,
      "tags": [
        "2d",
        "sdf",
        "distance",
        "cosine"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Distance to cosine wave of arbitrary amplitude, frequency, phase and offset\n// by reducing the problem to the first quadrant of a unit cosine wave, and then\n// fining the derivative of the distance squared. The problem reduces to\n//\n// For y(x) = w\u00b7cos(x)\n//\n// d\u00b2 (p,x) = (x-p.x)\u00b2 + (w\u00b7cos(x)-p.y)\u00b2\n// d\u00b2'(p,x) = 2[x-p.x - w\u00b7sin(x)\u00b7(w\u00b7cos(x)-p.y)] = 0\n//\n// I implemented two different root finders. A simple bisection method which uses\n// 24 iterations to give full floating point precision, and an 8 iterations\n// bisection followed by 4 newtown-raphson method (12 iterations total) that\n// provides full floating point precision as well. I am always worried about\n// convergence of newtwon-raphson methods, so I give it only as an option.\n\n\n\n// List of some other 2D distances:\n//\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\n// Cross:                https://www.shadertoy.com/view/XtGfzw\n// Pie:                  https://www.shadertoy.com/view/3l23RK\n// Arc:                  https://www.shadertoy.com/view/wl23RK\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\n//\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n#if 1\n//----------------------------------------------------------------------\n// Distance to y(x) = a + b*cos(cx+d)\n//----------------------------------------------------------------------\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\n#else\n\n//----------------------------------------------------------------------\n// Distance to y(x) = a + b*cos(cx+d)\n//----------------------------------------------------------------------\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n    \n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<8; i++ ) // bisection, 7 bits more or less\n    {\n        float x = 0.5*(xa+xb);\n        float si = sin(x);\n        float co = cos(x);\n        float y = x-p.x+b*c*si*(p.y-b*c*co);\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    for( int i=0; i<4; i++ ) // newtown-raphson, 28 bits more or less\n    {\n        float si = sin(x);\n        float co = cos(x);\n        float  f = x - p.x + b*c*(p.y*si - b*c*si*co);\n        float df = 1.0     + b*c*(p.y*co - b*c*(2.0*co*co-1.0));\n        x = x - f/df;\n    }\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/3.0;\n    float ca = 0.0 + 0.4*cos(t*1.1+1.0); // offset    (y position)\n    float cb = 0.3 + 0.2*cos(t*1.2+0.0); // amplitude (y scale)\n    float cc = 9.0 + 6.0*cos(t*1.3+2.0); // frequency (x scale)\n    float cd = 2.0 + 2.0*cos(t*1.0+3.0); // phase     (x position)\n    \n    // sdf\n    float d = udCos( p, ca, cb, cc, cd );\n    \n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.05 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Cool! I don't see any difference settings both loops to 1 though?",
        "date": "1560974666",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4t2cDc",
        "hidden": 0
      },
      {
        "text": "I totally missed your shader, too bad. It seems we are using the same technique (naturally, which is the simplest). I was able to remove the frequency from the equation since it can be translated into a scale factor. I didn't attempt clipping though, no.\r\n\r\nThe method seems to extend naturally to Fourier series, only that the function to  minimize becomes too wavy so finding the roots robustly probably is difficult.",
        "date": "1560945274",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4t2cWc",
        "hidden": 0
      },
      {
        "text": "does it extend easily to finite cosine segment ? \n( I did this version some time ago: [url]https://www.shadertoy.com/view/tsXXRM[/url] ).",
        "date": "1560944209",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Xt2cWc",
        "hidden": 0
      },
      {
        "text": "Wow. This is truly inspirational, I have so much to learn. Thanks again!",
        "date": "1560943041",
        "username": "vegardno",
        "userpicture": "/media/users/vegardno/profile.png",
        "id": "XljcWc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3tB3z3",
      "date": "1560380171",
      "viewed": 525,
      "name": "Hilbert R1 Blue Noise",
      "username": "paniq",
      "description": "mapping each pixel to a hilbert curve index, then taking a value from the Roberts R1 quasirandom sequence for it.",
      "likes": 24,
      "published": 3,
      "flags": 0,
      "tags": [
        "noise",
        "blue",
        "hilbert",
        "quasirandom"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define LEVEL 15U\n#define WIDTH ( (1U << LEVEL) )\n#define AREA ( WIDTH * WIDTH )\n\nuint part1by1 (uint x) {\n    x = (x & 0x0000ffffu);\n    x = ((x ^ (x << 8u)) & 0x00ff00ffu);\n    x = ((x ^ (x << 4u)) & 0x0f0f0f0fu);\n    x = ((x ^ (x << 2u)) & 0x33333333u);\n    x = ((x ^ (x << 1u)) & 0x55555555u);\n    return x;\n}\n    \nuint pack_morton2x16(uvec2 v) {\n\treturn part1by1(v.x) | (part1by1(v.y) << 1);\n}\n\n// from https://www.shadertoy.com/view/XtGBDW\nuint HilbertIndex( uvec2 Position )\n{   \n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return Index;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    #if 1\n    uint x = HilbertIndex( uvec2(fragCoord) ) % (1u << 17u);\n    #else\n    uint x = pack_morton2x16( uvec2(fragCoord) ) % (1u << 17u);    \n    #endif\n\n    float phi = 2.0/(sqrt(5.0)+1.0);\n\tfloat c = fract(0.5+phi*float(x));\n    \n    if (uv.x > 0.5) {\n    \tc = step(c, uv.y);\n    }\n    \n    fragColor = vec4(vec3(c),1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Permuting the input and output bits of the Morton function with Gray codes seems to improve the noise pattern, even if there is still some visible tiling in the noise.\n\nuint pack_morton2x16_permuted(uvec2 v) {\n      v = (v >> 1u) ^ v;\n      uint x = part1by1(v.x) | (part1by1(v.y) << 1);\n      return (x >> 1u) ^ x; \n}",
        "date": "1560546555",
        "username": "froxel",
        "userpicture": "/img/profile.jpg",
        "id": "MljyDV",
        "hidden": 0
      },
      {
        "text": "This is interesting.\n\nif (uv.x > 0.5) {\n        c = step(c, fract(iTime * 0.01));\n}",
        "date": "1560538793",
        "username": "belfry",
        "userpicture": "/img/profile.jpg",
        "id": "Mt2cWV",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3tBGzh",
      "date": "1558411135",
      "viewed": 1028,
      "name": "Biological Particles",
      "username": "wyatt",
      "description": "From free particles emerged all things. ",
      "likes": 35,
      "published": 3,
      "flags": 32,
      "tags": [
        "fluid",
        "particles",
        "dynamics",
        "naturalselection"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n\n\tFluid dynamics controls velocity field.\n\tParticles translate with the velocity field.\n\tParticles reproduce as they move. \n\tParticles diffuse  4  hormones. \n\tDiffusion is mediated by a 2 pass multi-scale gaussian blur.\n\tParticles experience a force from each hormone.\n\tThe force is proportional to their own hormone signature. \n\tEach hormone diffuses with a different radius. \n\tEach initial particle has its own hormone signature.\n\tThen they battle it out! \n\n*/\nvoid mainImage( out vec4 Q, in vec2 U)\n{\n    vec4 b = B(U);\n    vec4 h = (hash(b.w));\n    Q = smoothstep(2.,0.,length(b.xy-U))*(.5+2.*h);\n\t//Q = abs(D(U));\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// FLUID DYNAMICS\n// FORCE on FLUID = (PARTICLE)*(GRADIENT OF BUFFER D)\n\n#define R iResolution.xy\n#define A(U) texture(iChannel0, (U)/R)\n#define B(U) texture(iChannel1, (U)/R)\nvec4 T (vec2 U) {return A(U-A(U).xy);}\nvoid mainImage( out vec4 Q, in vec2 U)\n{\n    Q = T(U);\n    vec4 // neighborhood\n        n = T(U+vec2(0,1)),\n        e = T(U+vec2(1,0)),\n        s = T(U-vec2(0,1)),\n        w = T(U-vec2(1,0));\n   // FLUID DYNAMICS\n   Q.x -= (0.25*(e.z-w.z-Q.w*(n.w-s.w)));\n   Q.y -= (0.25*(n.z-s.z-Q.w*(e.w-w.w)));\n   Q.z += (0.25*((s.y-n.y+w.x-e.x)+(n.z+e.z+s.z+w.z))-Q.z);\n   Q.w += (0.25*(s.x-n.x+w.y-e.y)-Q.w);\n   // COMPUTE HORMONE FEILD\n   n = D(U+vec2(0,1));\n   e = D(U+vec2(1,0));\n   s = D(U-vec2(0,1));\n   w = D(U-vec2(1,0));\n   // THIS PARTICLE\n   vec4 b = B(U);\n   // COMPUTE HORMONE SIGNATURE\n   vec4 h = hash(b.w);\n   // SUM HORMONE FORCE\n   vec2 v = vec2(0);\n   v += h.x*vec2(e.x-w.x,n.x-s.x);\n   v += h.y*vec2(e.y-w.y,n.y-s.y);\n   v += h.z*vec2(e.z-w.z,n.z-s.z);\n   v += h.w*vec2(e.w-w.w,n.w-s.w);\n   // APPLY HORMONE FORCE TO THIS PARTICLE\n   Q.xy += v*smoothstep(1.,0.,length(U-b.xy));\n   // BOUNDARY CONDITIONS\n   if (fract(.1*iTime)<.2)Q.xy += .03*smoothstep(20.,0.,length(U-0.5*R+0.3*R*hash(floor(.1*iTime)).xy))*vec2(cos(floor(.1*iTime)),sin(floor(.1*iTime)));\n   if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.||iFrame<1)\n       Q.xyw = vec3(0);\n   \n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XsXGR8",
            "channel": 0
          }
        ],
        "code": "// SPACIALLY SORT VORONOI PARTICLES\n// ALLOW MOVING PARTICLES TO LEAVE A TRAIL OF CLONES\nvoid swap (inout vec4 Q, vec2 U, vec2 r) {\n\tvec4 n = B(U+r);\n    if (length(U-n.xy)<length(U-Q.xy)) Q = n;\n}\nvoid mainImage( out vec4 Q, in vec2 U)\n{\n    // FIND NEAREST PARTICLE\n    Q = B(U);\n    swap(Q,U,vec2(1,0));\n    swap(Q,U,vec2(0,1));\n    swap(Q,U,vec2(-1,0));\n    swap(Q,U,vec2(0,-1));\n    swap(Q,U,vec2(1,1));\n    swap(Q,U,vec2(1,-1));\n    swap(Q,U,vec2(-1,1));\n    swap(Q,U,vec2(-1,-1));\n    // LEAVE A TRIAL OF CLONES AS PARTICLE TRANSLATES\n    Q.xy += A(mix(U,Q.xy,0.7)).xy;\n    // BOUNDARY CONDITIONS\n    if ((iMouse.z>0.&&length(iMouse.xy-U)<30.)||iFrame < 1) {\n    \tQ = vec4(U,0,0);\n        Q.w = .1*(Q.x+R.x*Q.y+dot(iDate,vec4(1)));\n    }\n   \n}",
        "name": "Buffer B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4sXGR8",
            "channel": 0
          }
        ],
        "code": "// BLUR PARTICLES PASS 1\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = vec4(0);\n    for (float i = -I; i <= I; i++) {\n        vec2 x = U+vec2(i,0);\n        vec4 b = B(x);\n    \tQ += hash(b.w)*M*exp(-i*i*O)*smoothstep(1.,0.,length(b.xy-x));\n    }\n    \n}",
        "name": "Buffer C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XdfGR8",
            "channel": 0
          }
        ],
        "code": "// BLUR PASS 2\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = 0.5*D(U);\n    for (float i = -I; i <= I; i++) {\n        vec4 c = C(U+vec2(0,i));\n    \tQ += c*M*exp(-O*i*i);\n    }\n    if(iFrame<1) Q = vec4(0);\n}",
        "name": "Buffer D",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "#define R iResolution.xy\n#define A(U) texture(iChannel0, (U)/R)\n#define B(U) texture(iChannel1, (U)/R)\n#define C(U) texture(iChannel2, (U)/R)\n#define D(U) texture(iChannel3, (U)/R)\n\n\n#define S vec4(2,4,6,8)\n#define M .1*vec4(4,3,2,1)\n#define O .5/S/S\n#define I 12.\n\nvec4 hash (float p) // Dave (Hash)kins\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx)*2.-1.;\n    \n}",
        "name": "Common",
        "description": "",
        "type": "common"
      }
    ],
    "comments": [
      {
        "text": "add a \nhttps://en.wikipedia.org/wiki/The_Starry_Night\ncolor sceme and spinors.",
        "date": "1560050199",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "ll2yDy",
        "hidden": 0
      },
      {
        "text": "oh no, my blue blob caught some yellow virus  =)",
        "date": "1559599664",
        "username": "pyBlob",
        "userpicture": "/img/profile.jpg",
        "id": "Ml2cRd",
        "hidden": 0
      },
      {
        "text": "Adding mutations: (Buffer B line 21)\n    vec4 h = hash(U.x*1.3411+U.y*.54951+iTime*5.456218);\n    if (h.x > .9999)\n        Q.w += h.w*.1;",
        "date": "1559599316",
        "username": "pyBlob",
        "userpicture": "/img/profile.jpg",
        "id": "ll2cRd",
        "hidden": 0
      },
      {
        "text": "so, ant trail simulation is too boring for you? ants make nice hormone-driven cyclones of hundreds of ants, following each other in a tight circle, because they are too dumb to escape-time polar coordinates.",
        "date": "1558557332",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "MtjyzV",
        "hidden": 0
      },
      {
        "text": "Love this one. Really nice.",
        "date": "1558533927",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "lt2czK",
        "hidden": 0
      },
      {
        "text": "Sorry sorry I never know if anyone is interested, fluid dynamics controls velocity field. particles advect with the velocity field but can reproduce as they move. The particles diffuse via multi-scale gaussian blur 4  hormones. The particles experience a force from each hormone proportional to their own hormone signature. Each hormone diffuses with a different radius. Each initial particle has its own hormone signature thanks to Dave Hashkins. Then they battle it out! ",
        "date": "1558423554",
        "username": "wyatt",
        "userpicture": "/media/users/wyatt/profile.png",
        "id": "Xl2cRK",
        "hidden": 0
      },
      {
        "text": "( are you really not interested in the small effort of commenting a bit your code for people understand a bit how you do all these nice things ? for a start, just telling at the top of each buffer what this buffer is doing, for instance. )",
        "date": "1558422725",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Xt2cRK",
        "hidden": 0
      },
      {
        "text": "but how the hell are you doing all these alien patterns ? :-p",
        "date": "1558422590",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4ljcRK",
        "hidden": 0
      },
      {
        "text": ":-)",
        "date": "1558414090",
        "username": "wyatt",
        "userpicture": "/media/users/wyatt/profile.png",
        "id": "4ljyRK",
        "hidden": 0
      },
      {
        "text": "SO COOL! Looks like different kinds of mold or something fighting to survive in water. ",
        "date": "1558412074",
        "username": "Plento",
        "userpicture": "/media/users/Plento/profile.jpeg",
        "id": "XljyRK",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3tSGDy",
      "date": "1560870519",
      "viewed": 99,
      "name": "Star - distance",
      "username": "iq",
      "description": "2d distance to a n-sided polygon and start with an arbitrary angle for the arms. The distance is euclidean both in the interior and exterior.",
      "likes": 12,
      "published": 3,
      "flags": 0,
      "tags": [
        "2d",
        "sdf",
        "star",
        "distance",
        "polygon"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a regular n-sided start.\n\n// List of some other 2D distances:\n//\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\n// Cross:                https://www.shadertoy.com/view/XtGfzw\n// Pie:                  https://www.shadertoy.com/view/3l23RK\n// Arc:                  https://www.shadertoy.com/view/wl23RK\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\n//\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 6.283185/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/3.0;\n    float n = 3.0 + mod(floor(t),9.0);  // n, number of sides\n    float a = fract(t);                 // angle factor\n    float m = 4.0 + a*a*(n*2.0-4.0);    // angle divisor, between 4 and 2n\n    \n    // sdf\n    float d = sdStar( p, 0.7, int(n), m );\n    \n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.05 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3tSGWy",
      "date": "1560858521",
      "viewed": 97,
      "name": "antialiasing fract (2)",
      "username": "FabriceNeyret2",
      "description": "from base version [url]https://shadertoy.com/view/wtjGzt[/url],\nhere I add the filtering of high frequencies. #BIAS / #SPREAD to trade thresholding.\nClick to switch off.\nIn addition, note how #grad() =||dFdxy()|| improves compare to fwidth().",
      "likes": 7,
      "published": 3,
      "flags": 0,
      "tags": [
        "antialiasing",
        "fract",
        "tuto",
        "short",
        "shannonnyquist"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Self-ref: https://www.shadertoy.com/view/3tSGWy\n\n// Improved version on \"antialiasing fract\"  https://shadertoy.com/view/wtjGzt\n// dealing with antialiasing of 2 use-case of fract: ramps and bars.\n// Here: also deal with Shannon-Nyquiest filtering for high frequencies.\n\n//#define grad(x) fwidth(x)\n  #define grad(x) length(vec2(dFdx(x),dFdy(x)))\n\n// w = pixel width = grad(continous signal) . c = possibly fracted signal.\n#define Nyquist(w,c) mix(.5, c, clamp((.5-BIAS-(w))/.25/SPREAD,0.,1.) )\n\n#define BIAS -.0  // < 0: prefer a bit of aliasing to blur \n#define SPREAD 1. // < 1: transition more brutal \n\nfloat aafract(float x) {    // --- antialiased fract\n    float v = fract(x),\n          w = grad(x),      // pixel width. NB: x must not be discontinuous or factor discont out\n          c = v < 1.-w ? v/(1.-w) : (1.-v)/w; // replace right step by down slope (-> chainsaw is continuous).\n               // shortened slope : added downslope near v=1 \n    return c; \n // return Nyquist(w,c); // version with high-freq filtering integrated\n}\n\nfloat aastep(float x) {     // --- antialiased step(.5)\n    float w = grad(x),      // pixel width. NB: x must not be discontinuous or factor discont out\n          c = smoothstep(.7,-.7,(abs(fract(x-.25)-.5)-.25)/w); // just use  (offseted) smooth squares\n    return c;\n // return Nyquist(w,c);    // version with high-freq filtering integrated\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y;            // normalized coordinates\n    float a = atan(U.y,U.x), l = length(U); // polar coordinates\n \n    float v = 20.*a/6.28 + 10./l +iTime, // + sin(10.*l), // some fancy field\n          w = grad(v);                      // pixel width. \n    v = U.y > 0.\n            // top: spiral displayed with ramps, using fract\n            ? U.x < 0. ? fract( v ) : aafract( v )\n            // bottom: spiral displayed with bars, using step(fract)\n            : U.x < 0. ? step(.5,fract(v)) : aastep(v);\n\n    // version with Nyquist not already integrated in aafract/aastep:\n    // ( just to demo Nyquist also applied to aliased fract case. ) \n    if (iMouse.z<=0.) v = Nyquist(w,v);\n    \n    O = vec4( pow(v, 1./2.2) ); // final conversion to sRGB ( NB: sqrt(v) would be a good approx )\n    if ( abs(U.x) < 1./R.y ) O = vec4(1,0,0,0); // red separator\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "@BigWings: might be due to either high-frequencies  or not using the L2-alternative to fwidth (cf #def grad() here ) ",
        "date": "1560880165",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Xt2cW3",
        "hidden": 0
      },
      {
        "text": "Nice one",
        "date": "1560874850",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4ljcW3",
        "hidden": 0
      },
      {
        "text": "On the other one I could still see some aliasing at certain angles. This one is better!",
        "date": "1560872777",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "Xl2yW3",
        "hidden": 0
      },
      {
        "text": "Wow! Excellent!",
        "date": "1560863564",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "llScDc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "3tfGWl",
      "date": "1558064322",
      "viewed": 3567,
      "name": "Pikachu Thunderbolt",
      "username": "nyri0",
      "description": "Pikachu's attack \"thunderbolt\"",
      "likes": 22,
      "published": 3,
      "flags": 0,
      "tags": [
        "procedural",
        "2d"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define V 3\n\nconst float PI = 3.14159265;\n\n// Adds pikachu to the image\nvec3 addPikachu(vec2 uv, vec3 bg) {\n    float screenRatio = iResolution.x / iResolution.y;\n    const vec2 picDim = vec2(128.0, 120.0);\n    const float bTop = 0.5;\n    float bLeft = 0.55 - 0.5 * bTop * picDim.x / (picDim.y * screenRatio);\n    float bRight = 0.55 + 0.5 * bTop * picDim.x / (picDim.y * screenRatio);\n    if(uv.x < bLeft || uv.x > bRight || uv.y > bTop)\n        return bg;\n\n    int idx_x = int(picDim.x * (uv.x - bLeft) / (bRight - bLeft));\n    int idx_y = int(picDim.y * (bTop - uv.y) / bTop);\n\n    return pikachuText(idx_x, idx_y, bg);\n}\n\n// Finds a vector normal to the given vector\nvec2 vnorm(in vec2 v) {\n    return vec2(v.y, -v.x);\n}\n\n// Moves the points according to time and the id of the line\nvec2 getOffset(vec2 pos, vec2 posParent, vec2 offsetParent, int i) {\n    float rMag = i < 5 ? 0.1 : 0.04;\n    float lMag = i < 5 ? 0.04 : 0.01;\n    float period = 0.25 + 0.05 * mod(float(i), 3.0);\n    float tShift = iTime - 1.3 * float(i);\n    vec2 rOffset = rMag * 0.666 * floor(1.5*cos(7.0*float(i) + tShift / period)\n                                        * vnorm(pos - posParent - offsetParent));\n    vec2 lOffset = lMag * 0.666 * floor(1.5*cos(11.0*float(i) + tShift / period)\n                                        * (pos - posParent - offsetParent));\n    return offsetParent + rOffset + lOffset;\n}\n\n// Returns the lines that make the lightning\nconst int nbVertices = 25;\nconst int nbLines = nbVertices - 1;\nvec4[nbLines] getLines() {\n    const vec2[nbVertices] vertices = vec2[nbVertices] (\n        vec2(0.5, 0.1), vec2(0.2, 0.3), vec2(0.32, 0.5),\n        vec2(0.51, 0.55), vec2(0.75, 0.51), vec2(0.8, 0.2),\n        vec2(-0.05, 0.15), vec2(-0.15, 0.35), vec2(0.1, 0.6),\n        vec2(0.25, 0.7), vec2(-0.1, 0.5), vec2(-0.1, 0.8),\n        vec2(0.17, 1.1), vec2(0.3, 1.1), vec2(0.45, 0.69),\n        vec2(0.59, 0.83), vec2(0.48, 1.15), vec2(0.8, 1.15),\n        vec2(0.79, 0.79), vec2(0.94, 1.2), vec2(1.03, 1.07),\n        vec2(1.1, 0.63), vec2(0.93, 0.31), vec2(1.15, 0.1),\n        vec2(1.1, 0.28)\n    );\n    const ivec2[nbLines] lines = ivec2[nbLines] (\n        ivec2(0, 1), ivec2(0, 2), ivec2(0, 3), ivec2(0, 4),\n        ivec2(0, 5), ivec2(1, 6), ivec2(1, 7), ivec2(2, 8),\n        ivec2(2, 9), ivec2(8, 10), ivec2(8, 11), ivec2(9, 12),\n        ivec2(9, 13), ivec2(3, 14), ivec2(3, 15), ivec2(14, 16),\n        ivec2(15, 17), ivec2(4, 18), ivec2(18, 19), ivec2(18, 20),\n        ivec2(4, 21), ivec2(5, 22), ivec2(5, 23), ivec2(22, 24)\n    );\n    vec2[nbVertices] offsets;\n    offsets[0] = vec2(0.0, 0.0);\n    for(int i = 0; i < nbLines; i++) {\n        offsets[lines[i].y] = getOffset(vertices[lines[i].y],\n                                        vertices[lines[i].x],\n                                        offsets[lines[i].x], i);\n    }\n    vec4[nbLines] verticeLines;\n    for(int i = 0; i < nbLines; i++) {\n        verticeLines[i] = vec4(vertices[lines[i].x] + offsets[lines[i].x],\n                               vertices[lines[i].y] + offsets[lines[i].y]);\n    }\n    return verticeLines;\n}\n\n// Returns the lines that make Pikachu\nconst int nbPkVertices = 5;\nconst int nbPkLines = 5;\nvec4[nbPkLines] getPkLines() {\n    const vec2[nbPkVertices] vertices = vec2[nbPkVertices] (\n        vec2(0.43, 0.08), vec2(0.48, 0.3), vec2(0.54, 0.29),\n        vec2(0.59, 0.18), vec2(0.59, 0.07)\n    );\n    const ivec2[nbPkLines] lines = ivec2[nbPkLines] (\n        ivec2(0, 1), ivec2(1, 2), ivec2(2, 3), ivec2(3, 4), ivec2(4, 0)\n    );\n    vec4[nbPkLines] verticeLines;\n    for(int i = 0; i < nbPkLines; i++) {\n        verticeLines[i] = vec4(vertices[lines[i].x], vertices[lines[i].y]);\n    }\n    return verticeLines;\n}\n\n// From https://www.shadertoy.com/view/4sc3z2\n// and https://www.shadertoy.com/view/XsX3zB\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat simplexNoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\n// Creates the background texture\nvec3 backgroundDefault(vec2 uv) {\n    return vec3(0.05, 0.4, 0.2) + vec3(0.0, -0.05, 0.1)*simplexNoise(vec3(4.0*uv, 1.0));\n}\n\nfloat dot2(in vec2 v)\n{\n    return dot(v, v);\n}\n\n// Distance between p and the line from a to b\nfloat lineDist( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 adjRatio = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 pp = vec2((p.x - 0.5) / (1.0 + 0.3 * p.y) + 0.5, p.y);\n    vec2 pa = (pp-a)*adjRatio, ba = (b-a)*adjRatio;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    float sdist = dot2(pa-ba*h);\n    return sdist;\n}\n\n// Break the line according to the value of i\n// and return the minimum distance between p and\n// one of the sub-lines between a and b\nfloat lineMultiDist(in vec2 p, in vec2 a, in vec2 b, in int i)\n{\n    float offset1 = 0.4 + 0.05 * cos(5.0 * iTime + float(i+3));\n    float offset2 = 0.7 + 0.05 * cos(5.0 * iTime + float(i+5));\n    float shift1 = 0.02 + 0.04 * cos(5.0 * iTime + float(i));\n    float shift2 = -0.02 + 0.04 * sin(5.0 * iTime + float(i));\n    vec2[4] points = vec2[4] (\n        a,\n        mix(a, b, offset1) + shift1 * vnorm(b - a),\n        mix(a, b, offset2) + shift2 * vnorm(b - a),\n        b\n    );\n    float dm = 10.0;\n    for(int i = 0; i < 3; i++) {\n        dm = min(dm, lineDist(p, points[i], points[i+1]));\n    }\n    return dm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float noiseMicro = simplexNoise(vec3(20.0*uv, floor(iTime * 10.)));\n    float noiseMacro = simplexNoise(vec3(5.0*uv, iTime));\n    vec2 uv_o = uv + 0.007 * vec2(noiseMicro, noiseMicro) + 0.02 * vec2(noiseMacro, noiseMacro);\n\n    // Background color\n    vec3 col = backgroundDefault(uv);\n    \n    // Pikachu contour\n    vec4[nbPkLines] pkLines = getPkLines();\n    float di = 10.0;\n    for(int i = 0; i < nbPkLines; i++) {\n        di = min(di, lineDist(uv, pkLines[i].xy, pkLines[i].zw));\n    }\n    di /= (1.0 + 0.2 * cos(2.0*iTime) + 0.05 * cos(15.0*iTime));\n    float ampl = 1.0 / (1.0 + 3.0 * length(uv - vec2(0.5, 0.1)));\n    col = mix(col, vec3(1.0, 0.9, 0.5),0.8*(1.0-smoothstep(0.0,0.12,sqrt(di)*ampl)));\n    ampl = 1.0 / (1.0 + 3.0 * length(uv - vec2(0.5, 0.1)));\n    col = mix(col, vec3(1.0, 0.95, 0.4),0.8*(1.0-smoothstep(0.0,0.05,sqrt(di)*ampl)));\n     \n\n    // Thunderbolts\n    vec4[nbLines] lines = getLines();\n    const int[nbLines] groups = int[nbLines] (\n        0,1,2,3,4,0,0,1,1,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4\n    );\n    float[5] showgroup = float[5] (1.3*iTime, 1.1*iTime+0.5, 1.0*iTime+0.7, 1.4*iTime+0.3, 1.2*iTime+0.1);\n    di = 10.0;\n    int lum = 0;\n    for(int i = 0; i < nbLines; i++) {\n        if(fract(showgroup[groups[i]]) > 0.5) {\n        \tdi = min(di, lineMultiDist(uv_o, lines[i].xy, lines[i].zw, i));\n            lum++;\n        }\n    }\n  \n    if(fract(iTime * 7.) > 0.2)\n    {\n    col = mix(col, vec3(0.9, 0.9, 0.7), 0.7 * float(lum) / float(nbLines));\n\n    ampl = 1.0 / (1.0 + 3.0 * length(uv - vec2(0.5, 0.1)));\n    col = mix(col, vec3(1.0, 0.9, 0.4), 1.0-smoothstep(0.000002,0.00008,di*ampl));\n    col = mix(col, vec3(1.0, 1.0, 0.7), 1.0-smoothstep(0.000002,0.00001,di*ampl));\n    }\n\n    // Adding pikachu\n    col = addPikachu(uv, col);\n      \n    // Vignetting\n    col *= pow( 20.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.07 );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "vec3 pikachuText(int idx_x, int idx_y, vec3 col) {\nconst vec3[7] colors = vec3[7](vec3(1.000,0.847,0.145),vec3(0.165,0.165,0.149),vec3(0.917,0.314,0.145),vec3(0.980,0.980,0.980),vec3(0.753,0.435,0.157),vec3(0.902,0.666,0.180),vec3(0.764,0.259,0.090));\nint idx = idx_y * 128 + idx_x;\nuint off = uint(idx % 10);\nuint pos = uint(idx / 10);\nint index;\nif(pos >= 0u && pos < 128u) {\n  const int[128] indexv = int[128] (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,524288,0,0,0,0,0,0,0,0,0,0,0,0,74752,0,0,0,0,0,0,0,0,0,0,0,0,1170,0,0,0,0,0,0,0,0,0,0,0,306184192,18,0,0,0,0,0,0,0,0,0,0,0,306782208,0,0,0,0,0,0,0,0,0,0,0,0,4793488,0,0,0,0,0,0,0,0,0,0,0,301989888,74898,0,0,0,0,0,0,0,0,0,0,0,306774016,1170,0,0,0,0,0,0,0,0,0,0,0,306783360,18,0,0,0,0,0,0,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 128u && pos < 256u) {\n  const int[128] indexv = int[128] (0,0,268435456,306783378,0,0,0,0,0,0,0,0,0,0,0,306708480,4793490,0,0,0,0,0,0,0,0,0,0,0,306782208,74898,0,0,0,0,0,0,134217728,153391689,0,0,0,306783376,1170,0,0,0,0,0,0,153391680,153391689,0,0,268435456,306783378,18,0,0,0,0,0,153391680,153391689,19173961,0,0,306708480,287610002,0,0,0,0,0,153391104,153391689,153391689,299593,0,0,306782208,2396745,0,0,0,0,150994944,153391689,153391689,153391689,4681,0,0,153429136,37449,0,0,0,0,153391688,153391689,153391689,153391689,9,0,268435456,153391698,585,0,0,0,153387008,153391689,153391689,153391689,153391689,0,0,172490752,153391689,9,0,0,0,153391689,153391689,153391689,153391689,299593);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 256u && pos < 384u) {\n  const int[128] indexv = int[128] (0,0,153427968,153391689,0,0,0,153387008,153391689,153391689,153391689,153391689,4681,0,0,153391760,299593,0,0,0,153391689,153391689,153391689,153391689,153391689,9,0,268435456,153391689,4681,0,0,153387008,153391689,153391689,153391689,153391689,153391689,0,0,153092096,153391689,9,0,0,153391689,153391689,153391689,153391689,153391689,299593,0,0,153391104,153391689,0,0,153092096,153391689,153391689,153391689,153391689,153391689,4681,0,0,153391680,2396745,0,0,153387008,153391689,153391689,153391689,153391689,153391689,9,0,0,153391689,4681,0,0,153391616,153391689,153391689,153391689,153391689,153391689,0,0,153092096,153391689,73,0,0,165375360,153391689,153391689,153391689,153391689,299593,0,0,153387008,153391689,0,0,0,920350128,165375414,153391689,153391689,153391689,4681,0,0,153391616,2396745,0,0,0,920350134,920350134,153391734,153391689,153391689,9);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 384u && pos < 512u) {\n  const int[128] indexv = int[128] (0,0,153391688,4681,0,0,805306368,920350134,153415094,306782793,153391690,153391689,0,0,134217728,153391689,73,0,0,905969664,920350134,153391689,306783305,153391698,299593,0,0,153354240,824480329,6,0,0,918552576,153415094,153391689,306783377,153391698,4681,0,0,153391104,14193225,0,0,0,920125440,153391694,287609417,306783378,153391734,9,0,0,153391680,224329,0,0,0,153550848,153391689,306745929,910763154,153391734,0,0,0,153391689,153354673,153391689,0,0,153391680,153391689,306782793,920331410,299638,0,0,150994944,908366409,153391689,153391689,73,150994944,153391689,153391689,306783377,920350098,4726,0,0,153354240,154866249,153391689,153391689,585,153391104,153391689,287609417,910763154,920350134,118,0,0,153391104,153394249,153391689,153391689,37449,153391689,153391689,306745929,920347794,920350134,0,0,0,153391680,153391689,153391689,153391689,153391689,153391689,153391689,306783305,918577152,224694,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 512u && pos < 640u) {\n  const int[128] indexv = int[128] (0,0,153391689,153391689,153391689,153391689,153391689,153391689,153391689,74898,0,0,0,0,150994944,153391689,153391689,153391689,153391689,153391689,153391689,306483785,18,0,0,0,0,153354240,153391689,153391689,153391689,153391689,153391689,153391689,709435977,0,0,0,0,0,153391104,153391689,153391689,153391689,153391689,153391689,918852169,14328982,0,0,0,0,0,153391680,153391689,153391689,153391689,153391689,153391689,383479177,1797554,0,0,0,0,134217728,153391689,153391689,153391689,153391689,153391689,920326729,920350134,224694,0,0,0,0,153092096,153391689,153391689,153391689,153391689,920162889,115043766,920349696,28086,0,0,0,0,153387008,153391689,153391689,153391689,153391689,920162889,805306806,920350134,3510,0,0,0,0,153391680,153391689,153391689,153391689,153391689,920326729,920350134,920350134,54,0,0,0,0,153391689,153391689,153391689,153391689,153391689,920347209,920350134,920350134,6,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 640u && pos < 768u) {\n  const int[128] indexv = int[128] (0,150994944,153391689,153391689,153391689,153391689,153391689,920350089,920350134,115043766,0,0,0,0,153354240,153391689,153391689,153391689,153391689,153391689,920350129,920350134,1797558,0,0,0,0,153391616,153391689,153391689,153391689,153391689,824480329,920350134,920350134,3510,0,0,0,0,153391688,153391689,153391689,153391689,153391689,918852169,920350134,14380470,0,0,0,0,134217728,153391689,153391689,153391689,153391689,153391689,918229577,1797558,0,0,0,0,0,153092096,153391689,153391689,153391689,153391689,153391689,920052297,28086,0,0,0,0,0,153387008,153391689,153391689,153391689,153391689,153391689,920313225,3510,0,0,0,0,0,153391616,153391689,153391689,153391689,153391689,153391689,920345462,438,0,0,0,0,0,153391689,153391689,153391689,153391689,153391689,908366409,920349550,46,0,0,0,0,150994944,153391689,153391689,153391689,153391689,153391689,784634441,903535981,5,0,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 768u && pos < 896u) {\n  const int[128] indexv = int[128] (0,153354240,153391689,153391689,153391689,153391689,153391689,758846025,766991221,0,0,0,0,0,153391104,153391689,153391689,153391689,153391689,153391689,901049417,95869806,0,0,0,0,0,153391680,153391689,153391689,153391689,153391689,153391689,699847601,11983725,0,0,0,0,0,304386633,153391716,153391689,153391689,153396401,824480329,768006734,187245,0,0,0,0,150994944,612962889,153391692,153391689,606376521,153396372,247763529,766810985,2925,0,0,0,0,153354240,613557385,153391689,153391689,613552713,153391762,691737161,95867757,0,0,0,0,0,153391616,160580754,153391689,153391689,311576713,153391698,765783113,2893,0,0,0,0,0,304386632,153503890,153391689,153391689,306858274,153391689,229938097,365,0,0,0,0,134217728,306745929,153392274,153391689,304386633,155788580,824480329,758567502,5,0,0,0,0,153354240,306782793,153391698,153391689,307794505,153429138,247763529,765778761,0,0,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 896u && pos < 1024u) {\n  const int[128] indexv = int[128] (0,153464832,172565577,153391689,153391689,306778697,153392274,154866249,11965289,0,0,0,0,0,153466560,153429129,153391689,153391689,306782793,153391690,690285961,1497673,0,0,0,0,402653184,153401051,153391689,153396297,153391689,155788361,191730249,153392054,27465,0,0,0,0,459276288,153392859,153391689,153392265,153391689,153391689,917354201,153391694,109,0,0,0,0,460161024,153391707,153391689,153391689,153391689,455381577,165131995,757371465,9,0,0,0,0,460174848,153391691,153391689,153391689,153391689,460165705,153583323,162828873,0,0,0,0,0,191739608,153391689,153391689,153391689,153391689,460175049,153394683,2413129,0,0,0,0,402653184,158185179,153391689,153391689,153391689,153391689,997045979,153391735,299849,0,0,0,0,452984832,153466587,153391689,153391689,153391689,459575881,268285659,153391689,4681,0,0,0,0,460062720,153392859,287609417,153391698,153391689,460165705,154662619,153391689,73,0,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 1024u && pos < 1152u) {\n  const int[128] indexv = int[128] (0,460173312,153391707,766022217,153391698,153391689,460174921,153415675,153391689,1,0,0,0,0,460174912,153391689,690410569,153391698,153391689,997045977,153391743,19173961,0,0,0,0,0,158185177,153391689,690262634,153391698,421827145,939374299,153391689,2396745,0,0,0,0,153092096,153466587,153391689,153391689,153391690,459575881,154662619,153391689,37449,0,0,0,0,421826560,153391835,153391689,153391689,153391689,460100169,153415675,153391689,585,0,0,0,0,455381568,153391689,153391689,153391689,153391689,1064153673,153391727,153391689,9,0,0,0,134217728,153391689,153391689,153391689,153391689,153391689,234862153,153391689,824480329,0,0,0,0,153092096,153391689,153391689,153391689,153391689,153391689,154852233,153391689,12882505,0,0,0,0,153391104,153391689,153391689,153391689,153391689,153391689,153392054,824480329,221769,0,0,0,0,153391680,153391689,153391689,153391689,153391689,918852169,153391694,247763529,3465,0,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 1152u && pos < 1280u) {\n  const int[128] indexv = int[128] (134217728,153391689,153391689,153391689,153391689,153391689,165372489,153391689,825791049,54,0,0,0,153092096,153391689,153391734,153391689,153391689,153391689,153415089,153391689,920347209,0,0,0,0,153391104,824480329,153391694,153391689,153391689,908366409,153392054,153391689,14380105,0,0,0,0,153391680,908366409,153391694,153391689,153391689,920326729,153391689,153391689,224689,0,0,0,134217728,153391689,918852169,153391694,153391689,153391689,154889649,153391689,824480329,438,0,0,0,153092096,153391689,920162889,153391694,153391689,918852169,153394614,153391689,918852169,6,0,0,0,153391104,153391689,920347209,153391734,153391689,920350089,153391694,153391689,114856521,0,0,0,0,153391680,153391689,920349769,153392054,918852169,165375414,153391689,153391689,1794633,0,0,0,134217728,153391689,153391689,920350089,920350134,920350134,153415094,153391689,153391689,3465,0,0,0,153092096,153391689,153391689,920350134,920350134,920350134,153391734,153391689,153391689,54,0,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 1280u && pos < 1408u) {\n  const int[128] indexv = int[128] (153391104,153391689,824480329,920350134,920350134,920350134,153391689,153391689,908366409,0,0,0,0,153391680,153391689,918852169,920350134,920350134,249261494,153391689,153391689,14193225,0,0,0,0,153391689,153391689,920326729,920350134,920350134,154889654,153391689,153391689,1794633,0,0,0,153092096,153391689,153391689,920350089,920350134,920350134,153578934,153391689,153391689,28041,0,0,0,153387008,153391689,153391689,920350134,920350134,920350134,153415094,153391689,153391689,438,0,0,0,153391616,153391689,918852169,920350134,920350134,920350134,153392054,153391689,908366409,1,0,0,0,153391689,153391689,918553161,920350134,920350134,920350134,153391734,153391689,154702409,0,0,0,150994944,153391689,153391689,920125441,920350134,438,0,153391688,153391689,2417225,0,0,0,153354240,153391689,2396745,920326656,920350134,0,0,153391689,153391689,37769,0,0,0,153391104,153391689,4681,920326729,1797558,0,150994944,153391689,153391689,585,0,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(pos >= 1408u && pos < 1536u) {\n  const int[128] indexv = int[128] (153391688,153391689,153092105,920162889,3510,0,153092096,153391689,153391689,9,0,0,134217728,153391689,19173961,153391104,920162889,6,0,153354240,153391689,153391689,0,0,0,153092096,153391689,37449,153391680,1774153,0,0,153387008,153391689,2396745,0,0,0,153387008,153391689,73,153391689,585,0,0,153391104,153391689,37449,0,0,0,153391104,153391689,150994944,153391689,0,0,0,153391616,153391689,585,0,0,0,153391616,37449,153092096,37449,0,0,0,153391680,153391689,1,0,0,0,153391616,9,153354240,9,0,0,0,153391688,19173961,0,0,0,0,0,0,0,0,0,0,0,153391689,37449,0,0,0,0,0,0,0,0,0,0,134217728,153391689,73,0,0,0,0,0,0,0,0,0,0,134217728,153391689,0,0,0,0);\n  index = (indexv[pos % 128u] >> (3u * off)) & 7; }\nif(index == 0) return col;\nelse return colors[index-1];\n}\n",
        "name": "Common",
        "description": "",
        "type": "common"
      }
    ],
    "comments": [
      {
        "text": "Not running andriod webgl 100 LG k30 but some other shades run slowly",
        "date": "1560635042",
        "username": "gchipunov",
        "userpicture": "/img/profile.jpg",
        "id": "XlBcW3",
        "hidden": 0
      },
      {
        "text": "Very cool! Great job!",
        "date": "1559935756",
        "username": "flerovium",
        "userpicture": "/img/profile.jpg",
        "id": "4l2yDG",
        "hidden": 0
      },
      {
        "text": "thats so cool",
        "date": "1559398488",
        "username": "Arrangemonk",
        "userpicture": "/img/profile.jpg",
        "id": "4ljcRt",
        "hidden": 0
      },
      {
        "text": "Thanks 834144373 :)\n\nI've made a change to make the lightnings independent from each other, do you folks like it? And the luminosity varies in function of the number of lightnings on screen",
        "date": "1559397300",
        "username": "nyri0",
        "userpicture": "/media/users/nyri0/profile.png",
        "id": "4tjcRt",
        "hidden": 0
      },
      {
        "text": "haha,welcome to texture compression gang ;-)",
        "date": "1559380884",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "Xl2yRt",
        "hidden": 0
      },
      {
        "text": "This is a masterpiece!",
        "date": "1559333354",
        "username": "starea",
        "userpicture": "/media/users/starea/profile.jpeg",
        "id": "MtScRd",
        "hidden": 0
      },
      {
        "text": "I've added a v3 but not exactly the one from Arrangemonk. I found it a bit weird that it was darker when the lightning was shown. But thanks for the edits Arrangemonk! Btw a hastebin or pastebin is more suited than a Google Docs to share code.",
        "date": "1559078471",
        "username": "nyri0",
        "userpicture": "/media/users/nyri0/profile.png",
        "id": "Mt2czc",
        "hidden": 0
      },
      {
        "text": "https://docs.google.com/document/d/12OhfdGx76u7d2nbWPDJIf4y1UwR3AwaqgdlvFZZKoRw/edit?usp=sharing",
        "date": "1559072774",
        "username": "Arrangemonk",
        "userpicture": "/img/profile.jpg",
        "id": "Mljczc",
        "hidden": 0
      },
      {
        "text": "sorry to hijack again, but what do you think about\nadding if((int(iTime * 12226.))%41  > 13){} around the big pikachu contour and the thunderbolts,\nso its also flickering",
        "date": "1559051083",
        "username": "Arrangemonk",
        "userpicture": "/img/profile.jpg",
        "id": "Ml2yRc",
        "hidden": 0
      },
      {
        "text": "Ok, I switched the default to v2 then.\nI know it still doesn't look like real lightning but I want this kind of cartoony look.",
        "date": "1559006165",
        "username": "nyri0",
        "userpicture": "/media/users/nyri0/profile.png",
        "id": "lljcR3",
        "hidden": 0
      },
      {
        "text": "I like mode 2. It makes the bolts less smooth-moving and look more quick..\nI have never seen a lightning bolt that sways ok just saying :) ",
        "date": "1558706412",
        "username": "Imsure1200q_1UWE130",
        "userpicture": "/media/users/Imsure1200q_1UWE130/profile.jpeg",
        "id": "MlSyR3",
        "hidden": 0
      },
      {
        "text": "I've added a parameter V, set it to 2 to see the new version. If you folks like this one better I can set 2 as the default version, so tell me your opinion (or how you'd improve this animation).",
        "date": "1558648617",
        "username": "nyri0",
        "userpicture": "/media/users/nyri0/profile.png",
        "id": "4tScRc",
        "hidden": 0
      },
      {
        "text": "how about \n    vec2 rOffset = rMag * 0.6666 * floor(1.5 * cos(7.0*float(i) + tShift / period) * vnorm(pos - posParent - offsetParent));\n    vec2 lOffset = lMag * 0.6666  * floor(1.5 * cos(11.0*float(i) + tShift / period) * (pos - posParent - offsetParent));\nat line 30 \nand \n    float noiseMicro = simplexNoise(vec3(20.0*uv, floor(iTime * 10.)));\nat line 169",
        "date": "1558563873",
        "username": "Arrangemonk",
        "userpicture": "/img/profile.jpg",
        "id": "Ml2yzV",
        "hidden": 0
      },
      {
        "text": "Hey EvilRyu I'm sorry, if you have more info about the crash I could try to fix it, though it's likely a memory issue. WebGL support is quite bad on Mac. Also maybe try with Firefox",
        "date": "1558346868",
        "username": "nyri0",
        "userpicture": "/media/users/nyri0/profile.png",
        "id": "4lSczV",
        "hidden": 0
      },
      {
        "text": "Crashes on my mac, chrome",
        "date": "1558345238",
        "username": "EvilRyu",
        "userpicture": "/media/users/EvilRyu/profile.jpeg",
        "id": "XtSczV",
        "hidden": 0
      },
      {
        "text": "I added some simplex noise to improve the lightning :)",
        "date": "1558196055",
        "username": "nyri0",
        "userpicture": "/media/users/nyri0/profile.png",
        "id": "4lSyRK",
        "hidden": 0
      },
      {
        "text": "whwoa, it's adorable! more pixelcrunchy thunderbolt pls <3",
        "date": "1558166558",
        "username": "FMS_Cat",
        "userpicture": "/media/users/FMS_Cat/profile.png",
        "id": "Ml2cRy",
        "hidden": 0
      },
      {
        "text": ":)",
        "date": "1558161571",
        "username": "Imsure1200q_1UWE130",
        "userpicture": "/media/users/Imsure1200q_1UWE130/profile.jpeg",
        "id": "lt2cRy",
        "hidden": 0
      },
      {
        "text": "It does work now, yes! (160 fps) Thanks for the fix!",
        "date": "1558137111",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MljyRy",
        "hidden": 0
      },
      {
        "text": "I made a fix with indexed colors, the size of the texture should be divided by 10 approximately. It runs fine on my Linux laptop with Firefox, at 30-45 fps. Does it still crash your browser @iq ?",
        "date": "1558134917",
        "username": "nyri0",
        "userpicture": "/media/users/nyri0/profile.png",
        "id": "MtjyRy",
        "hidden": 0
      },
      {
        "text": "It crashes all my browsers, there's too much data. Instead of encoding ray color values it'd be better to encode color indices, and keep a global palette. There are a few examples in shadertoy on encoding images.\n\nFor now I'll put the shader in private mode to prevent other users from crashing while browsing. If you manage to change the encoding algorithm, feel free to re-publish!",
        "date": "1558069678",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4l2yzy",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4dKfDd",
      "date": "1559925657",
      "viewed": 579,
      "name": "Morning Dew",
      "username": "BigWIngs",
      "description": "See comments",
      "likes": 20,
      "published": 1,
      "flags": 64,
      "tags": [
        "drops"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "ldSXzt",
            "filepath": "https://soundcloud.com/pauldavids/looping-1",
            "previewfilepath": "https://soundcloud.com/pauldavids/looping-1",
            "type": "musicstream",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 0
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Morning Dew by Martijn Steinrucken aka BigWings - 2019\n// Twitter: @The_ArtOfCode\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Music - Paul Davids - Live Looping 1\n// https://soundcloud.com/pauldavids/looping-1\n\n#define MAX_STEPS 200\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 50.\n#define RAY_PRECISION 0.03\n\n#define REFLECTIONS\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec2 m; // mouse\n\nfloat X2(float x) {return x*x;}\n\nfloat N31(vec3 t) {return fract(sin((t.x+t.y*10.+ t.z*100.)*9e2));}\nvec4 N14(float t) {return fract(sin(vec4(1., 3., 5., 7.)*9e2));}\n\nfloat LN(float x) {return mix(N(floor(x)), N(floor(x+1.)), fract(x));}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\n\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n    float d;\t// distance to the object\n    float md;\t// closest distance\n    float m; \t// material\n    vec3 p;\t\t// world space position\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n\n\nray GetRay(vec2 uv, vec3 p, vec3 lookAt, float zoom, vec3 up) {\n\t\n    vec3 f = normalize(lookAt-p),\n    \t r = normalize(cross(up, f)),\n    \t u = cross(f, r),\n    \t c = p+f*zoom,\n         i = c+r*uv.x+u*uv.y;\t// point in 3d space where cam ray intersects screen\n    \n    ray cr;\n    \n    cr.o = p;\t\t\t\t\t\t\n    cr.d = normalize(i-p);\t\t// ray dir is vector from cam pos to screen intersect \n\treturn cr;\n}\n\nfloat remap01(float a, float b, float t) { return (t-a)/(b-a); }\nfloat remap(float a, float b, float c, float d, float t) { return sat((b-a)/(t-a)) * (d-c) +c; }\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/rect.zw;\n}\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\n\n\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec3 c ) {\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nmat2 Rot(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\treturn mat2(c, -s, s, c);\n}\n\n\n\n\nfloat Bounce2(float t) {\n    \n    t *= 2.75+.3;\n    t-=1.+.3;\n    \n\tfloat a = 0.;\n    float b = 1.-t*t;\n    float c = -4.*(t-1.)*(t-1.5);\n    float d = -4.*(t-1.5)*(t-1.75);\n    \n    float ab = smin(a, b, -.1);\n    float cd = smin(c, d, -.1);\n    \n    float y = smin(ab, cd, -.1);\n    \n    return y;\n}\n\nfloat Wave(float d, float t) {\n\tfloat x = d-t*10.;\n    \n    float wave = sin(x)/(1.+x*x);\n    float s = S(14., 0., d);\n    return wave*s*s*1.5;\n}\n\nfloat V2(vec3 p, float t) {\n\t\n   \n    \n   // p *= mix(1., .5, S(.8, .99, t));\n    //p *= 1.-.5*t;\n    \n    float dc = length(p.xz);\n    \n    float m = iMouse.x/iResolution.x;\n   //t = m;\n    t *= 2.;\n    \n    float eject = S(0., .1, t);\n    float eject2 = eject*S(.3, .1, t);\n    float dropSize = mix(1., .5, eject);\n    \n    float t1 = t;\n    float t2 = t-.75;\n    float t3 = t-.875;\n    \n    float t4 = t-.4;\n    \n    float w1 = Wave(dc, t1)* S(0., .05, t1);\n    float w2 = Wave(dc, t2)* S(0., .05, t2);\n    float w3 = Wave(dc, t3)* S(0., .05, t3);\n    \n    float w4 = Wave(dc, t4)* S(0., .05, t4);\n    \n    float wave = w1 + .5*w2 + .25*w3 + .25*w4;\n    \n    float cw = Wave(0., t1) + Wave(0., t2)*.5 + Wave(0., t3)*.4;\n    \n    float b = Bounce2(t*1.);\n    float y = b*6.+dropSize+cw-.1;\n    y -= .6*S(1., .85, t);\n    y += (1.-eject)*.5;\n    y -= eject2;\n    \n    \n    float x = sin(t*30.+p.z*9.)*.05*b;\n    float z = sin(t*33.+p.x*7.)*.05*b;\n    \n    float drop = length(p-vec3(x, y, z))-dropSize;\n    \n    float surf = abs(p.y);\n    \n    surf -= wave;\n    \n    surf *= .75;\n    float d = smin(surf, drop, eject2*2.);\n    \n    x = z = 0.;\n   // t = (t-1.);\n    \n    y = -(t-.2)*(t-.5)*100.-.5;\n    drop = length(p-vec3(x, y, z))-.5;\n    d = smin(d, drop, max(1.-y, .1));\n    \n    y = -(t-.15)*(t-.55)*100.-.5;\n    d = smin(d, length(p-vec3(x, y, z))-.25, .8);\n    \n    y = -(t-.13)*(t-.56)*100.-.25;\n    d = smin(d, length(p-vec3(x, y, z))-.15, .8);\n    \n    return d;\n}\n\nfloat V3(vec3 p, float t) {\n    vec2 size = vec2(25.);\n    vec2 id = floor(p.xz/size);\n    p.xz = mod(p.xz, vec2(size))-size*.5;\n    \n    float n = N21(id);\n    \n    t = fract(t*.2+n);\n    \n   return V2(p, t);\n}\n\nfloat map( vec3 p ) {\n    \n    float t = iTime;\n   // t += sin(t*.3);\n    //p.xz += t*2.;\n    \n    float d = V3(p, t);\n    \n    float s = sin(PI*.25);\n    float c = cos(PI*.25);\n    mat2 rot = mat2(c, -s, s, c);\n    \n   // p.xz *= 2.*rot;\n    p.xz += vec2(12.34, 34.45);\n    d = smin(d, V3(p, t), .1);\n    \n    return d;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(map( aopos )-hr)*sca;\n        sca *= .5;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\n\nde castRay( ray r, float precis ) {\n    \n    float t = iTime;\n    float dS;\n    \n    de o;\n    o.d = MIN_DISTANCE;\n    o.md = MAX_DISTANCE;\n    o.m = -1.0;\n    \n    float d;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        o.p =  r.o+r.d*o.d;\n \n        d = map(o.p);\n        \n        o.md = min(o.md, d);\n        if( d<precis || o.d>MAX_DISTANCE ) break;\n        \n        o.d += d;\n    }\n    \n    if(d<precis) o.m = 1.;\n    \n    return o;\n}\n\nvec3 calcNormal( de o )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.p+eps.xyy) - map(o.p-eps.xyy),\n\t    map(o.p+eps.yxy) - map(o.p-eps.yxy),\n\t    map(o.p+eps.yyx) - map(o.p-eps.yyx) );\n\treturn normalize(nor);\n}\n\nvec3 Bg(vec3 rd) {\n    float y = iMouse.y/iResolution.y;\n    y = sin(iTime*.1)*.15+.7;\n\treturn vec3(.5)*(rd.y+1.)*y;\n}\n\nvec3 render( vec2 uv, ray cam ) {\n    \n    float t = iChannelTime[0];\n    \n    vec3 col = vec3(0.);\n    de o = castRay(cam, RAY_PRECISION);\n    \n    vec3 n = calcNormal(o);\n    \n    float d = length(o.p-cam.o);\n    float fresnel = 1.-sat( dot(-cam.d, n) );\n    \n    if(o.m==1.) {\n    \tfloat ao = calcAO(o.p, n);\n        \n        float dif = .1+sat(dot(n, vec3(.577)));\n        dif = mix(ao, dif, .5);\n        \n        \n        col = vec3(dif);\n        \n        \n        #ifdef REFLECTIONS\n        ray r;\n        r.d = reflect(cam.d, n);\n        r.o = o.p+r.d*.1;\n        \n        de ro = castRay(r, .03);\n        float ref = 0.;\n        if(ro.m==1.) {\n        \tvec3 rn = calcNormal(ro);\n            \n            float rao = calcAO(ro.p, rn);\n        \n        \tfloat rdif = .1+sat(dot(rn, vec3(.577)));\n        \tref = mix(rao, rdif, .5)*.3;\n            \n        }\n        \n        col += ref*fresnel;\n        #endif\n    }\n    vec3 bg = Bg(cam.d);\n    col = mix(bg, col, (1.-fresnel)*S(50., 0., d));\n   // col = bg;\n    return col;\n}\n\nvec3 FlightPath(float t) {\n    //t *= .3;\n    float a = sin(t)*.5+.5;\n    float b = a*a;\n    float x = -sin(t*.25)*30.;\n    float y = sin(t*.225)+1.2 + sin(.2456*t)+1.5;\n   // y = mix(2., 12., b*b);\n\treturn vec3(x, y, t*10.);\n}\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n    float t = iTime;\n    \n    uv = (2.*uv - (o.xy=iResolution.xy) ) / o.y ;  \t// -1 <> 1\n   \tm = iMouse.xy/iResolution.xy;\t\t\t\t\t// 0 <> 1\n    \n    float turn =m.x*6.283;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    m.y -= .5;\n    s = sin(m.y*PI*.5);\n    c = cos(m.y);\n    vec3 pos = vec3(0., (1.-s)*6., -6.*c)*rotX;\n   \tvec3 lookAt = vec3(0., 1.5, 0.);\n    \n    float y = sin(t)*2.+1.;\n    pos = FlightPath(t);\n    lookAt = FlightPath(t+1.1)+vec3(0., -2.5, .1);\n    \n    float a = sin(t*.25)*.25;\n    vec3 up = vec3(sin(a), cos(a), 0.);\n    ray r = GetRay(uv, pos, lookAt, 1., up);\n\n    vec3 col = render(uv, r);\n    \n    \n    if(pos.y>0.)\n    col = 1.-col;\n    //col *= 1.5;\n    \n    col *= 1. - dot(uv, uv)*.125;\n    col *= 1.5;\n    \n    col *= col;\n    \n     col *= vec3(1., .9+sin(t*.36)*.1, .9+sin(t*.3)*.1);\n   \n    o = vec4(col, 1.);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n#define PI 3.14159265\n#define R3 1.732051\n\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11  is also first 32bits of M1*M1\n\n#define N21 N21dot\n\n// from James_Harnett - Simplest Fastest 2d Hash \n// https://www.shadertoy.com/view/MdcfDj\nfloat hash( uvec2 q ) {\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\n\n// Returns hexagonal coordinates. \n// XY = polar uv coords,  ZW = hex id \nvec4 HexCoordsPolar(vec2 uv) {\n    vec2 s = vec2(1, R3);\n    vec2 h = .5*s;\n\n    vec2 gv = s*uv;\n    \n    vec2 a = mod(gv, s)-h;\n    vec2 b = mod(gv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    vec2 st = vec2(atan(ab.x, ab.y), length(ab));\n    vec2 id = gv-ab;\n    \n    return vec4(st, id);\n}\n\n// Returns hexagonal coordinates. \n// XY = polar uv coords,  ZW = hex id \nvec4 HexCoords(vec2 uv) {\n    vec2 s = vec2(1, R3);\n    vec2 h = .5*s;\n\n    vec2 gv = s*uv;\n    \n    vec2 a = mod(gv, s)-h;\n    vec2 b = mod(gv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    vec2 st = ab;//vec2(atan(ab.x, ab.y), length(ab));\n    vec2 id = gv-ab;\n    \n    return vec4(st, id);\n}\n\n\n// returns the distance from a point to a rect (center-size)\nfloat DistRect(vec4 r, vec2 p) { \n\tvec2 d = max(abs(p - r.xy) - r.zw*.5, 0.);\n    return dot(d, d);\n}\n\nfloat GetT(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b-a;\n    vec2 pa = p-a;\n    \n    float t = dot(ba, pa)/dot(ba, ba);\n    \n    return t;\n}\n\nvec2 ClosestPointSeg2D(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b-a;\n    vec2 pa = p-a;\n    \n    float t = dot(ba, pa)/dot(ba, ba);\n    t = sat(t);\n    \n    return a + ba*t;\n}\n\nfloat DistSeg2d(vec2 uv, vec2 a, vec2 b) {\n\treturn length(uv-ClosestPointSeg2D(uv, a, b));\n}\n\nfloat N(float p) {\n\treturn fract(sin(p*6453.2)*3425.2);\n}\n\n\n\nvec3 N23(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 N23(float x, float y) {return N23(vec2(x, y));}\n\nfloat N21sin(vec2 p) {\n    p = p*132.3+vec2(345.45,2345.3);\n\treturn fract(sin(p.x+p.y*1534.2)*7363.2);\n}\n\nfloat N21dot(vec2 p) {\n    p = fract(p*vec2(345.45,2345.3));\n    p += dot(p, p+123.345);\n\treturn fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 N12(float p) {\n    float x = N(p);\n\treturn vec2(x, N(p*100.*x));\n}\n\n\n\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nfloat SmoothNoise(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nfloat LayerNoise(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)*.5;\n    c += SmoothNoise(uv*16.)*.25;\n    c += SmoothNoise(uv*32.)*.125;\n    c += SmoothNoise(uv*65.)*.0625;\n    \n    return c / 2.;\n}\n\nvec3 SmoothNoise3(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    vec3 top = mix(N23(id.x, id.y), N23(id.x+1., id.y), m.x);\n    vec3 bot = mix(N23(id.x, id.y+1.), N23(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nvec3 LayerNoise3(vec2 uv) {\n    vec3 c = SmoothNoise3(uv*4.);\n    c += SmoothNoise3(uv*8.)*.5;\n    c += SmoothNoise3(uv*16.)*.25;\n    c += SmoothNoise3(uv*32.)*.125;\n    c += SmoothNoise3(uv*65.)*.0625;\n    \n    return c / 2.;\n}\n\n\nvec2 Rot2d(vec2 p, float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return vec2(p.x*s-p.y*c, p.x*c+p.y*s);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = sat( 0.5+0.5*(b-a)/k );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k ) {\n    float h = sat( 0.5+0.5*(b-a)/k );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}",
        "name": "Common",
        "description": "",
        "type": "common"
      }
    ],
    "comments": [
      {
        "text": "Goes GREAT with the music! Very nice.",
        "date": "1559931906",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "4t2yDG",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4dfGzs",
      "date": "1376478210",
      "viewed": 72906,
      "name": "Voxel Edges",
      "username": "iq",
      "description": "Correct edge detection for voxels. The marching function is fb39ca4's DDA, but using floating point operations instead of integers. The most interesting bits are probably the exact 3D intersector, the occlusion and the edge detection code.",
      "likes": 527,
      "published": 3,
      "flags": 1,
      "tags": [
        "procedural",
        "3d",
        "raymarching",
        "voxel",
        "occlusion",
        "dda"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4sfGRn",
            "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
            "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
            "type": "texture",
            "channel": 2,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdX3Rn",
            "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
            "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "Xsf3zn",
            "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\n// Shading technique explained here:\n//\n// http://www.iquilezles.org/www/articles/voxellines/voxellines.htm\n//\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = abs( n );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*m.x + y*m.y + z*m.z;\n}\n\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = 2.0*texture( iChannel1,0.01*pos.xz ).zyx; \n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 0.5 + 0.5*texcube( iChannel2, 0.5*pos, nor ).x;\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = calcOcc( uv, va, vb, vc, vd );\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        // blend to black & white\t\t\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*www*(0.9+0.1*vvv)*exp( -0.04*t );;\n        float mi = sin(-1.57+0.5*iTime);\n        mi = smoothstep( 0.70, 0.75, mi );\n        col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfloat time = 1.0*iTime;\n\n    float cr = 0.0;\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\n    \n    fragColor = vec4( col, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "muy buen trabajo!!!",
        "date": "1560905805",
        "username": "jorge2017a1",
        "userpicture": "/img/profile.jpg",
        "id": "XljcD3",
        "hidden": 0
      },
      {
        "text": "looks fantastic!",
        "date": "1560460084",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "Mt2yWK",
        "hidden": 0
      },
      {
        "text": "Im getting 404'd on fb39ca4",
        "date": "1555634891",
        "username": "khlorghaal",
        "userpicture": "/media/users/khlorghaal/profile.png",
        "id": "4tjyzW",
        "hidden": 0
      },
      {
        "text": "cool",
        "date": "1548751287",
        "username": "pilot",
        "userpicture": "/img/profile.jpg",
        "id": "Xlfczn",
        "hidden": 0
      },
      {
        "text": "cool ",
        "date": "1545120963",
        "username": "liuhongyi",
        "userpicture": "/img/profile.jpg",
        "id": "MdBfRG",
        "hidden": 0
      },
      {
        "text": "Love it",
        "date": "1538984521",
        "username": "yuletian",
        "userpicture": "/media/users/yuletian/profile.png",
        "id": "4sXBzl",
        "hidden": 0
      },
      {
        "text": "How difficult would it be to make voxels in shapes other than cubes? I was looking at 3D honeycomb shapes and thought it would be interesting to see a voxel engine that uses rhombic dodecahedra or octahedron/tetrahedron patterns",
        "date": "1505408727",
        "username": "dawsx",
        "userpicture": "/img/profile.jpg",
        "id": "4tKGz3",
        "hidden": 0
      },
      {
        "text": "just to shorten the code:\n[code]\nfloat lineglow = smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n[/code]",
        "date": "1496559862",
        "username": "Imsure1200q_1UWE130",
        "userpicture": "/media/users/Imsure1200q_1UWE130/profile.jpeg",
        "id": "4t3GRr",
        "hidden": 0
      },
      {
        "text": "cool shader! but why do the voxels move away from the camera :( jk.\nI like the orange black effect",
        "date": "1496559673",
        "username": "Imsure1200q_1UWE130",
        "userpicture": "/media/users/Imsure1200q_1UWE130/profile.jpeg",
        "id": "Xt3GRr",
        "hidden": 0
      },
      {
        "text": "fantastic!",
        "date": "1492984614",
        "username": "nolibab",
        "userpicture": "/media/users/nolibab/profile.png",
        "id": "MdVXDm",
        "hidden": 0
      },
      {
        "text": "Awesome shader!\n\nAny particular reason you are using `f = f*f*(3.0-2.0*f);` instead of `f=smoothstep(0.0, 1.0, f);` ??\n\nIs this a \"best practice\" that I should use whenever I don't need the \"clamp\" functionality of smoothstep, or are you just used to writing out the polynomial and prefer it for aesthetic/readability reasons?",
        "date": "1453335428",
        "username": "mds2",
        "userpicture": "/media/users/mds2/profile.png",
        "id": "4lS3zc",
        "hidden": 0
      },
      {
        "text": "I LOVE this shader! How can I port it to PyOpenGL?",
        "date": "1453150997",
        "username": "etale_cohomology",
        "userpicture": "/media/users/etale_cohomology/profile.png",
        "id": "4t23zK",
        "hidden": 0
      },
      {
        "text": "black screen here too unfortunately",
        "date": "1452802082",
        "username": "demofox",
        "userpicture": "/media/users/demofox/profile.jpeg",
        "id": "4l23RG",
        "hidden": 0
      },
      {
        "text": "I only see a black screen.",
        "date": "1442767464",
        "username": "anastadunbar",
        "userpicture": "/media/users/anastadunbar/profile.png",
        "id": "XlfGzM",
        "hidden": 0
      },
      {
        "text": "Even then there's the occasional mad flicker! :(",
        "date": "1405688083",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "ls2Gzt",
        "hidden": 0
      },
      {
        "text": "It's broken in Chrome 36. Replacing the two 'continues' with 'break' and  replacing the long 'if' statement in line 178 with: [code]\tif( t<0.0 )\n\t{\n\t\tgl_FragColor = vec4( 0.0 );\n\t\treturn;\n\t}[/code]\nSeems to get it working again! But it's only a quick guess.",
        "date": "1405687990",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Md2Gzt",
        "hidden": 0
      },
      {
        "text": "Really digging this shader! I've been working on a game and when I saw this something just click. That said, any chance of a port? Or at least a pointer to how one might go about porting to shader lab? (with permission and credits of course).\n",
        "date": "1381623951",
        "username": "bmackenzie",
        "userpicture": "/img/profile.jpg",
        "id": "4dfGW2",
        "hidden": 0
      },
      {
        "text": "Done!",
        "date": "1378774883",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ldlGRf",
        "hidden": 0
      },
      {
        "text": "I'll give it a try later this week, it shouldn't be too difficult :)",
        "date": "1376512293",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "lsX3Rj",
        "hidden": 0
      },
      {
        "text": "Awesome! I wish you solved those corners.",
        "date": "1376498130",
        "username": "mu6k",
        "userpicture": "/media/users/mu6k/profile.png",
        "id": "MdX3Rj",
        "hidden": 0
      },
      {
        "text": "I :love: the Tron vibe to it, iq! :)",
        "date": "1376490626",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "ldX3Rj",
        "hidden": 0
      },
      {
        "text": "Hey 'fb39ca4'. If I convert your code to use vec's intead of ivec3's there is no speed difference between this and your code (on my Mac anyway). I'm guessing it's the 'steps' and the twice as many multiplies iq uses in each ray move? Even though iq's inner loop looks much smaller.",
        "date": "1376490487",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MsfGRj",
        "hidden": 0
      },
      {
        "text": "It looks great! I'm honored that you decided to build on top of my work.\n",
        "date": "1376489545",
        "username": "fb39ca4",
        "userpicture": "/media/users/fb39ca4/profile.png",
        "id": "MdfGRj",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4lKSzh",
      "date": "1482862660",
      "viewed": 66814,
      "name": "Re Seascape by TDM",
      "username": "wizgrav",
      "description": "Audio reactive version of the fantastic sea shader by TDM https://www.shadertoy.com/view/Ms2SD1, rewired to work with clubber\n\nzorba omg https://goo.gl/pQunGq , https://goo.gl/7tDFmr",
      "likes": 3,
      "published": 3,
      "flags": 0,
      "tags": [
        "procedural",
        "sea",
        "reactive",
        "clubber"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R 0.0\n#define CLUBBER_G 0.0\n#define CLUBBER_B 0.0\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\nvec4 Clubber = vec4(0.);\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\nfloat EPSILON_NRM\t= 0.1 / iResolution.x;\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nfloat SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.2;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat SEA_TIME = 1.0 + iTime * SEA_SPEED;\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    float md = mix(0.86,1.0,Clubber.b);\n    e.y = max(e.y,0.0);\n    return vec3(pow(0.8+md/5.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4)*md;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        d = sea_octave((uv+SEA_TIME)*freq + 2. * Clubber.r,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq + 2. * Clubber.g,choppy);\n        h += d * amp;        \n    \tuv *= octave_m ; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \tuv += Clubber.rg * 0.1;\n    \td = sea_octave((uv+SEA_TIME)*freq+ 2. * Clubber.r,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq + 2. * Clubber.g,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0)*mix(0.33,1.0,Clubber.b));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    Clubber = vec4(CLUBBER_R,CLUBBER_G, CLUBBER_B, CLUBBER_A);\n    SEA_CHOPPY = mix(4.0,32.0, Clubber.a);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "this is not compiling!  ",
        "date": "1558748085",
        "username": "flexiverse",
        "userpicture": "/img/profile.jpg",
        "id": "ltSyz3",
        "hidden": 0
      },
      {
        "text": "no longer compiling in webGL2",
        "date": "1547914020",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ls2fDV",
        "hidden": 0
      },
      {
        "text": "(Ooops - I left the I in the values.)\nYup - I get the same error. You can see a static sea by using the following lines - though this one used to work for me! What's changed?\n\nfloat EPSILON_NRM\t= 0.1 / 400.0;\nfloat SEA_TIME = 1.0 + 1.0 * SEA_SPEED;",
        "date": "1545532040",
        "username": "SarahC",
        "userpicture": "/img/profile.jpg",
        "id": "XsBfRK",
        "hidden": 0
      },
      {
        "text": "Yup - I get the same error. You can see a static sea by using the following lines - though this one used to work for me! What's changed?\n\nfloat EPSILON_NRM\t= 0.1 / 400.0;\nfloat SEA_TIME = 1.0 + i1.0 * SEA_SPEED;",
        "date": "1545532010",
        "username": "SarahC",
        "userpicture": "/img/profile.jpg",
        "id": "4dBfRK",
        "hidden": 0
      },
      {
        "text": "Under Linux/Google Chrome/NVIDIA 415.25 I get an error, \"Shader Error\".\n\nLine 21 and 32:\n'=' : global variable initializers must be constant expressions",
        "date": "1545416017",
        "username": "birdie",
        "userpicture": "/media/users/birdie/profile.png",
        "id": "ld2fRy",
        "hidden": 0
      },
      {
        "text": "@gloinart sorry that would be audio reactive. Here's an example with the music from zorba https://goo.gl/pQunGq",
        "date": "1483492318",
        "username": "wizgrav",
        "userpicture": "/img/profile.jpg",
        "id": "MstSz4",
        "hidden": 0
      },
      {
        "text": "What do you mean by reactive?",
        "date": "1482934058",
        "username": "gloinart",
        "userpicture": "/media/users/gloinart/profile.jpeg",
        "id": "4dtXRH",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4s2SRt",
      "date": "1415961287",
      "viewed": 73253,
      "name": "Oblivion radar",
      "username": "ndel",
      "description": "A simple sci-fi radar.",
      "likes": 114,
      "published": 1,
      "flags": 0,
      "tags": [
        "2d",
        "radar"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n\t    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 2.5 )\n        return 1.0;\n    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )\n        return 1.0;\n    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )\n        return 0.5;\n    else\n\t    return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),3.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 8.0+mod(87.0*iTime, 80.0);\n    return (0.5-0.5*cos(30.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n\tvec2 uv = fragCoord.xy;\n    //center of the image\n    vec2 c = iResolution.xy/2.0;\n    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                  + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n    finalColor += movingLine(uv, c, 240.0) * blue3;\n    finalColor += circle(uv, c, 10.0, 1.0) * blue3;\n    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(iTime)) * blue3;\n    if( length(uv-c) < 240.0 )\n    {\n        //animate some bips with random movements\n    \tvec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*iTime);\n   \t\tfinalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*iTime)+0.15*iTime);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*iTime+7.0)+0.2*iTime);\n        finalColor += bip2(uv,c+p) * red;\n    }\n\n    fragColor = vec4( finalColor, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "This is very nice! May I use it as part of a VJ set?",
        "date": "1523297590",
        "username": "jpkelly",
        "userpicture": "/media/users/jpkelly/profile.png",
        "id": "Xdfczs",
        "hidden": 0
      },
      {
        "text": "Did I miss something, or is \"29 d = normalize(d);\" completely redundant?",
        "date": "1508870169",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "4lcSW4",
        "hidden": 0
      },
      {
        "text": "b*b=length(p)*length(p)=dot(p,p);\nb=length(p)=sqrt(dot(p,p))=pow(dot(p,p),.5) = euclidean (diagonal shortest) distance from vec2(0,0) to vec2(p.x,p.y)\n\na*a=dot(d,p) is a simple matrix projection\nthe youtube channel [ 3blue1brown ] explains the dot-product nicely, it is identical to a projection matrix, projecting one vector on another vector.\n\ndot(d,p)/dot(p,p) divides one SQUARED distance (vector length) by another SQUARED distance (vector length).\n a*a/b*b=dot(d,p)/dot(p,p); in the context of a and b being euclidean distances.\n\ndot(d,p)/dot(p,p) is a subroutine that is commonly used to get the distance to a line segment.\n\nsearch \"line segment\" on shadertoy to see it wrapped and used in simpler contexts.",
        "date": "1501446298",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4l33Wf",
        "hidden": 0
      },
      {
        "text": "Hey ndel great shader! I'm studying it at the moment, but I'm a real beginner. I got everything in the movingLine function except the l at line 28. Why do you do the dot product of d and p? Thank you for any answer! ",
        "date": "1450284669",
        "username": "FedFod",
        "userpicture": "/media/users/FedFod/profile.jpeg",
        "id": "ltSGzW",
        "hidden": 0
      },
      {
        "text": "Red... thingy... moving... toward... the... green... thingy.  I think... I think we're the green thingy.",
        "date": "1420233773",
        "username": "jameswilddev",
        "userpicture": "/media/users/jameswilddev/profile.png",
        "id": "ldlXD8",
        "hidden": 0
      },
      {
        "text": "Very nice looking",
        "date": "1416365910",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4dfSzM",
        "hidden": 0
      },
      {
        "text": "Cool",
        "date": "1415979980",
        "username": "gloinart",
        "userpicture": "/media/users/gloinart/profile.jpeg",
        "id": "MslXR4",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4sfGWX",
      "date": "1380117630",
      "viewed": 105320,
      "name": "Wolfenstein 3D",
      "username": "reinder",
      "description": "Experiment to generate some well-known textures (from the [url=https://en.wikipedia.org/wiki/Wolfenstein_3D]first-person shooter video game developed by id Software[/url]) in a textureless shader.",
      "likes": 153,
      "published": 1,
      "flags": 0,
      "tags": [
        "procedural",
        "voxel",
        "textures",
        "wolfenstein"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Wolfenstein. Created by Reinder Nijhoff 2013\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4sfGWX\n//\n\n#define NUM_MATERIALS 3\n#define NUM_OBJECTS 1\n#define SECONDS_IN_ROOM 3.\n#define ROOM_SIZE 10.\n#define MAXSTEPS 17\n#define MATERIAL_DOOR 200\n#define MATERIAL_DOORWAY 201\n\n#define COL(r,g,b) vec3(r/255.,g/255.,b/255.)\n\n#define time (iTime+40.)\nvec3 rdcenter;\n\n//----------------------------------------------------------------------\n// Math functions\n\nfloat hash( const float n ) {\n    return fract(sin(n*14.1234512)*51231.545341231);\n}\nfloat hash( const vec2 x ) {\n\tfloat n = dot( x, vec2(14.1432,1131.15532) );\n    return fract(sin(n)*51231.545341231);\n}\nfloat crossp( const vec2 a, const vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\nbool intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\n\tvec2 p = ro.xz;\tvec2 r = rd.xz;\n\tvec2 q = a-p;\tvec2 s = b-a;\n\tfloat rCrossS = crossp(r, s);\n\t\n\tif( rCrossS == 0.){\n\t\treturn false;\n    } else {\n\t\tdist = crossp(q, s) / rCrossS;\n\t\tu = crossp(q, r) / rCrossS;\n\t\n\t\tif(0. <= dist && 0. <= u && u <= 1.){\n\t\t\treturn true;\n        } else {\n\t\t\treturn false;\n        }\n    }\n}\n\n//----------------------------------------------------------------------\n// Material helper functions\n\nfloat onCircle( const vec2 c, const vec2 centre, const float radius ) {\n\treturn clamp( 4.*(radius - distance(c,centre)), 0., 1. );\n}\nfloat onCircleLine( const vec2 c, const vec2 centre, const float radius ) {\n\treturn clamp( 1.-1.5*abs(radius - distance(c,centre)), 0., 1. );\n}\nfloat onLine( const float c, const float b ) {\n\treturn clamp( 1.-abs(b-c), 0., 1. );\n}\nfloat onBand( const float c, const float mi, const float ma ) {\n\treturn clamp( (ma-c+1.), 0., 1. )*clamp( (c-mi+1.), 0., 1. );\n}\nfloat onLineSegmentX( const vec2 c, const float b, const float mi, const float ma ) {\n\treturn onLine( c.x, b )*onBand( c.y, mi, ma );\n}\nfloat onLineSegmentY( const vec2 c, const float b, const float mi, const float ma ) {\n\treturn onLine( c.y, b )*onBand( c.x, mi, ma );\n}\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\n\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\n}\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\n\tfloat xl = clamp( (c.x-lt.x)/size, 0., 1. ); \n\tfloat xr = clamp( (rb.x-c.x)/size, 0., 1. );\t\n\tfloat yt = clamp( (c.y-lt.y)/size, 0., 1. ); \n\tfloat yb = clamp( (rb.y-c.y)/size, 0., 1. );\t\n\n\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRect( c, lt, rb ) );\n}\nvec3 addKnob( const vec2 c, const vec2 centre, const float radius, const float strength, const vec3 col ) {\n\tvec2 lv = normalize( centre-c );\n\treturn mix( col, col*(1.0+strength*dot(lv,vec2(-0.7071,0.7071))), onCircle(c, centre, radius ) );\n}\nfloat stepeq( float a, float b ) { \n\treturn step( a, b )*step( b, a );\n}\n//----------------------------------------------------------------------\n// Generate materials!\n\nvoid getMaterialColor( const int material, in vec2 uv, const float decorationHash, out vec3 col ) {\t\n\tvec3 fgcol;\n\t\n\tuv = floor( mod(uv+64., vec2(64.)) );\n\tvec2 uvs = uv / 64.;\n\t\n\t// basecolor\n\tvec3 basecol = vec3( mix(55./255.,84./255.,uvs.y ) );\t\n\tfloat br = hash(uv);\n\tcol = basecol;\n// grey bricks\n\tif( material == 0 || material == 1 ) {\n\t\tvec2 buv = vec2( mod(uv.x+1. + (floor((uv.y+1.) / 16.) * 16.), 32.) , mod( uv.y+1., 16.) );\n\t\tfloat bbr = mix( 190./255., 91./255., (buv.y)/14. ) + 0.05*br;\n\t\tif ( buv.x < 2. || buv.y < 2.) {\n\t\t\tbbr = 72./255.; \n\t\t}\n\t\tcol = vec3(bbr*0.95);\n\t\tcol = addBevel( buv, vec2(1.,1.), vec2( 31.5, 15.), 2., 0.35, 1., 1., col);\n\t// blue wall\n\t\tif( material == 1 ) {\n\t\t\tcol *= 1.3*COL(11.,50.,209.);\n\t\t\tcol = mix( col, COL(2.,15.,86.), onBand(uv.y,14.,49.));\n\t\t\tcol = mix( col, COL(9.,44.,185.)*(0.9+0.1*br), onBand(uv.y,16.,47.));\n\t\t\tcol = mix( col, COL(3.,25.,122.), onBand(uv.y,21.,42.));\n\t\t\tcol = addBevel( uv, vec2(-1.,16.), vec2( 65., 21.), 1., 0.35, 1., 1., col);\n\t\t\tcol = addBevel( uv, vec2(-1.,43.), vec2( 65., 48.), 1., 0.35, 1., 1., col);\n\t\t\t\n\t\t\tcol = mix( col, COL(2.,11.,74.), onRect(uv, vec2(22.,22.), vec2(42.,42.)));\t\t\n\t\t\tcol = mix( col, COL(9.,44.,185.)*(0.95+0.1*br), onRect(uv, vec2(22.,23.), vec2(42.,40.)));\n\t\t\tcol = addBevel( uv, vec2(22.,23.), vec2(42.,40.), 1., 0.2, -1., 1., col);\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.x-26.)/3.), onRect(uv, vec2(26.,23.), vec2(29.,29.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)/2.), onRect(uv, vec2(22.,34.), vec2(29.,36.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-27.)/2.), onRect(uv, vec2(35.,27.), vec2(42.,29.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)/8.), onRect(uv, vec2(35.,34.), vec2(38.,42.)));\n\t\t}\n\t}\n// wooden wall\n\telse if( material == 2 ) {\n\t\tfloat mx = mod( uv.x, 64./5. ); \n\t\tfloat h1 = hash( floor(uv.x/(64./5.)) );\n\t\tfloat h2 = hash( 1.+1431.16*floor(uv.x/(64./5.)) );\n\t\tcol = mix( COL(115.,75.,43.),COL( 71.,56.,26.), smoothstep( 0.2, 1., (0.7+h2)*abs(mod( h2-uv.y*(0.05+0.1*h2)+(1.+h1+h2)*sin(mx*(0.1+0.2*h2)), 2. )-1.) ) );\n\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x)/2.), step(uv.x,2.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-10.)/2.), step(10.,uv.x)*step(uv.x,12.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-26.)/2.), step(26.,uv.x)*step(uv.x,28.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-40.)/2.), step(40.,uv.x)*step(uv.x,42.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-54.)/2.), step(54.,uv.x)*step(uv.x,56.) );\n\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x- 8.)), step( 8.,uv.x)*step(uv.x,9.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-24.)), step(24.,uv.x)*step(uv.x,25.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-38.)), step(38.,uv.x)*step(uv.x,39.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-52.)), step(52.,uv.x)*step(uv.x,53.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-62.)), step(62.,uv.x) );\n\t\t\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.y)/2.), step(uv.y,2.) );\n\t\tcol *= 1.-0.3*stepeq(uv.y,3.);\n\t}\n// door\n\telse if( material == MATERIAL_DOOR ) {\n\t\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)/(1.3-0.8*uvs.x)) ) );\n\t\tfgcol = addBevel( uv, vec2(-1.,1.), vec2(62.,66.), 2., 0.4, -1., -1., fgcol);\n\t\tfgcol = addBevel( uv, vec2( 6.,6.), vec2(57.,57.), 2.25, 0.5, -1., -1., fgcol);\t\n\t\tfgcol = mix( addKnob( mod( uv, vec2(8.) ), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uv,  vec2( 6.,6.), vec2(57.,57.)) ) ;\n\t\t\n\t\t//knob\n\t\tfgcol *= 1.-0.2*onRect( uv, vec2( 13.5, 28.5 ), vec2( 22.5, 44.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(44.,44.,44.),COL(152.,152.,152.), ((uv.x+(43.-uv.y)-15.)/25. ) ), onRect( uv, vec2( 15., 27. ), vec2( 24., 43. ) ) );\n\t\tfgcol = addBevel( uv, vec2( 15., 27. ), vec2( 24., 43. ), 1., 0.45, 1., 1., fgcol);\t\n\t\tfgcol = mix( fgcol, addKnob( mod( uv, vec2(6.) ), vec2(4.25,5.5), 1.15, 0.75, fgcol ), onRect( uv,  vec2( 15., 27. ), vec2( 24., 43. ) ) ) ;\n\n\t\tfgcol *= 1.-0.5*onRect( uv, vec2( 16.5, 33.5 ), vec2( 20.5, 38.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(37.-uv.y)-18.)/7. ) ), onRect( uv, vec2( 18., 33. ), vec2( 21., 37. ) ) );\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onRect( uv, vec2( 19., 34. ), vec2( 20., 35.7 ) ) );\n\n\t\tfgcol *= 1.-0.2*onRect( uv, vec2( 6.5, 29.5 ), vec2( 10.5, 41.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(40.-uv.y)-9.)/13. ) ), onRect( uv, vec2( 9., 29. ), vec2( 11., 40. ) ) );\n\t\tfgcol = addBevel( uv, vec2( 9., 29. ), vec2( 11., 40. ), 0.75, 0.5, 1., 1., fgcol);\t\n\t\t\n\t\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\t\n\t}\n// doorway\n\telse if( material == MATERIAL_DOORWAY ) {\n\t\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)/(1.3-0.8*uvs.x)) ) );\n\t\tvec2 uvhx = vec2( 32.-abs(uv.x-32.), uv.y );\n\t\tfgcol = addBevel( uvhx, vec2(-1.,1.), vec2(28.,66.), 2., 0.4, -1., -1., fgcol);\n\t\tfgcol = addBevel( uvhx, vec2( 6.,6.), vec2(23.,57.), 2.25, 0.5, -1., -1., fgcol);\t\n\t\tfgcol = mix( addKnob( vec2( mod( uvhx.x, 22. ), mod( uvhx.y, 28. )), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uvhx,  vec2( 6.,6.), vec2(24.,57.)) ) ;\n\t\tfgcol = mix( fgcol, vec3(0.), onRect( uv, vec2( 29., 1.), vec2( 35., 63.) ) );\n\t\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\t\n\t}\n\t\n// prison door\t\n\tif( decorationHash > 0.93 && material < (NUM_MATERIALS+1) ) {\t\n\t\tvec4 prisoncoords = vec4(12.,14.,52.,62.);\n\t// shadow\n\t\tcol *= 1.-0.5*onRect( uv,  vec2( 11., 13. ), vec2( 53., 63. ) );\n\t// hinge\n\t\tcol = mix( col, COL(72.,72.,72.), stepeq(uv.x, 53.)*step( mod(uv.y+2.,25.), 5.)*step(13.,uv.y) );\n\t\tcol = mix( col, COL(100.,100.,100.), stepeq(uv.x, 53.)*step( mod(uv.y+1.,25.), 3.)*step(13.,uv.y) );\n\t\t\n\t\tvec3 pcol = vec3(0.)+COL(100.,100.,100.)*step( mod(uv.x-4., 7.), 0. ); \n\t\tpcol += COL(55.,55.,55.)*step( mod(uv.x-5., 7.), 0. ); \n\t\tpcol = addBevel(uv, vec2(0.,17.), vec2(63.,70.), 3., 0.8, 0., -1., pcol);\n\t\tpcol = addBevel(uv, vec2(0.,45.), vec2(22.,70.), 3., 0.8, 0., -1., pcol);\n\t\t\n\t\tfgcol = COL(72.,72.,72.);\n\t\tfgcol = addBevel(uv, prisoncoords.xy, prisoncoords.zw+vec2(1.,1.), 1., 0.5, -1., 1., fgcol );\n\t\tfgcol = addBevel(uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(2.,1.), 1., 0.5, 1., -1., fgcol );\n\t\tfgcol = mix( fgcol, pcol, onRect( uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(3.,2.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uv, vec2(15.,32.5), vec2(21.,44.) ) );\n\t\t\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.) ), stepeq(uv.x, 15.)*step(37.,uv.y)*step(uv.y,38.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.)/3. ), stepeq(uv.x, 17.)*step(37.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 18.)*step(37.,uv.y)*step(uv.y,41.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(100.,100.,100.), (uv.y-37.)/3. ), stepeq(uv.x, 18.)*step(36.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 19.)*step(37.,uv.y)*step(uv.y,40.) );\n\n\t\tfgcol = mix( fgcol, mix( COL(84.,84.,84.), COL(108.,108.,108.), (uv.x-15.)/2. ), stepeq(uv.y, 32.)*step(15.,uv.x)*step(uv.x,17.) );\n\t\tfgcol = mix( fgcol, COL(81.,81.,81.), stepeq(uv.y, 32.)*step(20.,uv.x)*step(uv.x,21.) );\n\n\t\tcol = mix( col, fgcol, onRect( uv, prisoncoords.xy, prisoncoords.zw ) );\n\t}\n// flag\n\telse if( decorationHash > 0.63 && material < (NUM_MATERIALS+1) ) {\t\t\n\t\tvec2 uvc = uv-vec2(32.,30.);\n\t\n\t// shadow\t\n\t\tvec4 shadowcoords = vec4( 14., 7., \n\t\t\t\t\t\t\t\t  54., max( 56. + sin( uv.x*0.32-1. ),56.) ); \n\t\tcol *= 1.-0.3*onRect( uv,  vec2( 6., 6. ), vec2( 61., 7. ) );\n\t\tcol *= 1.-0.3*clamp( 0.25*(56.-uv.x), 0., 1.)*onRect( uv, shadowcoords.xy, shadowcoords.zw );\n\n\t// rod\n\t\tcol = mix( col, COL(250.,167.,98.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 4., 6.5 ) );\n\t\tcol = mix( col, COL(251.,242.,53.), onLineSegmentY( uv, 5., 4., 60. ) );\n\t\tcol = mix( col, COL(155.,76.,17.), onLineSegmentY( uv, 6., 4., 60. ) );\n\t\tcol = mix( col, COL(202.,96.,25.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 26., 28. ) );\n\t\tcol = mix( col, COL(251.,242.,53.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 3., 7. ) );\n\t\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 4.3, 5.5 ) );\n\t\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 5.3, 5.5 ) );\n\t\tcol = mix( col, COL(0.,0.,0.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 18.3, 19.5 ) );\n\n\t// flag\t\n\t\tvec4 flagcoords = vec4( 13., min( 9.5 - pow(5.5* (uvs.x-0.5), 2.), 9. ), \n\t\t\t\t\t\t    51., max( 55. + sin( uv.x*0.4+2.7 ),55.) ); \n\t\n\t\tfgcol = COL(249.,41.,27.);\n\t\t\n\t\tfgcol = mix( fgcol, COL(255.,255.,255.), onBand( min(abs(uvc.x), abs(uvc.y)), 2., 4. ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onLine( min(abs(uvc.x), abs(uvc.y)), 3. ) );\t\t\n\t\t\n\t\tfgcol = mix( fgcol, COL(255.,255.,255.), onCircle( uv, vec2(32.,30.), 12.5 ) );\t\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 11. ) );\t\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 9. ) );\n\t\t\n\t\tvec2 uvr = vec2( (uvc.x-uvc.y)*0.7071, (uvc.y+uvc.x)*0.7071)*sign( uvc.x+0.5 );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(1.,4.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-4.2, 4.2), vec2(1.,6.15) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(4.,1.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2( 4.2,-1.), vec2(6.15,4.2) ) );\n\t\n\t\tfgcol *= (0.8+0.2*sin( uv.x*0.4+2.7 ));\n\t\tfgcol *= (0.8+0.2*clamp( 0.5*(uv.y-7.), 0., 1.));\n\t\n\t// mix flag on background\n\t\tcol = mix( col, fgcol, onRect( uv, flagcoords.xy, flagcoords.zw ) );\n\t}\n\t\n// fake 8-bit color palette and dithering\t\n\tcol = floor( (col+0.5*mod(uv.x+uv.y,2.)/32.)*32.)/32.;\n}\nbool getObjectColor( const int object, in vec2 uv, inout vec3 icol ) {\n\tuv = floor( mod(uv, vec2(64.)) );\n\tvec2 uvs = uv / 64.;\n\tvec3 col = vec3(20./255.);\n\tfloat d;\n\t\n// only a lamp for now\n\t\n\t// lamp top\n\td = distance( uv*vec2(1.,2.), vec2(28.1, 5.8)*vec2(1.,2.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( d/8.-0.2, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,13.6), 11.7 )*step( uv.y, 6. )); \n\tcol = mix( col, COL(9.,75.,6.), onCircleLine( uv, vec2(31.,14.), 11.6 ) *\n\t\t\t  step( length(uv-vec2(31.,13.6)), 11.7 )*step( uv.y, 6. ) );\n\tcol = mix( col, COL(100.,100.,100.), onLine( abs(uv.x-31.), 1. )*step( uv.y, 1. ) );\n\tcol = mix( col, COL(140.,140.,140.), onLine( abs(uv.x-31.), 0.25 )*step( uv.y, 1. )*step( 1., uv.y ) );\n\t\n\t// lamp bottom\n\td = distance( uv*vec2(1.,2.), vec2(30.5, 6.5)*vec2(1.,2.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( abs(uv.x-31.)/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 7.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(16.,123.,17.), clamp( abs(uv.x-31.)/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 8.) );\n\tcol = mix( col, mix( COL(133.,250.,130.), COL(22.,150.,23.), clamp( abs(uv.x-31.)/4.-0.75, 0., 1. )), step( abs(uv.x-31.), 7. )*stepeq( uv.y, 9.) );\n\n\tcol = mix( col, mix( COL(255.,251.,187.), col, clamp( d/4.5-0.6, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,1.), 10.2 )*step( uv.y, 8. )*step( 7., uv.y )); \n\tcol = mix( col, mix( COL(255.,255.,255.), col, clamp( d/4.-0.7, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,1.), 7.2 )*step( uv.y, 8. )*step( 7., uv.y )); \n\t\t\n\t// floor\n\td = distance( vec2(mod(uv.x, 32.),uv.y)*vec2(1.5,30./3.), vec2(16., 61.5)*vec2(1.5,30./3.) );\n\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(d/15.-0.5, 0., 1.) ), step(d,24.5)); \n\tcol = mix( col, mix( COL(124.,124.,124.), COL(140.,140.,140.), clamp((uv.y-59.)/1., 0., 1.)), step(59.,uv.y)*step(uv.x, 57.)*step(7.,uv.x)); \n\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(abs(32.-uv.x)/10.-2., 0., 1.)), step(uv.y, 62.)*step(62.,uv.y)*step(uv.x, 61.)*step(3.,uv.x)); \n\tcol = mix( col, mix( COL(152.,152.,152.), COL(124.,124.,124.), clamp(abs(32.-uv.x)/10.-2.25, 0., 1.)), step(uv.y, 61.)*step(61.,uv.y)*step(uv.x, 59.)*step(5.,uv.x)); \n\n\tcol = floor( (col)*32.)/32.;\n\tif( any(notEqual(col, vec3(floor((20./255.)*32.)/32.))) ) {\n\t\ticol = col;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//----------------------------------------------------------------------\n// Proocedural MAP functions\n\nbool isWall( const vec2 vos ) {\n\treturn vos.y<0.4*ROOM_SIZE || vos.y>2.75*ROOM_SIZE || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(0.,0.) ) );\n}\nbool isDoor( const vec2 vos ) {\n\treturn isWall(vos) && ((hash(vos)>0.75 &&  any( equal( mod( vos, vec2( ROOM_SIZE*0.5 ) ), vec2(2.) ) )) \n\t\t    || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(ROOM_SIZE*0.5) ) )); \n}\nbool isObject( const vec2 vos ) {\n\treturn hash( vos*10. ) > 0.95;\n}\nbool map( const vec2 vos ) {\n\treturn isObject( vos ) || isWall( vos );\n}\n\n//----------------------------------------------------------------------\n// Render MAP functions\n\nbool intersectSprite( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 nor, out vec2 uv ) {\n\tfloat dist, u;\n\tvec2 a = vos.xz + nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\n\tvec2 b = vos.xz - nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\n\tif( intersectSegment( ro, rd, a, b, dist, u) ) {\n\t\tuv.x = u; uv.y = 1.-(ro+dist*rd).y;\n\t\tif( sign(nor.x)<0. ) uv.x = 1.-uv.x;\n\t\treturn uv.y>0.&&uv.y<1.;\n\t}\n\treturn false;\n}\nint getMaterialId( const vec2 vos ) {\n\treturn int( mod( 521.21 * hash( floor((vos-vec2(0.5))/ROOM_SIZE )  ), float(NUM_MATERIALS)) );\n}\nbool getColorForPosition( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 pos, const vec3 nor, inout vec3 col ) {\t\n\tvec2 uv;\n\n\tif( isWall( vos.xz ) ) {\n\t\tif( isDoor( vos.xz ) ) {\n\t\t\tif( intersectSprite( ro, rd, vos+nor*0.03, nor, uv ) ) {\n\t\t\t\t// open the door\n\t\t\t\tuv.x -= clamp( 2.-0.75*distance( ro.xz, vos.xz+vec2(0.5) ), 0., 1.);\n\t\t\t\tif( uv.x > 0. ) {\n\t\t\t\t\tgetMaterialColor( MATERIAL_DOOR, uv*64., 0., col );\n\t\t\t\t\treturn true;\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t\treturn false;\n\t\t}\n\t\t// a wall is hit\n\t\tif( pos.y <= 1. && pos.y >= 0. ) {\n\t\t\tvec2 mpos = vec2( dot(vec3(-nor.z,0.0,nor.x),pos), -pos.y );\n    \t\tfloat sha = 0.6 + 0.4*abs(nor.z);\t\t\n\t\t\tgetMaterialColor( isDoor( vos.xz+nor.xz )?MATERIAL_DOORWAY:getMaterialId(vos.xz), mpos*64., hash( vos.xz ), col );\n\t\t\tcol *= sha;\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}\n\tif( isObject( vos.xz ) && !isWall( vos.xz+vec2(1.,0.) ) && !isWall( vos.xz+vec2(-1.,0.) )\n\t    && !isWall( vos.xz+vec2(0.,-1.) ) && !isWall( vos.xz+vec2(0.,1.) ) &&\n\t    intersectSprite( ro, rd, vos, rdcenter, uv ) ) {\n\t\treturn getObjectColor( 0, uv*64., col );\n\t}\n\treturn false;\n}\n\nbool castRay( const vec3 ro, const vec3 rd, inout vec3 col ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ )\t{\n\t\tif( hit ) continue;\n\t\t\n\t\tmm = step(dis.xyz, dis.zyx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t\t\n\t\tif( map(pos.xz) ) { \n\t\t\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\t\t\tfloat t = max ( mini.x, mini.z );\t\t\t\n\t\t\thit = getColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), col );\n\t\t}\n\t}\n\treturn hit;\n}\n\n//----------------------------------------------------------------------\n// Some really ugly code\n\n#define CCOS(a) cos(clamp(a,0.,1.)*1.57079632679)\n#define CSIN(a) sin(clamp(a,0.,1.)*1.57079632679)\nvec3 path( const float t ) {\n\tfloat tmod = mod( t/SECONDS_IN_ROOM, 8. );\n\tfloat tfloor = floor( tmod );\n\t\n\tvec3 pos = vec3( 4.*ROOM_SIZE*floor(t/(SECONDS_IN_ROOM*8.))+0.5, 0.5, 0.5*ROOM_SIZE+0.5 );\t\n\treturn pos + ROOM_SIZE*vec3(\n\t\tclamp(tmod,0.,1.)+clamp(tmod-4.,0.,1.)+0.5*(2.+CSIN(tmod-1.)-CCOS(tmod-3.)+CSIN(tmod-5.)-CCOS(tmod-7.)), 0.,\n\t\tclamp(tmod-2.,0.,1.)-clamp(tmod-6.,0.,1.)+0.5*(-CCOS(tmod-1.)+CSIN(tmod-3.)+CCOS(tmod-5.)-CSIN(tmod-7.)) );\n}\n\n\n//----------------------------------------------------------------------\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+0.1 );\n\t\n    rdcenter = rotate( normalize( ta - ro), 0.3*cos(time*0.75) );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rdcenter ));\n    vec3 vv = normalize(cross(rdcenter,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*rdcenter );\n\t\n\tvec3 col = rd.y>0.?vec3(56./255.):vec3(112./255.);\n\tcastRay( ro, rd, col );\n\t\t\n\tfragColor = vec4( col, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "nice one!",
        "date": "1533829465",
        "username": "AnnaEverson",
        "userpicture": "/media/users/AnnaEverson/profile.jpeg",
        "id": "Xsffz4",
        "hidden": 0
      },
      {
        "text": "360 at [video]https://www.youtube.com/watch?v=-bf9XoZibsI[/video]",
        "date": "1508251247",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "Xt3XWr",
        "hidden": 0
      },
      {
        "text": "@tosh: done.",
        "date": "1504880594",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "ltKGRy",
        "hidden": 0
      },
      {
        "text": "Guten tag! :) ",
        "date": "1481404392",
        "username": "pthextract",
        "userpicture": "/media/users/pthextract/profile.jpeg",
        "id": "XdKGWc",
        "hidden": 0
      },
      {
        "text": "This is super cool!",
        "date": "1440295221",
        "username": "MehediAhmed",
        "userpicture": "/img/profile.jpg",
        "id": "XdjXWd",
        "hidden": 0
      },
      {
        "text": "Not only awesome but very fast.",
        "date": "1411746635",
        "username": "Optimus",
        "userpicture": "/media/users/Optimus/profile.jpeg",
        "id": "4sfXRn",
        "hidden": 0
      },
      {
        "text": "Amazing stuff!",
        "date": "1401673651",
        "username": "pailhead",
        "userpicture": "/img/profile.jpg",
        "id": "XsS3RK",
        "hidden": 0
      },
      {
        "text": "and thanks for all the comments :)",
        "date": "1396257612",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "lsSGWW",
        "hidden": 0
      },
      {
        "text": "I have tried to convert this shader to 2k of javascript for a competition: [url=http://js1k.com/2014-dragons/demo/1934]demo[/url] and [url=http://js1k.com/2014-dragons/details/1934]source[/url].",
        "date": "1396257585",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "MdSGWW",
        "hidden": 0
      },
      {
        "text": "Awesome! \n\nThough someone not remembering the game could easily conclude we're all bloody Nazis now.\n\nAs this is a public site, adding an explicit statement that it's the scenery of a shooter game to the description wouldn't hurt - or just implement demo mode and enemies :-)",
        "date": "1380380116",
        "username": "tosh",
        "userpicture": "/img/profile.jpg",
        "id": "MsX3WS",
        "hidden": 0
      },
      {
        "text": "Here's a link to Wolfenstein's 2D ray-tracing code, if anyone's interested...\n[url]https://github.com/id-Software/wolf3d/blob/master/WOLFSRC/WL_DR_A.ASM[/url]",
        "date": "1380202660",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XsX3DB",
        "hidden": 0
      },
      {
        "text": "wow. i love the way the textures are completely procedural, and then pixelated!",
        "date": "1380194011",
        "username": "simesgreen",
        "userpicture": "/media/users/simesgreen/profile.gif",
        "id": "4dfGDB",
        "hidden": 0
      },
      {
        "text": "insanely good! my new favourite shader on shadertoy. It's so hilarious to jump thru all those hoops to replace texture fetch, but I love it! it's a tour de force. made my morning! thankyou!",
        "date": "1380191163",
        "username": "mmalex",
        "userpicture": "/img/profile.jpg",
        "id": "4sXGDB",
        "hidden": 0
      },
      {
        "text": "The texturing work is fantastic.",
        "date": "1380166046",
        "username": "morgan3d",
        "userpicture": "/media/users/morgan3d/profile.png",
        "id": "Xdf3WB",
        "hidden": 0
      },
      {
        "text": "Damn. I was thinking of doing something like this, but you beat me to it. Ah well, there's still Doom.",
        "date": "1380150300",
        "username": "fb39ca4",
        "userpicture": "/media/users/fb39ca4/profile.png",
        "id": "XsX3WB",
        "hidden": 0
      },
      {
        "text": "how is it this even works in webGL! miraculous!!!",
        "date": "1380140613",
        "username": "Antonalog",
        "userpicture": "/media/users/Antonalog/profile.jpeg",
        "id": "XdX3WB",
        "hidden": 0
      },
      {
        "text": "WOW! Super cool, and fast! I loved this game! ",
        "date": "1380139523",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "4sfGWB",
        "hidden": 0
      },
      {
        "text": "Amazing!",
        "date": "1380137666",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "4dfGWB",
        "hidden": 0
      },
      {
        "text": "Almost forgot! Awesome work by the way!",
        "date": "1380134975",
        "username": "megaton",
        "userpicture": "/media/users/megaton/profile.png",
        "id": "XdfGWB",
        "hidden": 0
      },
      {
        "text": "Also to smooth out rotation one can do something like this =)\nInstead of line 425:\n\nvec3 prev = path( time-0.1 );\nvec3 dir = normalize( ( ta - ro ) + ( ro - prev ) );\t\n\t\nrdcenter = rotate( dir, 0.3*cos(time*0.75) );",
        "date": "1380134727",
        "username": "megaton",
        "userpicture": "/media/users/megaton/profile.png",
        "id": "XsXGWB",
        "hidden": 0
      },
      {
        "text": "Thanks! I was just looking at those lines - trying to figure out how I could avoid the branches ;). Thanks!",
        "date": "1380129847",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "4sf3DS",
        "hidden": 0
      },
      {
        "text": "Super cool!!! And it runs super fast. Even at full screen I get a fluid framerate. Incredible!\n\nOne can replace lines 356 to 363 with this branchless version, dunno if that helps at this stage given that it's all full of branches anyway.\n\n[code]    var2 mpos = vec2( dot(vec3(-nor.z,0.0,nor.x),pos), -pos.y );\n    float sha = 0.6 + 0.4*abs(nor.z);[/code]\n",
        "date": "1380129706",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "Xsf3DS",
        "hidden": 0
      },
      {
        "text": "Fantastic work, those door and flag textures are perfect. I realise that a lot of the constants are the same, but I'm still amazed this runs in Angle with Chrome without bombing out. :love: it.",
        "date": "1380122845",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4df3DS",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4t2SRh",
      "date": "1441550472",
      "viewed": 84494,
      "name": "Umbrellar",
      "username": "candycat",
      "description": "Draw a umbrellar",
      "likes": 143,
      "published": 1,
      "flags": 0,
      "tags": [
        "distancefield"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [],
        "code": "float sdfCircle(vec2 center, float radius, vec2 coord )\n{\n    vec2 offset = coord - center;\n    \n    return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;\n}\n\nfloat sdfEllipse(vec2 center, float a, float b, vec2 coord)\n{\n    float a2 = a * a;\n    float b2 = b * b;\n    return (b2 * (coord.x - center.x) * (coord.x - center.x) + \n        a2 * (coord.y - center.y) * (coord.y - center.y) - a2 * b2)/(a2 * b2);\n}\n\nfloat sdfLine(vec2 p0, vec2 p1, float width, vec2 coord)\n{\n    vec2 dir0 = p1 - p0;\n\tvec2 dir1 = coord - p0;\n\tfloat h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n\treturn (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat sdfUnion( const float a, const float b )\n{\n    return min(a, b);\n}\n\nfloat sdfDifference( const float a, const float b)\n{\n    return max(a, -b);\n}\n\nfloat sdfIntersection( const float a, const float b )\n{\n    return max(a, b);\n}\n\nvec4 render(float d, vec3 color, float stroke)\n{\n    //stroke = fwidth(d) * 2.0;\n    float anti = fwidth(d) * 1.0;\n    vec4 strokeLayer = vec4(vec3(0.05), 1.0-smoothstep(-anti, anti, d - stroke));\n    vec4 colorLayer = vec4(color, 1.0-smoothstep(-anti, anti, d));\n\n    if (stroke < 0.000001) {\n    \treturn colorLayer;\n    }\n    return vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat size = min(iResolution.x, iResolution.y);\n    float pixSize = 1.0 / size;\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float stroke = pixSize * 1.5;\n    vec2 center = vec2(0.5, 0.5 * iResolution.y/iResolution.x);\n    \n    float a = sdfEllipse(vec2(0.5, center.y*2.0-0.34), 0.25, 0.25, uv);\n    float b = sdfEllipse(vec2(0.5, center.y*2.0+0.03), 0.8, 0.35, uv);\n    b = sdfIntersection(a, b);\n    vec4 layer1 = render(b, vec3(0.32, 0.56, 0.53), fwidth(b) * 2.0);\n    \n    // Draw strips\n    vec4 layer2 = layer1;\n    float t, r0, r1, r2, e, f;\n    vec2 sinuv = vec2(uv.x, (sin(uv.x*40.0)*0.02 + 1.0)*uv.y);\n    for (float i = 0.0; i < 10.0; i++) {\n    \tt = mod(iTime + 0.3 * i, 3.0) * 0.2;\n    \tr0 = (t - 0.15) / 0.2 * 0.9 + 0.1;\n    \tr1 = (t - 0.15) / 0.2 * 0.1 + 0.9;\n        r2 = (t - 0.15) / 0.2 * 0.15 + 0.85;\n        e = sdfEllipse(vec2(0.5, center.y*2.0+0.37-t*r2), 0.7*r0, 0.35*r1, sinuv);\n    \tf = sdfEllipse(vec2(0.5, center.y*2.0+0.41-t), 0.7*r0, 0.35*r1, sinuv);\n    \tf = sdfDifference(e, f);\n    \tf = sdfIntersection(f, b);\n    \tvec4 layer = render(f, vec3(1.0, 0.81, 0.27), 0.0);\n        layer2 = mix(layer2, layer, layer.a);\n    }\n    \n    \n    // Draw the handle\n    float bottom = 0.08;\n    float handleWidth = 0.01;\n    float handleRadius = 0.04;\n    float d = sdfCircle(vec2(0.5-handleRadius+0.5*handleWidth, bottom), handleRadius, uv);\n    float c = sdfCircle(vec2(0.5-handleRadius+0.5*handleWidth, bottom), handleRadius-handleWidth, uv);\n    d = sdfDifference(d, c);\n    c = uv.y - bottom;\n    d = sdfIntersection(d, c);\n    c = sdfLine(vec2(0.5, center.y*2.0-0.05), vec2(0.5, bottom), handleWidth, uv);\n    d = sdfUnion(d, c);\n    c = sdfCircle(vec2(0.5, center.y*2.0-0.05), 0.01, uv);\n    d = sdfUnion(c, d);\n    c = sdfCircle(vec2(0.5-handleRadius*2.0+handleWidth, bottom), handleWidth*0.5, uv);\n    d = sdfUnion(c, d);\n    vec4 layer0 = render(d, vec3(0.404, 0.298, 0.278), stroke);\n    \n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec3 bcol = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n    fragColor = vec4(bcol, 1.0);  \n    fragColor.rgb = mix(fragColor.rgb, layer0.rgb, layer0.a);\n    fragColor.rgb = mix(fragColor.rgb, layer1.rgb, layer1.a);\n    fragColor.rgb = mix(fragColor.rgb, layer2.rgb, layer2.a);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}",
        "name": "",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "\u54c8\u54c8\uff0c\u4e00\u770b\u8fd9\u4e2a\u5c31\u60f3\u5230\u4e86\u4f60\u90a3\u4e2aCSDN\u4e0a\u7684\u4e13\u680f\uff0c\u4f60\u73b0\u5728\u8fd8\u5728\u505aopengl\u5f00\u53d1\u5417\u5927\u59d0",
        "date": "1557142795",
        "username": "zcx",
        "userpicture": "/img/profile.jpg",
        "id": "Ml2yWW",
        "hidden": 0
      },
      {
        "text": "cuteness is proportional to aspect ratio.",
        "date": "1510383498",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "Ml3SRf",
        "hidden": 0
      },
      {
        "text": "Hi :) *OI*\n",
        "date": "1508239941",
        "username": "Imsure1200q_1UWE130",
        "userpicture": "/media/users/Imsure1200q_1UWE130/profile.jpeg",
        "id": "4lcSWn",
        "hidden": 0
      },
      {
        "text": "This is eye candy! :) \n\nLove the colors and the minimalism!",
        "date": "1507889510",
        "username": "isak",
        "userpicture": "/media/users/isak/profile.png",
        "id": "4t3XzM",
        "hidden": 0
      },
      {
        "text": "@\u840c\u840c\u54d2",
        "date": "1507537146",
        "username": "marktubu",
        "userpicture": "/img/profile.jpg",
        "id": "4l3SRN",
        "hidden": 0
      },
      {
        "text": "@candycat1992 \u00e4\u00bd\u00a0\u00e5\u00a5\u00bd\u00ef\u00bc\u0081",
        "date": "1469425644",
        "username": "zcheng",
        "userpicture": "/img/profile.jpg",
        "id": "ls3GWr",
        "hidden": 0
      },
      {
        "text": "Viewing this on a vertical resolution has the added effect of elongating the umbrella stem which I think adds extra charm to the shader.",
        "date": "1465042715",
        "username": "Friedslick6",
        "userpicture": "/media/users/Friedslick6/profile.png",
        "id": "lljSzy",
        "hidden": 0
      },
      {
        "text": "So Cute!",
        "date": "1458941032",
        "username": "Hanley",
        "userpicture": "/img/profile.jpg",
        "id": "llsSRs",
        "hidden": 0
      },
      {
        "text": "@candycat \u00e8\u00bf\u2122\u00e4\u00bc\u017e\u00e5\u00a5\u00bd\u00e8\u0090\u0152\u00e5\u2022\u0160\u00ef\u00bc\u0152\u00e8\u2021\u00aa\u00e7\u00ab\u2039\u00e8\u2021\u00aa\u00e5\u00bc\u00ba\u00e7\u0161\u201e\u00e5\u00a6\u00b9\u00e5\u00ad\u0090\u00ef\u00bc\u0081\u00e6\u0153\u20ac\u00e8\u00bf\u2018\u00e5\u0153\u00a8\u00e7\u0153\u2039\u00e4\u00bd\u00a0\u00e7\u0161\u201eblog\u00ef\u00bc\u0152\u00e5\u2020\u2122\u00e5\u00be\u2014\u00e5\u00a5\u00bd\u00e7\u201d\u00a8\u00e5\u00bf\u0192\u00e5\u2018\u00a2\u00e3\u20ac\u201a\u00e6\u0153\u0178\u00e5\u00be\u2026\u00e5\u2021\u00ba\u00e4\u00b9\u00a6\u00ef\u00bc\u0081",
        "date": "1446723622",
        "username": "ffhacker",
        "userpicture": "/media/users/ffhacker/profile.jpeg",
        "id": "MlsGRS",
        "hidden": 0
      },
      {
        "text": "\u00e5\u00be\u02c6\u00e6\u00a3\u2019\u00e5\u201c\u00a6\u00ef\u00bc\u0152\u00e4\u00b9\u2039\u00e5\u2030\u008d\u00e5\u0153\u00a8CSDN\u00e4\u00b8\u0160\u00e8\u00bf\u02dc\u00e7\u0153\u2039\u00e5\u02c6\u00b0\u00e4\u00bd\u00a0\u00e7\u0161\u201e\u00e8\u00bf\u2122\u00e4\u00b8\u00aa\u00e5\u2018\u00a2\u00ef\u00bc\u0152\u00e6\u0153\u0178\u00e5\u00be\u2026\u00e4\u00bd\u00a0\u00e7\u0161\u201e\u00e4\u00b9\u00a6",
        "date": "1446608580",
        "username": "StoneFinal",
        "userpicture": "/img/profile.jpg",
        "id": "4lsGRS",
        "hidden": 0
      },
      {
        "text": "@candycat @EvilRyu \n\u00e4\u00bd\u00a0\u00e4\u00bb\u00ac\u00e5\u00a5\u00bd\u00e5\u2022\u0160\u00ef\u00bc\u0152\u00e9\u0161\u00be\u00e5\u00be\u2014\u00e7\u0161\u201e\u00e5\u00b0\u008f\u00e4\u00bc\u2122\u00e4\u00bc\u00b4\u00ef\u00bc\u0152\u00e7\u02c6\u00b1\u00e6\u00ad\u00bb\u00e4\u00bd\u00a0\u00e4\u00bb\u00ac\u00e5\u2022\u00a6\u00ef\u00bc\u0081\n@all \u00ef\u00bc\u0161I love everyone and every shader.Happy code shader!",
        "date": "1446201431",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "XllGW7",
        "hidden": 0
      },
      {
        "text": "@EvilRyu \u00e5\u201c\u02c6\u00e5\u201c\u02c6\u00ef\u00bc\u0152\u00e6\u02dc\u00af\u00e5\u2022\u0160\u00ef\u00bc\u0081\u00e5\u00be\u02c6\u00e5\u2013\u0153\u00e6\u00ac\u00a2\u00e4\u00bd\u00a0\u00e7\u0161\u201eshader\u00ef\u00bc\u0152\u00e5\u0090\u2018\u00e4\u00bd\u00a0\u00e5\u00ad\u00a6\u00e4\u00b9\u00a0:\u00ef\u00bc\u2030",
        "date": "1446192693",
        "username": "candycat",
        "userpicture": "/media/users/candycat/profile.jpeg",
        "id": "Xtl3DM",
        "hidden": 0
      },
      {
        "text": "@candycat wow \u00e9\u0081\u2021\u00e5\u02c6\u00b0\u00e5\u203a\u00bd\u00e5\u2020\u2026\u00e5\u00b0\u008f\u00e4\u00bc\u2122\u00e4\u00bc\u00b4\u00e4\u00b8\u008d\u00e5\u00ae\u00b9\u00e6\u02dc\u201c\u00e5\u2022\u0160:P",
        "date": "1446192276",
        "username": "EvilRyu",
        "userpicture": "/media/users/EvilRyu/profile.jpeg",
        "id": "4lsGDM",
        "hidden": 0
      },
      {
        "text": "@EvilRyu \u00e5\u201c\u2021\u00ef\u00bc\u0152\u00e5\u00a5\u00bd\u00e6\u201e\u008f\u00e5\u00a4\u2013",
        "date": "1446174343",
        "username": "candycat",
        "userpicture": "/media/users/candycat/profile.jpeg",
        "id": "4llGDM",
        "hidden": 0
      },
      {
        "text": "@834144373 \u00e4\u00bd\u00a0\u00e5\u00a5\u00bd\u00e5\u2022\u0160",
        "date": "1446174066",
        "username": "EvilRyu",
        "userpicture": "/media/users/EvilRyu/profile.jpeg",
        "id": "XllGDM",
        "hidden": 0
      },
      {
        "text": "Love the color",
        "date": "1446173882",
        "username": "EvilRyu",
        "userpicture": "/media/users/EvilRyu/profile.jpeg",
        "id": "4tlGDM",
        "hidden": 0
      },
      {
        "text": "\u00e5\u201c\u02c6\u00e5\u201c\u02c6,nice work,\n\u00e6\u0152\u00ba\u00e8\u0090\u0152\u00e7\u0161\u201e\u00e6\u201e\u0178\u00e8\u00a7\u2030",
        "date": "1442210476",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "4tfGzN",
        "hidden": 0
      },
      {
        "text": "I'm very glad you like it!",
        "date": "1441698139",
        "username": "candycat",
        "userpicture": "/media/users/candycat/profile.jpeg",
        "id": "XllGRH",
        "hidden": 0
      },
      {
        "text": "Super cute",
        "date": "1441670104",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4ts3z8",
        "hidden": 0
      },
      {
        "text": "Cute!!",
        "date": "1441568030",
        "username": "Artoo",
        "userpicture": "/img/profile.jpg",
        "id": "XllGR8",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4tByz3",
      "date": "1511132429",
      "viewed": 30020,
      "name": "Ladybug",
      "username": "iq",
      "description": "A ladybug on a mushroom. It renders really slowly. Sorry for that, this is not meant to be rendered with raymarching really, but well, here we are. I'll get a pass later",
      "likes": 139,
      "published": 3,
      "flags": 32,
      "tags": [
        "3d",
        "raymarching",
        "distancefield",
        "procedueal"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    \n    \n    // dof\n    const float focus = 2.35;\n\n    vec4 acc = vec4(0.0);\n    const int N = 12;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off/vec2(800.0,450.0) ); \n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        float coc = 0.05 + 12.0*abs(depth-focus)/depth;\n        \n        if( dot(off,off) < (coc*coc) )\n        {\n            float w = 1.0/(coc*coc); \n            acc += vec4(color*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz / acc.w;\n\n    \n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    // color correct - it seems my laptop has a fucked up contrast/gamma seeting, so I need\n    //                 to do this for the picture to look okey in all computers but mine...\n    col = col*1.1 - 0.06;\n    \n    // vignetting\n    col *= 0.8 + 0.3*sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "XsX3Rn",
            "filepath": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
            "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define MAT_MUSH_HEAD 1.0\n#define MAT_MUSH_NECK 2.0\n#define MAT_LADY_BODY 3.0\n#define MAT_LADY_HEAD 4.0\n#define MAT_LADY_LEGS 5.0\n#define MAT_GRASS     6.0\n#define MAT_GROUND    7.0\n#define MAT_MOSS      8.0\n#define MAT_CITA      9.0\n\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\n\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\n{\n    vec3 p = pos - cen;\n    float d = length(p/rad) - 1.0;   \n    return d * min(min(rad.x,rad.y),rad.z);\n}\n    \nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\n{\n    vec3 pa = pos - a;\n    vec3 ba = b - a;\n   \n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n    return vec2( length(pa-h*ba), h );\n}\n\nvec2 sdLineOri( in vec3 p, in vec3 b )\n{\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\n    \n    return vec2( length(p-h*b), h );\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec3 smax( vec3 a, vec3 b, float k )\n{\n\tvec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat length2(in vec2 p ) { return dot(p,p); }\nfloat length2(in vec3 p ) { return dot(p,p); }\n\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n\n//==================================================\n\n#define ZERO (min(iFrame,0))\n\n//==================================================\n\nvec3 mapLadyBug( vec3 p, float curmin )\n{\n    \n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\n    \n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\n\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\n\n    // --------\n    vec3 hc = vec3(0.0,0.1,0.8);\n    vec3 ph = rotateX(p-hc,0.5);\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\n\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\n    \n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\n\n    // -------------\n    \n    vec3 k1 = vec3(0.42,-0.05,0.92);\n    vec3 k2 = vec3(0.49,-0.2,1.05);\n    float dLegs = 10.0;\n\n    float sx = sign(p.x);\n    p.x = abs(p.x);\n    for( int k=0; k<3; k++ )\n    {   \n        vec3 q = p;\n        q.y -= min(sx,0.0)*0.1;\n        if( k==0) q += vec3( 0.0,0.11,0.0);\n        if( k==1) q += vec3(-0.3,0.1,0.2);\n        if( k==2) q += vec3(-0.3,0.1,0.6);\n        \n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\n        dLegs = min(dLegs,se.x);\n\n        se = sdLine( q, k1, k2 );\n        se.x -= 0.01 + 0.01*se.y;\n        dLegs = min(dLegs,se.x);\n\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\n        se.x -= 0.02 - 0.01*se.y;\n        dLegs = min(dLegs,se.x);\n    }\n    \n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\n\n\n    return res;\n}\n\n\nvec3 worldToMushrom( in vec3 pos )\n{\n    vec3 qos = pos;\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\n    qos.y -= 0.4;\n    return qos;\n}\n\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\n{\n    vec3 res = cur;\n\n    vec3 qos = worldToMushrom(pos);\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\n    if( db<cur.x )\n    {\n\n        {\n\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\n\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\n\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\n            float d = smax( d1, -d2, 0.1 );\n            d *= 0.8;\n            if( d<res.x )\n            {\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\n            }\n        }\n\n\n        {\n            pos.x += 0.3*sin(pos.y) - 0.65;\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\n\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\n\n            float d3 = se.x - tt;\n\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\n            d3 += 0.003*pa;\n            d3 *= 0.7;\n            \n            if( d3<res.x )\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\n        }\n    \n    }\n    return res;\n}\n\n\n\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\n{\n    vec3 res = cur;\n    \n    float db = pos.y-2.6;\n    \n    if( db<cur.x && pos.z>-1.65 )\n    {\n        const float gf = 4.0;\n\n        vec3 qos = pos * gf;\n\n        vec2 n = floor( qos.xz );\n        vec2 f = fract( qos.xz );\n        for( int j=-2; j<=2; j++ )\n        for( int i=-2; i<=2; i++ )\n        {\n            vec2  g = vec2( float(i), float(j) );\n\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\n\n            if( ra2.x<0.73 ) continue;\n\n            vec2  o = hash2( n + g );\n            vec2  r = g - f + o;\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\n\n            float gh = 2.0*(0.3+0.7*ra.x);\n\n            float rosy = qos.y - h*gf;\n\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\n            r.x -= 0.03*rosy*rosy;\n\n            r.x *= 4.0;\n\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\n\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\n            float d = se.x - gr;\n            d /= 4.0;\n\n            d /= gf;\n            if( d<res.x )\n            {\n                res.x = d;\n                res.y = MAT_GRASS;\n                res.z = r.y;\n            }\n        }\n    }\n    \n    return res;\n}\n\n\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\n{\n    vec3 res = cur;\n    \n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\n    float dm = 1e10;\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 o = vec3(0.0,3.2,0.0);\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\n        float d = length2(pos - o);\n        dm = min(d,dm);\n    }\n    dm = sqrt(dm)-0.02;\n    \n    if( dm<res.x )\n        res = vec3( dm,MAT_CITA,0);\n    \n    return res;\n}\n\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\n{\n    vec3 res = cur;\n\n    float db = pos.y-2.2;\n    if( db<res.x )\n    {\n    const float gf = 2.0;\n    \n    vec3 qos = pos * gf;\n    vec2 n = floor( qos.xz );\n    vec2 f = fract( qos.xz );\n\n    for( int k=ZERO; k<2; k++ )\n    {\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2  g = vec2( float(i), float(j) );\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\n            vec2  r = g - f + o;\n\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\n\n            float mh = 0.5 + 1.0*ra2.y;\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\n\n            vec3 rr = vec3(r.x,ros.y,r.y);\n\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\n\n            rr.xz += 0.5*(-1.0+2.0*ra2);\n            vec2 se  = sdLineOri( rr, vec3(0.0,gf*mh,0.0) );\n            float sey = se.y;\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\n\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\n\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\n            float cc = cos(an);\n            float ss = sin(an);\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\n\n            pp.xz = abs(pp.xz);\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\n\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\n            d = smin( d, d2, 0.05 );\n\n            d /= gf;\n            d *= 0.9;\n            if( d<res.x )\n            {\n                res.x = d;\n                res.y = MAT_MOSS;\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\n                res.z *= 0.02 + 0.98*e*e;\n                \n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\n            }\n        }\n    }\n\n    }\n    \n    return res;\n}\n\n\nvec3 worldToLadyBug( in vec3 p )\n{\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\n    p.y += 0.2;\n    return p;\n}\n\n\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\n\nfloat terrain( in vec2 pos )\n{\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\n}\n\nvec3 mapShadow( in vec3 pos )\n{\n    float h = terrain( pos.xz );\n    float d = pos.y - h;\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\n    \n    res = mapGrass(pos,h,res);\n    res = mapMoss(pos,h,res);\n\n    vec3 m1 =  pos - mushroomPos1;\n    vec3 m2 = (pos - mushroomPos2).zyx;\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\n\tres = mapMushroom(m1, res);\n\n\n    vec3 q = worldToLadyBug(pos);\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\n    if( d3.x<res.x ) res = d3;\n\n    return res;\n}\n\n\nvec3 map( in vec3 pos )\n{\n    vec3 res = mapShadow(pos);\n        \n    res = mapCrapInTheAir(pos, res);\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec2 e = vec2(0.002,0.0); \n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*0.002).x;\n    }\n    return normalize(n);\n#endif    \n}\n    \nfloat calcShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<100; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = mapShadow( pos ).x;\n        res = min( res, 16.0*max(h,0.0)/t );\n        if( h<0.0001 || pos.y>3.0 ) break;\n        \n        t += clamp(h,0.01,0.2);\n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    const float tmax = 12.0;\n    \n\tvec3 res = vec3(1.0,-1.0, 0.0);\n\n    for( int i=ZERO; i<256; i++ )\n    {\n        vec3 h = map( ro + rd*res.x );\n        if( h.x<(0.00015*res.x) || res.x>tmax )\n            break;\n        res.x += h.x;\n        res.y = h.y;\n        res.z = h.z;\n    }\n    \n    if( res.x>=tmax ) res.y = -1.0;\n    \n    return res;\n}\n\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\n                out vec3 matColor, out float matRough,\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\n{\n    matNor = nor;\n    matOcc = 1.0;\n    matSSS = 0.0;\n    matRough = 1.0;\n    matRefOcc = 1.0;\n    matGamma = vec3(1.0);\n    \n    if( matID<MAT_MUSH_HEAD+0.5 )\n    {\n        vec3 m1 =  pos - mushroomPos1;\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\n\n        vec3 qos = worldToMushrom( m1 );\n\n        matColor = vec3(0.26,0.21,0.15);\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\n        matColor *= 0.4*0.45;\n        matColor = max( matColor, 0.0 );\n        \n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\n        \n        matRough = 0.6;\n        matSSS = 1.0;\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\n        matRefOcc = matOcc;\n        matGamma = vec3(0.75,0.87,1.0);\n    }\n    else if( matID<MAT_MUSH_NECK+0.5 )\n    {\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\n\n        matColor = vec3(0.42,0.35,0.15);\n        \n        float pa = smoothstep(0.3,0.8,pos.y);\n\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\n        matColor = max(vec3(0.0),matColor);\n        \n        matColor *= 0.22;\n        matColor = clamp( matColor, 0.0, 1.0 );\n        \n        matRough = 0.7;\n        matSSS = 1.0;\n        \n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\n        matOcc = matOcc*matOcc;\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\n        matRefOcc = matOcc;\n        matGamma = vec3(0.75,0.95,1.0);\n\n    }\n    else if( matID<MAT_LADY_BODY+.5 )\n    {\n        vec3 qos = worldToLadyBug( pos );\n            \n        // red\n        matColor = vec3(0.16,0.008,0.0);\n\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\n        \n        qos.x = abs(qos.x);\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\n\n        // white\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\n\n        // black\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\n        \n        \n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\n        matColor *= 1.0 - 0.5*f;\n        f = texture( iChannel1, 4.0*qos.xz ).x;\n        matColor *= 1.0 - 0.99*f*f;\n        \n        \n        matColor *= 1.3;\n        matRough = 0.15;\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\n    }\n    else if( matID<MAT_LADY_HEAD+.5 )\n    {\n        vec3 qos = worldToLadyBug( pos );\n\n        matColor = vec3(0.001);\n\n        qos.z += -0.22;\n        qos.y += -0.7;\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\n        matRough = 0.2;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_LADY_LEGS+.5 )\n    {\n        matColor = vec3(0.0,0.0,0.0);\n        matRough = 0.8;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_GRASS+0.5 )\n    {\n    \tmatColor = vec3(0.1,0.15,0.03);\n        \n        float h = terrain( pos.xz );\n        float e = clamp(pos.y-h,0.0,1.0);\n        matOcc = 0.01 + 0.99*e*e;\n        \n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\n        matColor += 0.04*sin(matID2*41.0);\n        \n        matSSS = 0.2;\n        matColor *= 0.75;\n        matRough = 0.5;\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\n        matRefOcc = matOcc;\n        matGamma = vec3(0.9,0.9,1.0);\n    }\n    else if( matID<MAT_GROUND+0.5 )\n    {\n        matColor = vec3(0.2,0.2,0.0);\n        matRough = 1.0;\n        matOcc = 0.02;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_MOSS+0.5 )\n    {\n        matColor = vec3(0.18,0.15,0.02);\n        \n        \n        if( matID2<0.0 ) matColor = vec3(0.1,0.05,0.005);\n        \n        \n        float f = texture( iChannel1, pos.xy*8.0 ).x;\n        matColor *= 0.55 + f;\n            \n        matOcc = abs(matID2);\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\n        matRough = 0.25;\n        matSSS = 0.5;\n        matRefOcc = matOcc;\n        matGamma = vec3(0.7,0.7,1.0);\n        \n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\n    }\n    else //if( matID<MAT_CITA+0.5 )\n    {\n        matColor = vec3(1.0);\n        matSSS = 1.0;\n        matRough = 1.0;\n        matGamma = vec3(0.5);\n    }\n}\n\n\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\n               in float occ,\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\n               in vec3 matGamma )\n{\n    vec3 col = vec3(0.0);\n\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\n    \n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\n    \n    float pn = exp2( 10.0*(1.0-matRough) );\n    \n\n    // sun light\n    {\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\n        vec3 hal = normalize( sun - rd );\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\n    }\n\n    // sky light\n    {\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\n        float dif = 0.5 + 0.5*nor.y;\n        col += matColor * skyColor * dif * occ;\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\n    }\n\n    // bounce light\n    {\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\n        col += matColor * bouColor * dif * occ;\n    }\n\n    col += fre*matColor*occ*matSSS;\n    col = pow( max(col,0.0), matGamma );\n\n    return col;\n}\n\nvec3 background(in vec3 d)\n{\n    // cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                                     d.xy/d.z;\n    \n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\n}\n\nmat3 calcCamera( in vec3 ro, in vec3 ta )\n{\n    vec3 w = normalize( ro-ta );\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\n    vec3 v = normalize( cross( w, u ) );\n    \n    return mat3( u, v, w );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\n    \n    // camera\n    vec3 ro = vec3(0.0,2.7,-3.0);\n    vec3 ta = vec3(0.0,1.9,0.0);\n    ro.x += 0.3*sin(0.03*iTime);    \n    mat3 camRot = calcCamera( ro, ta );\n    \n    // ray\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\n    \n    // background\n    vec3 col = background(rd);\n \n    // scene\n    vec3 tm = intersect(ro,rd);\n    float t = tm.x;\n    float matID = tm.y;\n    if( matID>0.5 )\n    {\n        vec3 pos = ro + t*rd;\n    \tvec3 nor = calcNormal( pos ); \n        \n        vec3 matNormal, matColor, matGamma;\n        float matRough, matOcc, matSSS, matRefOcc;\n        \n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\n    }\n    else\n    {\n        t = 30.0;\n    }\n    \n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "I think there is a way that you could progressively raymarch it, but I'm not that good at these things yet.",
        "date": "1555027756",
        "username": "ShadowFlare",
        "userpicture": "/img/profile.jpg",
        "id": "Ml2czR",
        "hidden": 0
      },
      {
        "text": "20-23fps on 1070ti for me, but slows everything else to a crawl while doing so. Still, very amazing!",
        "date": "1550777583",
        "username": "technobaboo",
        "userpicture": "/img/profile.jpg",
        "id": "4tfyW4",
        "hidden": 0
      },
      {
        "text": "Wow, amazing! :-) But makes my 1080ti stutter!!... ",
        "date": "1531591166",
        "username": "marsipan",
        "userpicture": "/img/profile.jpg",
        "id": "4sByDK",
        "hidden": 0
      },
      {
        "text": "This shader and the one with the snail are the most amazing shaders here. I love them!",
        "date": "1530761255",
        "username": "eclectic",
        "userpicture": "/img/profile.jpg",
        "id": "XsjyRt",
        "hidden": 0
      },
      {
        "text": "But Amazing",
        "date": "1529400029",
        "username": "yuletian",
        "userpicture": "/media/users/yuletian/profile.png",
        "id": "Xd2czy",
        "hidden": 0
      },
      {
        "text": "12fps on GTX1066",
        "date": "1529400007",
        "username": "yuletian",
        "userpicture": "/media/users/yuletian/profile.png",
        "id": "4sjczy",
        "hidden": 0
      },
      {
        "text": "@etale_cohomology, yes, computers are too slow for programs that calculate whole scene geometry 4 million times every frame.",
        "date": "1520947032",
        "username": "metalim",
        "userpicture": "/media/users/metalim/profile.jpeg",
        "id": "MdlcDr",
        "hidden": 0
      },
      {
        "text": "(computers are still WAY too slow for the rigors of unconstrained computer graphics!)",
        "date": "1520724609",
        "username": "etale_cohomology",
        "userpicture": "/media/users/etale_cohomology/profile.png",
        "id": "XdsyDn",
        "hidden": 0
      },
      {
        "text": "Runs at 16fps with an NVIDIA Titan V (linux driver 390.30)",
        "date": "1520724503",
        "username": "etale_cohomology",
        "userpicture": "/media/users/etale_cohomology/profile.png",
        "id": "4slyDn",
        "hidden": 0
      },
      {
        "text": "oh my......",
        "date": "1516722795",
        "username": "jcyuan",
        "userpicture": "/img/profile.jpg",
        "id": "4lKSRt",
        "hidden": 0
      },
      {
        "text": "1 fps on fullscreen. But it looks amazing",
        "date": "1514585096",
        "username": "janispritzkau",
        "userpicture": "/img/profile.jpg",
        "id": "XtGSDm",
        "hidden": 0
      },
      {
        "text": "I'll never feel bad about my heavy shaders again... but then they are not remotely as complex and slick as this one... so maybe I'll still fee bad ;)\n\nJust had to think back at the first GLSL example I saw on some GPU from 3Dlabs (http://prideout.net/archive/shots/glsldemo.png) and thought \"Geez, OpenGL came a long way from the old SGI-times!\"... and here we are today, able to write whole rendering-systems in a shader on the web.",
        "date": "1512445884",
        "username": "MacSlow",
        "userpicture": "/media/users/MacSlow/profile.jpeg",
        "id": "XlGSzh",
        "hidden": 0
      },
      {
        "text": "zproxy, nice 360 video. (Readers -- remember to click pause on the above ShaderToy before playing the YouTube video)",
        "date": "1512260428",
        "username": "BlurBusters",
        "userpicture": "/media/users/BlurBusters/profile.png",
        "id": "4tKXzR",
        "hidden": 0
      },
      {
        "text": "360 at [video]https://www.youtube.com/watch?v=ZJZMjMjfQFk[/video]",
        "date": "1511999207",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "MttXWl",
        "hidden": 0
      },
      {
        "text": "\"mapCrapInTheAir\" hahah",
        "date": "1511977074",
        "username": "tetsuo",
        "userpicture": "/img/profile.jpg",
        "id": "4ldSDs",
        "hidden": 0
      },
      {
        "text": "Iq, brilliant picts there. You\u00b4re a great source of inspiration to me. Thanks for all work. :)",
        "date": "1511773218",
        "username": "ingagard",
        "userpicture": "/img/profile.jpg",
        "id": "4t3SDl",
        "hidden": 0
      },
      {
        "text": "Brilliant! Looks very real :-)",
        "date": "1511534424",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "MtcXDX",
        "hidden": 0
      },
      {
        "text": "I'm beyond speechless ",
        "date": "1511467514",
        "username": "slerpy",
        "userpicture": "/media/users/slerpy/profile.png",
        "id": "4tcSDf",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret2 Thx. I see what you mean.",
        "date": "1511445049",
        "username": "rs",
        "userpicture": "/media/users/rs/profile.jpeg",
        "id": "Xl3SWf",
        "hidden": 0
      },
      {
        "text": "wow\uff0camazing\uff01\n12.5 FPS on GTX1060",
        "date": "1511439004",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "Xl3XDX",
        "hidden": 0
      },
      {
        "text": "wow, super report; thanks !",
        "date": "1511393742",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Xt3XWX",
        "hidden": 0
      },
      {
        "text": "@Fabrice, this is a summary of the process (click on the image to see the original):\r\n  [img]http://iquilezles.org/trastero/process.png[/img]\r\n\r\nAs it says in the image, I'll talk more about it soon in my Patreon page ([url]https://www.patreon.com/inigoquilez[/url]) and my website ([url]http://www.iquilezles.org/[/url]). You can also see another typical breakdown in the video this page: [url]http://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm[/url]",
        "date": "1511393332",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XlcSWX",
        "hidden": 0
      },
      {
        "text": "Of course it runs faster if you reduce the voronoi search size. But, also of course, I chose those loop limits for a good reason -\r\n reducing them breaks the image (for the grass elements span beyond 2 grid cells). So that's not an option for me.\r\n\r\nThe only way to reduce the loops, as I said, is to generate the grass/moss elements in a way that allows you to know the direction of growth (and hence cell overlap) beforehand without evaluating the full distance field. Then you can explore only the relevant part of the grid. Since that's not easily done at runtime, an option is to precompute it in the first frame of the animation and store it in a buffer where each texel encodes the xmin,xmax,ymin,ymax of the smallest search box for each grid cell that gives correct results.\r\n\r\nA classic trick in real applications that render vegetation is to reduce the amount of elements with distance, dof and mblur, and make them thicker to compensate for the lost pixel coverage. That works great for images with a big dynamic range of distances. In this case all the content is concentrated in small distance and with a long lens, so not much can be done. You can still try it by doing [code]    int km = ( pos.z>1.0 ) ? 1 : 2;\r\n    for( int k=0; k<km; k++ )[/code] in line 300 and float d2 = se2.x - (0.02 + 0.03*se2.y)*((km==2)?1.0:2.0); in line 336. Still, all you get is a win of 1.03x. Probably, because of the way WebGL is unrolling these loops.\r\n\r\nAnyway. Yes, I did look into all the alternatives I could think of (and believe me, rendering massive amounts of vegetation efficiently is something I know about).\r\n\r\nI might try dr2's hexagonal pattern next time, a 2-ring search should involve 19 cells instead of 25, so there's that, although the density will decrease, so that might require a 3-ring search, defeating the point. We'll see.",
        "date": "1511388995",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "Xl3SWX",
        "hidden": 0
      },
      {
        "text": "I think iq already explained that he wants the grass to cover more area continuously, although I'm sure there's ways around that with smaller loops.",
        "date": "1511348024",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MldSW2",
        "hidden": 0
      },
      {
        "text": "If you want it to run 3x faster, reduce the Voronoi loop counts:\n\nIn mapGrass -\n        //for( int j=-2; j<=2; j++ )\n        //for( int i=-2; i<=2; i++ )\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n       \nIn mapMoss:\n    //for( int k=0; k<2; k++ )\n    for( int k=0; k<1; k++ )\n\nI have done this in https://www.shadertoy.com/view/llXfRM (unlisted) - I also omitted the DoF to see if the extra buffer slows things (only a slight effect).\n\nIf you use the hexagon-based Voronoi, as in https://www.shadertoy.com/view/MlsBzN (Succulent Forest), you will get this speedup (perhaps even slightly more), without the visual artifacts that the extra square Voronoi cells are needed to prevent.\n\nAs they say, just my 2c. Of course YMMV :octopusballoon:\n",
        "date": "1511346029",
        "username": "dr2",
        "userpicture": "/img/profile.jpg",
        "id": "MltSW2",
        "hidden": 0
      },
      {
        "text": "@iq: BTW, any idea how much time  you spent on the making ?  and possibly, on the raw making vs the fine tweaking ?",
        "date": "1511339300",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "lldSDj",
        "hidden": 0
      },
      {
        "text": "Amazing!!!",
        "date": "1511330575",
        "username": "smkgames",
        "userpicture": "/media/users/smkgames/profile.png",
        "id": "lttSDj",
        "hidden": 0
      },
      {
        "text": "@Fabrice, if I disable the materials I still get pretty much the same FPS (well, it improves by a 1.03x)",
        "date": "1511325075",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "lldXWj",
        "hidden": 0
      },
      {
        "text": "@rs: for a convex component, testing dot(rayDir,obj-raySamplePos) before considering its distance. But this test is about the same cost as the distance evaluation (for base objects), so it is doubling the cost in all the cases while saving maxi 50% in some cases.",
        "date": "1511275223",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XttSW2",
        "hidden": 0
      },
      {
        "text": "@iq Wow.",
        "date": "1511270757",
        "username": "rs",
        "userpicture": "/media/users/rs/profile.jpeg",
        "id": "XldXDj",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret2 \"backface culling (ignoring backsided distances)\" how would you do that in a distance field?",
        "date": "1511270724",
        "username": "rs",
        "userpicture": "/media/users/rs/profile.jpeg",
        "id": "4tdXDj",
        "hidden": 0
      },
      {
        "text": "WOW! So beautiful!",
        "date": "1511259006",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "4ltSDj",
        "hidden": 0
      },
      {
        "text": "29fps on my 1070 alienware....  man it's so amazing!",
        "date": "1511257343",
        "username": "pellicus",
        "userpicture": "/media/users/pellicus/profile.jpeg",
        "id": "4ttSDj",
        "hidden": 0
      },
      {
        "text": "@iq:\n- \" /dot(b,b) pre-computed since the lengths are fixed,\": Isn't the optimizer is supposed to find this by itself ?\n- shading cost: uh, in material(), adding a return at first position doubled the fps, but not if added right after \" matNor = nor;\". ok, then :-)\n- backface optimisation: yep, the (unlikely) peak best to gain is 50%, but the additional cost is probably way more.",
        "date": "1511247787",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XldSWj",
        "hidden": 0
      },
      {
        "text": "Yeah, the cost of shading is 0. So not only it's useless to optimize shading, but trying to conditionally simplify based on DOF would probably make it more expensive.\r\n\r\nThe cost of shadows is almost 0 too (since shadows are found so early on). Not worth trying to reduce number of steps or casting the ray from light to surface instead of surface to light (classic trick to speed things up sometimes). Shadows are not the issue. All the cost is in the intersection/raymarch of the primary ray.\r\n\r\nGeometrically, the cost is not the mushroom nor the ladybug. Still, both use bounding spheres right now, but that helps nothing.\r\n\r\nAll the cost is in the grass and moss intersection. The 5x5 and 3x3 search kernels are necessary to prevent missing intersections, since moss and specially grass are bent and cross one or two cells. Since the bending is in arbitrary directions, the \"offset search by 1 and reduce range\" trick cannot be applied.\r\n\r\nI think the optimization effort should go into either micro-optimizations inside the moss and grass inner loops (for example, the sdLineOri calls on moss could have /dot(b,b) pre-computed since the lengths are fixed, or replacing the sin/cos rotations with a reflect in lines 327), or go all the way and do higher level optimizations such as raymarching with over-stepping + correction?",
        "date": "1511237536",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4ltSWj",
        "hidden": 0
      },
      {
        "text": "shadow loop down to 50 save nothing\nintersec loop down to 100 save 6% (no visible change)\ndecentered finite difference for N save 13% (no visible change)\nSmall gain.",
        "date": "1511219585",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4ttSWj",
        "hidden": 0
      },
      {
        "text": "oops sorry, mapGrass is Grass geometry, not texture.\nstill, material() cost 48% ( which is strange: no loop or Perlin noise inside. Is adding a return at the beginning really testing the right way ? )",
        "date": "1511218724",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XttSWj",
        "hidden": 0
      },
      {
        "text": "well, the cost of mapGrass is 55% of the total, and all the rest (marching + other maps) is 45% ;-)",
        "date": "1511218361",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MlcXD2",
        "hidden": 0
      },
      {
        "text": "such amazing quality",
        "date": "1511218297",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "llcXD2",
        "hidden": 0
      },
      {
        "text": "Also, the grass probably  does not need noise in its color when out of focus. Maybe the backProjected CoC (generalisation of MIPmap LOD) could be  considered at shading for minimum scale of noise evaluation. ( Anyway, it might be that this part of the cost is almost nothing compare to marching cost).",
        "date": "1511211950",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ll3XD2",
        "hidden": 0
      },
      {
        "text": "Here is the heat map showing the cost of each 8x8 pixel blocks in fullscreen  (computed here[url]https://www.shadertoy.com/view/ltfBzN[/url] ).\nColor scale:\nBlue: < 25%*average.  Green/yellow : average cost. Violet : > 200%*average.\n[img]https://img4.hostingpics.net/pics/919673rainbow.png[/img]\n- Why is the left side more costly than the right side ?\n- Silhouettes are costly. Could we do some \"backface culling\" ? (ignoring backsided distances) \n[img]https://img4.hostingpics.net/pics/308010heatmap8.png[/img]",
        "date": "1511211617",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Mt3XD2",
        "hidden": 0
      },
      {
        "text": "its very nice, as usual, but very slow alos on my gpu, 3.5fps snif",
        "date": "1511211234",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "llcSD2",
        "hidden": 0
      },
      {
        "text": "oh wow, it's like animated photograph!",
        "date": "1511210861",
        "username": "kuvkar",
        "userpicture": "/media/users/kuvkar/profile.png",
        "id": "Ml3SD2",
        "hidden": 0
      },
      {
        "text": "indeed it's precisely\nvec3 col = textureLod( iChannel0, q, log2(coc) ) \nwith coc as defined line 31\n",
        "date": "1511203512",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "llcXW2",
        "hidden": 0
      },
      {
        "text": "a very cheap version of the Depth of Field using MIPmap (cheap in cost and quality ;-) ):\n\n    float depth =  texture( iChannel0, q).w;\n    vec3 col = textureLod( iChannel0, q, clamp(depth-2.,0.,3.)).rgb;\n\n(and set MIPmap for bufA)",
        "date": "1511202685",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ll3XW2",
        "hidden": 0
      },
      {
        "text": "Beautiful scene, iq! Is it possible to implement separable blur for a few more FPS?",
        "date": "1511201954",
        "username": "stb",
        "userpicture": "/img/profile.jpg",
        "id": "Mt3XW2",
        "hidden": 0
      },
      {
        "text": "So Pretty!! Amazing as always.",
        "date": "1511201846",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "lt3XW2",
        "hidden": 0
      },
      {
        "text": "Hey iq, I've just noticed your intercept loop could be 100 and your calcShadow loop < 50 or less. Not to mention the 25 loops of the mapGrass stuff where a large percent of it gets discarded anyway.",
        "date": "1511188526",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "llcSDj",
        "hidden": 0
      },
      {
        "text": "@lamogui If you want it webGL 1 compatible just replace all 2x2 by 2 and all 3x3 by 3. I don't know why iq has done that, probably part of an experiment.",
        "date": "1511187297",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "ll3SDj",
        "hidden": 0
      },
      {
        "text": "Doesn't compile on firefox with Nvidia 780 Ti\n\nLine 153 mat2x2 : no matching overloaded function found\nLine 686 mat3x3 : syntax error \n\n\n",
        "date": "1511180688",
        "username": "lamogui",
        "userpicture": "/media/users/lamogui/profile.png",
        "id": "ltcXWj",
        "hidden": 0
      },
      {
        "text": "Looks awesome iq! It's running at 30 fps on my Titan X (windows-chrome).",
        "date": "1511179042",
        "username": "Nesvi7",
        "userpicture": "/media/users/Nesvi7/profile.png",
        "id": "Ml3XWj",
        "hidden": 0
      },
      {
        "text": "Perfect!",
        "date": "1511178722",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "ll3XWj",
        "hidden": 0
      },
      {
        "text": "Looks like the moss and grass are the killers (they even totally killed my machine...) :)\nIn the k-loop at line 300, set the upper limit to \"1\" for 50% speedup without much visual impact.",
        "date": "1511173110",
        "username": "dr2",
        "userpicture": "/img/profile.jpg",
        "id": "Mt3XWj",
        "hidden": 0
      },
      {
        "text": "Wow! This level of quality is simply amazing... Almost photographic.",
        "date": "1511168179",
        "username": "rigel",
        "userpicture": "/media/users/rigel/profile.png",
        "id": "Ml3SWj",
        "hidden": 0
      },
      {
        "text": "I'm curious: do you use some BBbox or sphereBox before testing intersection with the ladybird and mushroom ? or all the cost is spent on the grass anyway ? \n( I dream of a way to have a heat map giving the cost of each pixel, or anything close ).",
        "date": "1511167474",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "lt3SWj",
        "hidden": 0
      },
      {
        "text": "funny, I recognized the style before seeing the name ;-) . \n\ngorgeous, but 3-4\" of compilation and 1.5 fps, though.",
        "date": "1511167249",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4lcXD2",
        "hidden": 0
      },
      {
        "text": "Such realism. Does it fly? :octopusballoon:",
        "date": "1511165707",
        "username": "dr2",
        "userpicture": "/img/profile.jpg",
        "id": "4l3XD2",
        "hidden": 0
      },
      {
        "text": "Looks great. I would have stopped once I had a nice looking ladybug. That's a lot of different stuff. :)",
        "date": "1511163533",
        "username": "otaviogood",
        "userpicture": "/media/users/otaviogood/profile.jpeg",
        "id": "Xt3XD2",
        "hidden": 0
      },
      {
        "text": "Gorgeously exquisite rendering. Considering how long it'd normally take to render a scene like this, I'd say it's running pretty quickly. By the way, I like how you randomized the grass direction with the \"reflect\" vector.",
        "date": "1511159895",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "XlcSD2",
        "hidden": 0
      },
      {
        "text": "Perfect coloring btw!",
        "date": "1511159342",
        "username": "ingagard",
        "userpicture": "/img/profile.jpg",
        "id": "4tcSD2",
        "hidden": 0
      },
      {
        "text": "You already know what I think. Sad it only gives me 2fps.\nI think the for loops inside the for loops hurt the performance for me.",
        "date": "1511159321",
        "username": "ingagard",
        "userpicture": "/img/profile.jpg",
        "id": "XtcSD2",
        "hidden": 0
      },
      {
        "text": "Impressive as always ! Those mushrooms look so good !! ",
        "date": "1511154599",
        "username": "balkhan",
        "userpicture": "/img/profile.jpg",
        "id": "4lcXW2",
        "hidden": 0
      },
      {
        "text": "Wow dude, that is insanely good!",
        "date": "1511150192",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4t3XW2",
        "hidden": 0
      },
      {
        "text": "In the UK we confusingly call them [url=http://www.ladybird-survey.org/what_is.aspx]Ladybirds[/url]\nLovely rendering IQ, nice work. And I like the 'worldTo' transforms - very neat.",
        "date": "1511143118",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4lcSW2",
        "hidden": 0
      },
      {
        "text": "did the bug just move its hands?",
        "date": "1511141058",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "XlcSW2",
        "hidden": 0
      },
      {
        "text": "Fantastic job iq!",
        "date": "1511137909",
        "username": "DELTRON",
        "userpicture": "/img/profile.jpg",
        "id": "XtcSW2",
        "hidden": 0
      },
      {
        "text": "phew!!! supernatural! a photograph couldn't look as real ;-)",
        "date": "1511133462",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "Xl3SW2",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4tcGDr",
      "date": "1468612909",
      "viewed": 84226,
      "name": "Ray Marching: Part 6",
      "username": "jlfwong",
      "description": "Part 6 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/",
      "likes": 51,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    \n    float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(samplePoint, 1.2);\n    \n    float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);\n    float ballRadius = 0.3;\n    float balls = sphereSDF(samplePoint - vec3(ballOffset, 0.0, 0.0), ballRadius);\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(ballOffset, 0.0, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, 0.0, ballOffset), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, 0.0, ballOffset), ballRadius));\n    \n    \n    \n    float csgNut = differenceSDF(intersectSDF(cube, sphere),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n    \n    return unionSDF(balls, csgNut);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Fantastic!!!\nThis is best tutorial :)\nThanks for sharing your wisdom and experiences.",
        "date": "1509989436",
        "username": "smkgames",
        "userpicture": "/media/users/smkgames/profile.png",
        "id": "MtcSzj",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4tjGRh",
      "date": "1427737621",
      "viewed": 74317,
      "name": "Planet Shadertoy",
      "username": "reinder",
      "description": "A seamless space-to-surface flight. This is a tribute to all the great shaders on Shadertoy! Use chrome without angle (or a Mac) and run this shader on med, or high settings (line 4 or 5) to get the full shader and the detail I was aiming for.",
      "likes": 238,
      "published": 3,
      "flags": 9,
      "tags": [
        "terrain",
        "sea",
        "space",
        "ocean",
        "planet",
        "shadertoy",
        "vr",
        "asteroids"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Planet Shadertoy. Created by Reinder Nijhoff 2015\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4tjGRh\n//\n\n//#define HIGH_QUALITY\n//#define MED_QUALITY\n//#define LOW_QUALITY\n#define VERY_LOW_QUALITY\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI / 180.0);\nconst float MAX = 10000.0;\n\nconst float EARTH_RADIUS = 1000.;\nconst float EARTH_ATMOSPHERE = 5.;\nconst float EARTH_CLOUDS = 1.;\n\nconst float RING_INNER_RADIUS = 1500.;\nconst float RING_OUTER_RADIUS = 2300.;\nconst float RING_HEIGHT = 2.;\n\n#ifdef HIGH_QUALITY\n    const int   SEA_NUM_STEPS = 7;\n    const int\tTERRAIN_NUM_STEPS = 140;\n    const int   ASTEROID_NUM_STEPS = 11;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\n    const int   RING_VOXEL_STEPS = 25;\n    const float ASTEROID_MAX_DISTANCE = 1.1; \n\tconst int   FBM_STEPS = 4;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\n\n    #define DISPLAY_LLAMEL\n    #define DISPLAY_CLOUDS\n    #define DISPLAY_CLOUDS_DETAIL\n    #define DISPLAY_TERRAIN_DETAIL\n#endif\n\n#ifdef MED_QUALITY\n    const int   SEA_NUM_STEPS = 6;\n    const int\tTERRAIN_NUM_STEPS = 100;\n    const int   ASTEROID_NUM_STEPS = 10;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\n    const int   RING_VOXEL_STEPS = 24;\n    const float ASTEROID_MAX_DISTANCE = 1.; \n\tconst int   FBM_STEPS = 4;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\n    #define DISPLAY_CLOUDS\n    #define DISPLAY_TERRAIN_DETAIL\n    #define DISPLAY_CLOUDS_DETAIL\n#endif\n\n#ifdef LOW_QUALITY\n    const int   SEA_NUM_STEPS = 5;\n    const int\tTERRAIN_NUM_STEPS = 75;\n    const int   ASTEROID_NUM_STEPS = 9;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\n    const int   RING_VOXEL_STEPS = 20;\n    const float ASTEROID_MAX_DISTANCE = .85; \n\tconst int   FBM_STEPS = 3;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\n#endif\n\n#ifdef VERY_LOW_QUALITY\n    const int   SEA_NUM_STEPS = 4;\n    const int\tTERRAIN_NUM_STEPS = 60;\n    const int   ASTEROID_NUM_STEPS = 7;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\n    const int   RING_VOXEL_STEPS = 16;\n    const float ASTEROID_MAX_DISTANCE = .67; \n\tconst int   FBM_STEPS = 3;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\n\t#define HIDE_TERRAIN\n#endif\n\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\n\nfloat time;\n\n//-----------------------------------------------------\n// Noise functions\n//-----------------------------------------------------\n\nfloat hash( const in float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nfloat hash( const in vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31( const in float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\nvec3 hash33( const in vec3 p) {\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\n}\n\nfloat noise( const in  float p ) {    \n    float i = floor( p );\n    float f = fract( p );\t\n\tfloat u = f*f*(3.0-2.0*f);\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\n}\n\nfloat noise( const in  vec2 p ) {    \n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise( const in  vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat tri( const in vec2 p ) {\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n   \n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( in vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); \n    \n#ifndef LOW_QUALITY\n#ifndef VERY_LOW_QUALITY\n    p = m2*p*2.01;\n    f += 0.0625*noise( p );\n#endif\n#endif\n    return f/0.9375;\n}\n\nfloat fbm( const in vec3 p, const in float a, const in float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < FBM_STEPS; i++) {\n        float n = pow(noise(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n//-----------------------------------------------------\n// Lightning functions\n//-----------------------------------------------------\n\nfloat diffuse( const in vec3 n, const in vec3 l) { \n    return clamp(dot(n,l),0.,1.);\n}\n\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\n}\n\n//-----------------------------------------------------\n// Math functions\n//-----------------------------------------------------\n\nvec2 rotate(float angle, vec2 v) {\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\nfloat boolSub(float a,float b) { \n    return max(a,-b); \n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) return -MAX;\n\treturn -b + sqrt( d );\n}\n\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\n\td = sqrt( d );\n\treturn vec2( -b - d, -b + d );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// Wet stone by TDM\n// \n// https://www.shadertoy.com/view/ldSSzV\n//-----------------------------------------------------\n\nconst float ASTEROID_TRESHOLD \t= 0.001;\nconst float ASTEROID_EPSILON \t= 1e-6;\nconst float ASTEROID_DISPLACEMENT = 0.1;\nconst float ASTEROID_RADIUS = 0.13;\n\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\n\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \n    float d = sphere(p,ASTEROID_RADIUS);    \n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\n        float ii = float(i)+id.x;\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \n    }\n    return d;\n}\n\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( xyangle, ro.xy );\n    \n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( yzangle, ro.yz );\n}\n\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( -yzangle, ro.yz );\n\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( -xyangle, ro.xy );  \n}\n\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\n    asteroidTransForm( p, id );\n    \n    vec3 n;\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\n    n = normalize(n-asteroidMapDetailed(p, id));\n    \n    asteroidUnTransForm( n, id );\n    return n;\n}\n\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\n    asteroidTransForm( ori, id );\n    asteroidTransForm( dir, id );\n    \n    vec2 td = vec2(0,1);\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\n        td.y = asteroidMap(ori + dir * td.x, id);\n        td.x += td.y;\n    }\n    return td;\n}\n\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \n}\n\n//-----------------------------------------------------\n// Ring (by me ;))\n//-----------------------------------------------------\n\nconst float RING_DETAIL_DISTANCE = 40.;\nconst float RING_VOXEL_STEP_SIZE = .03;\n\nvec3 ringShadowColor( const in vec3 ro ) {\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\n        return vec3(0.);\n    }\n    return vec3(1.);\n}\n\nbool ringMap( const in vec3 ro ) {\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\n}\n\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \n// find startpoint \n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\n    \n    float d = min( max(d1,0.), max(d2,0.) );\n   \n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\n        return vec4( 0. );\n    } else {\n        vec3 ros = ro + rd*d;\n\n        // avoid precision problems..\n        vec2 mroxy = mod(ros.xy, vec2(10.));\n        vec2 roxy = ros.xy - mroxy;\n        ros.xy -= roxy;\n        ros /= RING_VOXEL_STEP_SIZE;\n        //ros.xy -= vec2(.013,.112)*time*.5;\n\n        vec3 pos = floor(ros);\n        vec3 ri = 1.0/rd;\n        vec3 rs = sign(rd);\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\n\n        float alpha = 0., dint;\n        vec3 offset = vec3(0), id, asteroidro;\n        vec2 asteroid = vec2(0);\n\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\n            if( ringMap(pos) ) {\n                id = hash33(pos);\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\n\n                if( dint > 0. ) {\n                    asteroidro = ros+rd*dint-(pos+offset);\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\n\n                    if( asteroid.y < .1 ) {\n                        alpha = 1.;\n                        break;\t    \n                    }\n                }\n\n            }\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n            dis += mm * rs * ri;\n            pos += mm * rs;\n        }\n\n        if( alpha > 0. ) {       \n            vec3 intersection = ros + rd*(asteroid.x+dint);\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\n\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\n\n            intersection *= RING_VOXEL_STEP_SIZE;\n            intersection.xy += roxy;\n          //  col *= ringShadowColor( intersection );\n\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\n        } else {\n            return vec4(0.);\n        }\n    }\n}\n\n//-----------------------------------------------------\n// Ring (by me ;))\n//-----------------------------------------------------\n\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\n    // intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. ) {\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n        } else {\n            return 0.;\n        }\n    } else {\n\t    return 0.;\n    }\n}\n\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    // intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. && d < maxd ) {\n        maxd = d;\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\n            \n            col *= ringShadowColor( intersection );\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\n\t\t\tcol *= SUN_COLOR;\n            return vec4( col, dens );\n        } else {\n            return vec4(0.);\n        }\n    } else {\n\t    return vec4(0.);\n    }\n}\n\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    vec4 far = renderRingFar( ro, rd, maxd );\n    float l = length( ro.xy );\n\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\n     \t\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\n        far.xyz *= detail;    \n    }\n    \n\t// are asteroids neaded ?\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\n        \n        vec4 near = renderRingNear( ro, rd );\n        far = mix( far, near, near.w );\n        maxd=0.;\n    }\n            \n    return far;\n}\n\n//-----------------------------------------------------\n// Stars (by me ;))\n//-----------------------------------------------------\n\nvec4 renderStars( const in vec3 rd ) {\n\tvec3 rds = rd;\n\tvec3 col = vec3(0);\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\n    \n    vec2 xy = vec2(rds.y * v, rds.x * v);\n    float s = noise(rds*134.);\n    \n    s += noise(rds*470.);\n    s = pow(s,19.0) * 0.00001;\n    if (s > 0.5) {\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \n        col += backStars;\n    }\n\treturn   vec4( col, 1 ); \n} \n\n//-----------------------------------------------------\n// Atmospheric Scattering by GLtracy\n// \n// https://www.shadertoy.com/view/lslXDr\n//-----------------------------------------------------\n\nconst float ATMOSPHERE_K_R = 0.166;\nconst float ATMOSPHERE_K_M = 0.0025;\nconst float ATMOSPHERE_E = 12.3;\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\nconst float ATMOSPHERE_G_M = -0.85;\n\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\n\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\n\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\n\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n    \n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\nfloat atmosphericPhaseReyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat atmosphericDensity( vec3 p ){\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\n}\n\nfloat atmosphericOptic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\n\t\tsum += atmosphericDensity( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\n\t\n\treturn sum;\n}\n\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n    float sumdensity = 0.;\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\n\t\tfloat dens = atmosphericDensity( v );\n  \n\t    float m = MAX;\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\n \t\tsumdensity += dens;\n        \n\t\tv += step;\n\t}\n\tsum *= len * ATMOSPHERE_SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\n}\n\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\n\t\tsum += atmosphericDensity( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\n\t\n\treturn sum;\n}\n\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\n\t    float m = MAX;\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\n\t\tv += step;\n\t}\n\tsum *= len * ATMOSPHERE_SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\n}\n\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \n    // inside or outside atmosphere?\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\n        \n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\n        if( d < e.y ) {\n            e.y = d;\n        }\n\t\td = e.y;\n\t    e.x = 0.;\n        \n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\n\t\t}\n    } else {\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\n        \n        if ( e.x > e.y ) {\n        \td = MAX;\n\t\t\treturn vec4(0.);\n\t\t}\n\t\td = e.y = min( e.y, f.x );\n    }\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\n}\n\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n    e.x = 0.;\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\n}\n\n//-----------------------------------------------------\n// Seascape by TDM\n// \n// https://www.shadertoy.com/view/Ms2SD1\n//-----------------------------------------------------\n\nconst int   SEA_ITER_GEOMETRY = 3;\nconst int   SEA_ITER_FRAGMENT = 5;\n\nconst float SEA_EPSILON\t= 1e-3;\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat       SEA_TIME;\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat seaOctave( in vec2 uv, const in float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat seaMap(const in vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat seaMapHigh(const in vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\n    \n    color += upc*SEA_WATER_COLOR * (att * 0.18);\n    color += sunc * vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\n    vec3 n;\n    n.y = seaMapHigh(p);    \n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = seaMap(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = seaMap(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = seaMap(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 seaTransform( in vec3 x ) {\n    x.yz = rotate( 0.8, x.yz );\n    return x;\n}\n\nvec3 seaUntransform( in vec3 x ) {\n    x.yz = rotate( -0.8, x.yz );\n    return x;\n}\n\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \n    vec3 p,\n    rom = seaTransform(ro),\n    rdm = seaTransform(rd);\n    \n    rom.y -= EARTH_RADIUS;\n    rom *= 1000.;\n    rom.xz += vec2(3.1,.2)*time;\n\n    SEA_TIME = time * SEA_SPEED;\n    \n    seaHeightMapTracing(rom,rdm,p);\n    float squareddist = dot(p - rom, p-rom );\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\n    \n    n = seaUntransform(n);\n    \n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\n}\n\n//-----------------------------------------------------\n// Terrain based on Elevated and Terrain Tubes by IQ\n//\n// https://www.shadertoy.com/view/MdX3Rr\n// https://www.shadertoy.com/view/4sjXzG\n//-----------------------------------------------------\n\n#ifndef HIDE_TERRAIN\n\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat terrainLow( vec2 p ) {\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n\treturn t*33.0;\n}\n\nfloat terrainMed( vec2 p ) {\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<6; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n            \n    return t*33.0;\n}\n\nfloat terrainHigh( vec2 p ) {\n    vec2 q = p;\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<7; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n    \n    t += t*0.015*fbm( q );\n\treturn t*33.0;\n}\n\nfloat terrainMap( const in vec3 pos ) {\n\treturn pos.y - terrainMed(pos.xz);  \n}\n\nfloat terrainMapH( const in vec3 pos ) {\n    float y = terrainHigh(pos.xz);\n    float h = pos.y - y;\n    return h;\n}\n\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\n    float t = tmin;\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\n        vec3 pos = ro + t*rd;\n        float res = terrainMap( pos );\n        if( res<(0.001*t) || t>tmax  ) break;\n        t += res*.9;\n\t}\n\n\treturn t;\n}\n\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\n\tvec2  eps = vec2(150.0,0.0);\n    float h1 = terrainMed( ro.xz );\n    float h2 = terrainLow( ro.xz );\n    \n    float d1 = 10.0;\n    float d2 = 80.0;\n    float d3 = 200.0;\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\n\n    return min(min(s1,s2),s3);\n}\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\n\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\n}\n\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\n\tfloat e = 0.005*t;\n    vec2  eps = vec2(e,0.0);\n    float h = terrainMed( pos.xz );\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\n}\n\nvec3 terrainTransform( in vec3 x ) {\n    x.zy = rotate( -.83, x.zy );\n    return x;\n}\n\nvec3 terrainUntransform( in vec3 x ) {\n    x.zy = rotate( .83, x.zy );\n    return x;\n}\n\n\nfloat llamelTime;\nconst float llamelScale = 5.;\n\nvec3 llamelPosition() {\n    llamelTime = time*2.5;\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\n    return vec3( pos.x, terrainMed( pos ), pos.y );\n}\n\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\n    float dif = diffuse( n, sunDirection );\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\n    float sha = terrainCalcShadow( pos, sunDirection );\n    float amb = clamp( n.y,0.0,1.0);\n        \n    vec3 lin  = vec3(0.0);\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\n    lin += 0.2*amb*upc;\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\n}\n\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n    vec3 nor = terrainCalcNormalHigh( pos, t );\n    vec3 sor = terrainCalcNormalMed( pos, t );\n        \n    float spec = 0.005;\n\n#ifdef DISPLAY_TERRAIN_DETAIL\n    float no = noise(5.*fbm(1.11*pos.xz));\n#else\n    const float no = 0.;\n#endif\n    float r = .5+.5*fbm(.95*pos.xz);\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\n    col *= .88+.12*no;\n        \n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\n    float sf = fwidth(s) * 1.5;\n    s = smoothstep(0.84-sf, 0.84+sf, s );\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\n\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\n\n#ifdef DISPLAY_LLAMEL\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\n#endif\n    \n    return col;\n}\n\nvec3 terrainTransformRo( const in vec3 ro ) {\n    vec3 rom = terrainTransform(ro);\n    rom.y -= EARTH_RADIUS - 100.;\n    rom.xz *= 5.;\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\n    return rom;\n}\n\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \n    vec3 p,\n    rom = terrainTransformRo(ro),\n    rdm = terrainTransform(rd);\n        \n    float tmin = 10.0;\n    float tmax = 3200.0;\n    \n    float res = terrainIntersect( rom, rdm, tmin, tmax );\n    \n    if( res > tmax ) {\n        res = -1.;\n    } else {\n        vec3 pos =  rom+rdm*res;\n        n = terrainCalcNormalMed( pos, res );\n        n = terrainUntransform( n );\n        \n        intersection = ro+rd*res/100.;\n    }\n    return vec4(res, rom+rdm*res);\n}\n\n#endif\n\n//-----------------------------------------------------\n// LLamels by Eiffie\n//\n// https://www.shadertoy.com/view/ltsGz4\n//-----------------------------------------------------\n#ifdef DISPLAY_LLAMEL\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\n}\n\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\n\tu=p-j0;q=j1-j0;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\n\tu=p-j1;q=j2-j1;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\n\tu=p-j2;q=j3-j2;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\n}\n\nfloat llamelMap(in vec3 p) {\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\n\tp.y += 0.25*llamelScale;\n    p.xz -= 0.5*llamelScale;\n    p.xz = vec2(-p.z, p.x);\n    vec3 pori = p;\n        \n    p /= llamelScale;\n    \n\tvec2 c=floor(p.xz);\n\tp.xz=fract(p.xz)-vec2(0.5);\n    p.y -= p.x*.04*llamelScale;\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\n\n    float b=0.83-abs(p.z);\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\n\tp.y-=0.03;\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\n\ta=max(abs(p.z),p.y)+0.05;\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\n}\n\nvec3 llamelGetNormal( in vec3 ro ) {\n    vec2 e = vec2(1.0,-1.0)*0.001;\n\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\n}\n\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n    ro -= llamelPosition();\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\n\tfor(int i=0;i<36;i++){\n\t\tt+=d=llamelMap(ro+rd*t);\n\t\tif(d<dm){dm=d;tm=t;}\n\t\tif(t>1000.0 || d<0.00001)break;\n\t}\n\tdm=max(0.0,dm);\n    if( dm < .02 ) {\n        vec3 col = vec3(0.45,.30,0.15)*.2;\n        vec3 pos = ro + rd*tm;\n        vec3 nor = llamelGetNormal( pos );\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\n    }\n    \n    return vec4(0.);\n}\n#endif\n\n//-----------------------------------------------------\n// Clouds (by me ;))\n//-----------------------------------------------------\n\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\n\tvec3 intersection = ro+rd*d;\n    vec3 cint = intersection*0.009;\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\n\n    cint.xy = rotate( rot, cint.xy );\n\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\n\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\n\n#ifdef DISPLAY_CLOUDS_DETAIL\n    if( d < 200. ) {\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\n    }\n#endif\n\n    shadow = clamp(1.-clouds, 0., 1.);\n\n    clouds = clamp(clouds, 0., 1.);\n    clouds *= clouds;\n    clouds *= smoothstep(0.,0.4,d);\n\n    vec3 clbasecolor = vec3(1.);\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\n    clcol += .3*clbasecolor*sunColor;\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \n    \n    return vec4( clcol, clouds );\n}\n\n//-----------------------------------------------------\n// Planet (by me ;))\n//-----------------------------------------------------\n\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\n\n    vec3 intersection = ro + rd*d;\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\n    vec4 res;\n\n#ifndef HIDE_TERRAIN\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\n#endif\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \n    float mixDetailColor = 0.;\n        \n\tif( d < 0. || d > maxd) {\n#ifndef HIDE_TERRAIN\n        if( renderTerrainDetail ) {\n       \t\tintersection = ro;\n            n = normalize( ro );\n        } else { \t       \n\t        return vec4(0);\n        }\n#else \n      \treturn vec4(0.);\n#endif\n\t}\n    if( d > 0. ) {\n\t    maxd = d;\n    }\n    float att = 0.;\n    \n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\n    \n    float dm = MAX, e = 0.;\n    vec3 col, detailCol, nDetail;\n    \n    // normal and intersection \n#ifndef HIDE_TERRAIN\n    if( renderTerrainDetail ) {   \n        res = renderTerrain( ro, rd, intersection, nDetail );\n        if( res.x < 0. && d < 0. ) {\n\t        return vec4(0);\n        }\n        if( res.x >= 0. ) {\n            maxd = pow(res.x/4000.,4.)*50.;\n            e = -10.;\n        }\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\n    } else \n#endif        \n    if( renderSeaDetail ) {    \n        float attsea, mf = smoothstep(.5,1.,d);\n\n        renderSea( ro, rd, nDetail, attsea );\n\n        n = normalize(mix( nDetail, n, mf ));\n        att = mix( attsea, att, mf );\n    } else {\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\n#ifndef HIDE_TERRAIN\n        if( d < 1500. ) {\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\n        }\n#endif  \n    }\n    \n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \n                 \n    // color  \n#ifndef HIDE_TERRAIN\n    if(renderTerrainDetail ) {\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\n\t\td = 0.;\n    }   \n#endif\n     \n    if( mixDetailColor < 1. ) {\n        if( e < .45 ) {\n            // sea\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \n        } else {\n            // planet (land) far\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\n\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\n            vec3 landColor2 = RING_COLOR_1 * land2;\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\n\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\n#ifdef HIGH_QUALITY\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\n#endif\n        }\n    }\n    \n    if( mixDetailColor > 0. ) {\n        col = mix( col, detailCol, mixDetailColor );\n    }\n        \n#ifdef DISPLAY_LLAMEL\n    if(renderTerrainDetail ) {\n        vec3 rom = terrainTransformRo(ro),\n        rdm = terrainTransform(rd);\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\n        if( d > 0. ) {\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\n            col = mix(col, llamel.rgb, llamel.a);\n        }\n    }\n#endif\n    \n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\n    if( d > 0. ) { \n        float shadow;\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\n        col *= shadow; \n        col = mix( col, clouds.rgb, clouds.w );\n    }\n    \n    float m = MAX;\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\n\n \treturn vec4( col, 1. ); \n}\n\n//-----------------------------------------------------\n// Lens flare by musk\n//\n// https://www.shadertoy.com/view/4sX3Rs\n//-----------------------------------------------------\n\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\n\tc = c*.5 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\n//-----------------------------------------------------\n// cameraPath\n//-----------------------------------------------------\n\nvec3 pro, pta, pup;\nfloat dro, dta, dup;\n\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\n    if( t >= prevt && t <= prevt+duration ) {\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\n    }\n    prev = dest;\n    prevt += duration;\n}\n\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\n#ifndef HIDE_TERRAIN\n    time = t = mod( t, 92. );\n#else\n    time = t = mod( t, 66. );\n#endif\n    dro = dta = dup = 0.;\n\n    pro = ro = vec3(900. ,7000. ,1500. );\n    pta = ta = vec3(    0. ,    0. ,   0. );\n    pup = up = vec3(    0. ,    0.4,   1. ); \n   \n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \n \n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\n\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\n    \n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\n    \n    camint( ro, t, 7.,roe, pro, dro );\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\n    camint( up, t, 6., upe, pup, dup );\n        \n    camint( ro, t, 17.,roe, pro, dro );\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\n    \n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \n#ifndef HIDE_TERRAIN    \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\n    \n    camint( ro, t, 7., roe, pro, dro );\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\n    camint( up, t, 2., upe, pup, dup );\n        \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\n    camint( ro, t, 17.,roe, pro, dro );\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\n        \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\n    camint( ro, t, 4.,roe, pro, dro );\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\n#endif    \n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \n    \n    up = normalize( up );\n}\n\n//-----------------------------------------------------\n// mainImage\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col;\n    \n// black bands\n    vec2 bandy = vec2(.1,.9);\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\n        col = vec3(0.);\n    } else {\n        // camera\n        vec3 ro, ta, up;\n        cameraPath( iTime*.7, ro, ta, up );\n\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,up) );\n        vec3 vv = normalize( cross(uu,ww));\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n\n        float maxd = MAX;  \n        col = renderStars( rd ).xyz;\n\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \n        if( planet.w > 0. ) col.xyz = planet.xyz;\n\n        float atmosphered = maxd;\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \n\n        vec4 ring = renderRing( ro, rd, maxd );\n        if( ring.w > 0. && atmosphered < maxd ) {\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \n        }\n        col = col * (1.-ring.w ) + ring.xyz;\n\n#ifdef DISPLAY_CLOUDS\n        float lro = length(ro);\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \n\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\n                // clouds\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\n                if( d < maxd ) {\n                    float shadow;\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\n                }\n            }\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\n        }\n#endif \n\n        // post processing\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        col *= vec3(1.,0.99,0.95);   \n        col = clamp(1.06*col-0.03, 0., 1.);      \n\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\n\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \n    }\n    fragColor = vec4( col ,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    float maxd = MAX;  \n    time = iTime * .7;\n    \n    rd = rd.xzy;\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\n    \n    vec3 col = renderStars( rd ).xyz;\n\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \n    if( planet.w > 0. ) col.xyz = planet.xyz;\n\n    float atmosphered = maxd;\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \n\n    vec4 ring = renderRing( ro, rd, maxd );\n    col = col * (1.-ring.w ) + ring.xyz;\n    \n    // post processing\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col *= vec3(1.,0.99,0.95);   \n    col = clamp(1.06*col-0.03, 0., 1.);      \n    fragColor = vec4( col ,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [
          {
            "id": "XsfGRr",
            "channel": 0
          }
        ],
        "code": "\n//----------------------------------------------------------------------\n// Wind function by Dave Hoskins https://www.shadertoy.com/view/4ssXW2\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nvec2 Hash( vec2 p) {\n    return vec2( hash(p.x), hash(p.y) );\n}\n\n//--------------------------------------------------------------------------\nvec2 Noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n//--------------------------------------------------------------------------\nvec2 FBM( vec2 p ) {\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 2.32;\n\tf += 0.2500  * Noise(p); p = p * 2.23;\n\tf += 0.1250  * Noise(p); p = p * 2.31;\n    f += 0.0625  * Noise(p); p = p * 2.28;\n    f += 0.03125 * Noise(p);\n    return f;\n}\n\n//--------------------------------------------------------------------------\nvec2 Wind(float n) {\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\n    \n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\n    \n\treturn noise;\n}\n\n//----------------------------------------------------------------------\n\n\n\nvec2 mainSound(float time) {\n    //16 - 38\n //   time -= 7.5;\n    time *= .7;\n    float vol = 1.-smoothstep(6.,8.5, time);\n    vol += smoothstep(16.5,20., time);\n    vol *= 1.-smoothstep(23.5,25.5, time);\n    vol += smoothstep(47.5,51.5, time);\n    vol = vol*.8+.2;\n    \n\treturn Wind(time*.05) * vol;\n}",
        "name": "Sound",
        "description": "",
        "type": "sound"
      }
    ],
    "comments": [
      {
        "text": "OMG ",
        "date": "1556015168",
        "username": "xavierseb",
        "userpicture": "/img/profile.jpg",
        "id": "MtBcRm",
        "hidden": 0
      },
      {
        "text": "Just code :D ",
        "date": "1541712209",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "lsjfRh",
        "hidden": 0
      },
      {
        "text": "... Is this real life?",
        "date": "1541689448",
        "username": "Lanlost",
        "userpicture": "/img/profile.jpg",
        "id": "4s2fz1",
        "hidden": 0
      },
      {
        "text": "The ocean has tons of places where the ray never seems to hit it and there's just a black dot. :(",
        "date": "1541371198",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "XsBfRh",
        "hidden": 0
      },
      {
        "text": "Featured in this video :) ! [video]http://youtu.be/7BB8TkY4Aeg[/video]",
        "date": "1532120557",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "Md2yDV",
        "hidden": 0
      },
      {
        "text": "OMG AWESOME PLZ do a youtube tutorial, I would subscribe for that!",
        "date": "1531069226",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "XsScWy",
        "hidden": 0
      },
      {
        "text": "my daughter really loves space and she really likes this :)!!!!!!!;):)",
        "date": "1519556400",
        "username": "Beatrix",
        "userpicture": "/img/profile.jpg",
        "id": "MssczH",
        "hidden": 0
      },
      {
        "text": "This is nuts beyond the capacity of minds to understand",
        "date": "1470452665",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "4stGD4",
        "hidden": 0
      },
      {
        "text": "You should work for NASA :)",
        "date": "1470265399",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "XdcGWN",
        "hidden": 0
      },
      {
        "text": "Really cool! I tried higher settings however when I compiled web-gl all about froze! I have a gtx 980 so probably not your issue though!",
        "date": "1460682359",
        "username": "cubby208",
        "userpicture": "/img/profile.jpg",
        "id": "ltXXWs",
        "hidden": 0
      },
      {
        "text": "Amazing!",
        "date": "1459639135",
        "username": "ciberxtrem",
        "userpicture": "/media/users/ciberxtrem/profile.jpeg",
        "id": "4tXXDj",
        "hidden": 0
      },
      {
        "text": "oh my god",
        "date": "1459488709",
        "username": "tehsauce",
        "userpicture": "/media/users/tehsauce/profile.jpeg",
        "id": "MtlSWB",
        "hidden": 0
      },
      {
        "text": "Awesome work, one of my favorites for sure",
        "date": "1458928504",
        "username": "KylBlz",
        "userpicture": "/media/users/KylBlz/profile.jpeg",
        "id": "MlsXzl",
        "hidden": 0
      },
      {
        "text": "This feels like an opening to a movie. Very well done.",
        "date": "1458861587",
        "username": "zel",
        "userpicture": "/img/profile.jpg",
        "id": "4tsSzs",
        "hidden": 0
      },
      {
        "text": "Very noice! It's very dreamy.",
        "date": "1458854782",
        "username": "Klems",
        "userpicture": "/media/users/Klems/profile.png",
        "id": "XllSzs",
        "hidden": 0
      },
      {
        "text": "Wow!",
        "date": "1458720782",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "llfXzs",
        "hidden": 0
      },
      {
        "text": "Fantastic! And runs even on my tiny eee-box :-)\n",
        "date": "1447875665",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "MlfGzl",
        "hidden": 0
      },
      {
        "text": "My Tegra K1 laptop fails to even load this. When loading the page, the screen freezes for 5-10 sec and then WebGL dies. Will have to try this on a better GPU. :D",
        "date": "1430655076",
        "username": "tajjada",
        "userpicture": "/img/profile.jpg",
        "id": "4s2Sz1",
        "hidden": 0
      },
      {
        "text": "I have also rendered a video of this shader:\n[video]https://www.youtube.com/watch?v=VVrPhvfAXko[/video]",
        "date": "1427907495",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "XssXDX",
        "hidden": 0
      },
      {
        "text": "Haha, I just saw the deer, welldone!",
        "date": "1427757356",
        "username": "movAX13h",
        "userpicture": "/media/users/movAX13h/profile.png",
        "id": "XdlSWX",
        "hidden": 0
      },
      {
        "text": "Very smooth, I really like the closeup of the rings.\n\nIn the sound code...\n1.-smoothstep(23.5,25.5, time);\n...can also be,\nsmoothstep(25.5,23.5, time);\n.. which I use quite a lot for fading in and out of signals.\n:)\n\n",
        "date": "1427740637",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MsfSDf",
        "hidden": 0
      },
      {
        "text": "SOOO much work! Thank you.",
        "date": "1427740407",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "lsfSDf",
        "hidden": 0
      },
      {
        "text": "wow... nice movie :)",
        "date": "1427739214",
        "username": "jimmikaelkael",
        "userpicture": "/img/profile.jpg",
        "id": "ldfSDf",
        "hidden": 0
      },
      {
        "text": "Seamlessly fly from space to the surface of Planet Shadertoy. This was the shader I intended to make for the 'space compo' @ NVScene 2015. \n\nPlease use [i]chrome without angle[/i] (or a Mac) and run this shader on [i]med[/i], or [i]high[/i] settings (line 4 or 5) to get the full shader (including terrain) and see the level of detail I was aiming for.\n\nThis shader is a tribute to all the great shaders on Shadertoy. It uses code from the following shaders:\n\n[url=https://www.shadertoy.com/view/ldSSzV]Wet stone[/url] by TDM\n[url=https://www.shadertoy.com/view/lslXDr]Atmospheric Scattering[/url] by GLtracy\n[url=https://www.shadertoy.com/view/Ms2SD1]Seascape[/url] by TDM\n[url=https://www.shadertoy.com/view/MdX3Rr]Elevated[/url] and [url=https://www.shadertoy.com/view/4sjXzG]Terrain Tubes[/url] by IQ\n[url=https://www.shadertoy.com/view/ltsGz4]LLamels[/url] by Eiffie\n[url=https://www.shadertoy.com/view/4sX3Rs]Lens flare[/url] by Musk",
        "date": "1427737296",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "MsXSDf",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "4ttSWf",
      "date": "1482384986",
      "viewed": 95882,
      "name": "Rainforest",
      "username": "iq",
      "description": "Another terrain, with cheap trees made of spheres with some noise. Not complete really, but I must move on. Analytic normals for terrain, tree envelope intersection, analytical normals for clouds, and other tricks involved. Art composed to camera as usual",
      "likes": 472,
      "published": 3,
      "flags": 32,
      "tags": [
        "procedural",
        "3d",
        "raymarching",
        "reprojection"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Normals are analytical (true derivatives) for the terrain and for the clouds, that \n// includes the noise, the fbm and the smoothsteps involved chain derivatives correctly.\n//\n// See here for more info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n// Lighting and art composed for this shot/camera\n//\n// The trees are really cheap (ellipsoids with noise), but they kind of do the job in\n// distance and low image resolutions.\n//\n// I used some cheap reprojection technique to smooth out the render, although it creates\n// halows and blurs the image way too much (I don't the time now to do the tricks used in \n// TAA). Enable the STATIC_CAMERA define to see a sharper image.\n//\n// Lastly, it runs very slow, so I had to make a youtube capture, sorry for that!\n// \n// https://www.youtube.com/watch?v=VqYROPZrDeU\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n    //vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n    \n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n         \n    fragColor = vec4( col, 1.0 );\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Normals are analytical (true derivatives) for the terrain and for the clouds, that \n// includes the noise, the fbm and the smoothsteps involved chain derivatives correctly.\n//\n// See here for more info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n// Lighting and art composed for this shot/camera\n//\n// The trees are really cheap (ellipsoids with noise), but they kind of do the job in\n// distance and low image resolutions.\n//\n// I used some cheap reprojection technique to smooth out the render, although it creates\n// halows and blurs the image way too much (I don't have the time now to do the tricks\n// used in TAA). Enable the STATIC_CAMERA define to see a sharper image.\n//\n// Lastly, it runs very slow in WebGL (but runs 2x faster in native GL), so I had to make\n// a youtube capture, sorry for that!\n// \n// https://www.youtube.com/watch?v=VqYROPZrDeU\n\n\n//#define STATIC_CAMERA\n#define LOWQUALITY\n\n\n\n//==========================================================================================\n// general utilities\n//==========================================================================================\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    return (length( p/r.xyx ) - 1.0) * r.x;\n}\n\n// return smoothstep and its derivative\nvec2 smoothstepd( float a, float b, float x)\n{\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//==========================================================================================\n// hashes\n//==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n#if 0\n    p *= 0.3183099;\n    float kx0 = 50.0*fract( p.x );\n    float kx1 = 50.0*fract( p.x+0.3183099 );\n    float ky0 = 50.0*fract( p.y );\n    float ky1 = 50.0*fract( p.y+0.3183099 );\n\n    float a = fract( kx0*ky0*(kx0+ky0) );\n    float b = fract( kx1*ky0*(kx1+ky0) );\n    float c = fract( kx0*ky1*(kx0+ky1) );\n    float d = fract( kx1*ky1*(kx1+ky1) );\n#else\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n#endif\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yz;       // accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\treturn vec3( a, d );\n}\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\n//==========================================================================================\n\n#define ZERO (min(iFrame,0))\n\n\n//==========================================================================================\n// specifics to the actual painting\n//==========================================================================================\n\n\n//------------------------------------------------------------------------------------------\n// global\n//------------------------------------------------------------------------------------------\n\nconst vec3  kSunDir = vec3(-0.624695,0.468521,-0.624695);\nconst float kMaxTreeHeight = 2.0;\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 fogCol = vec3(0.4,0.6,1.15);\n    return mix( col, fogCol, 1.0-exp(-0.000001*t*t) );\n}\n\n\n//------------------------------------------------------------------------------------------\n// clouds\n//------------------------------------------------------------------------------------------\n\nvec4 cloudsMap( in vec3 pos )\n{\n    vec4 n = fbmd_8(pos*0.003*vec3(0.6,1.0,0.6)-vec3(0.1,1.9,2.8));\n    vec2 h  =  smoothstepd( -60.0, 10.0, pos.y ) -  smoothstepd( 10.0, 500.0, pos.y );\n    h.x = 2.0*n.x + h.x - 1.3;\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0)  );\n}\n\nfloat cloudsShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n\tfloat sum = 0.0;\n\n    // bounding volume!!\n    float tl = ( -10.0-ro.y)/rd.y;\n    float th = ( 300.0-ro.y)/rd.y;\n    if( tl>0.0 ) tmin = max( tmin, tl );\n    if( th>0.0 ) tmax = min( tmax, th );\n\n\tfloat t = tmin;\n\tfor(int i=ZERO; i<64; i++)\n    { \n        vec3  pos = ro + t*rd; \n        vec4  denGra = cloudsMap( pos ); \n        float den = denGra.x;\n        float dt = max(0.2,0.02*t);\n        if( den>0.001 ) \n        { \n            float alp = clamp(den*0.3*min(dt,tmax-t-dt),0.0,1.0);\n            sum = sum + alp*(1.0-sum);\n        }\n        else \n        {\n            dt *= 1.0 + 4.0*abs(den);\n        }\n        t += dt;\n        if( sum>0.995 || t>tmax ) break;\n    }\n\n    return clamp( 1.0-sum, 0.0, 1.0 );\n}\n\nvec4 renderClouds( in vec3 ro, in vec3 rd, float tmin, float tmax, inout float resT )\n{\n    vec4 sum = vec4(0.0);\n\n    // bounding volume!!\n    float tl = ( -10.0-ro.y)/rd.y;\n    float th = ( 300.0-ro.y)/rd.y;\n    if( tl>0.0 )   tmin = max( tmin, tl ); else return sum;\n  /*if( th>0.0 )*/ tmax = min( tmax, th );\n\n\n    float t = tmin;\n    float lastT = t;\n    float thickness = 0.0;\n    #ifdef LOWQUALITY\n    for(int i=ZERO; i<128; i++)\n    #else\n    for(int i=ZERO; i<300; i++)\n    #endif\n    { \n        vec3  pos = ro + t*rd; \n        vec4  denGra = cloudsMap( pos ); \n        float den = denGra.x;\n        #ifdef LOWQUALITY\n        float dt = max(0.1,0.011*t);\n        #else\n        float dt = max(0.05,0.005*t);\n        #endif\n        if( den>0.001 ) \n        { \n            #ifdef LOWQUALITY\n            float sha = 1.0;\n            #else\n            float sha = clamp( 1.0 - max(0.0,cloudsMap( pos + kSunDir*5.0 ).x), 0.0, 1.0 );\n            //sha *= clamp( pos.y - terrainMap( (pos + kSunDir*5.0).xz ).x, 0.0, 1.0 );\n            #endif\n            vec3 nor = -normalize(denGra.yzw);\n            float dif = clamp( dot(nor,kSunDir), 0.0, 1.0 )*sha; \n            float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 )*sha;\n            // lighting\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*nor.y);\n                 lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*nor.y);\n                 lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \n            \t lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\n            // color\n            vec3 col = vec3(0.8,0.77,0.72)*clamp(1.0-4.0*den,0.0,1.0);\n\n            col *= lin;\n\n            col = fog( col, t );\n\n            // front to back blending    \n            float alp = clamp(den*0.25*min(dt,tmax-t-dt),0.0,1.0);\n            col.rgb *= alp;\n            sum = sum + vec4(col,alp)*(1.0-sum.a);\n\n            thickness += dt*den;\n            lastT = t;            \n        }\n        else \n        {\n#ifdef LOWQUALITY\n            dt *= 1.0 + 4.0*abs(den);\n#else\n            dt *= 0.8 + 2.0*abs(den);\n#endif\n        }\n        t += dt;\n        if( sum.a>0.995 || t>tmax ) break;\n    }\n\n    resT = mix( resT, lastT, sum.w );\n    \n    if( thickness>0.0)\n\t\tsum.xyz += vec3(1.00,0.60,0.40)*0.2*pow(clamp(dot(kSunDir,rd),0.0,1.0),32.0)*exp(-0.3*thickness)*clamp(thickness*4.0,0.0,1.0);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n//------------------------------------------------------------------------------------------\n// terrain\n//------------------------------------------------------------------------------------------\n\nvec2 terrainMap( in vec2 p )\n{\n    const float sca = 0.0010;\n    const float amp = 300.0;\n\n    p *= sca;\n    float e = fbm_9( p + vec2(1.0,-2.0) );\n    float a = 1.0-smoothstep( 0.12, 0.13, abs(e+0.12) ); // flag high-slope areas (-0.25, 0.0)\n    e = e + 0.15*smoothstep( -0.08, -0.01, e );\n    e *= amp;\n    return vec2(e,a);\n}\n\nvec4 terrainMapD( in vec2 p )\n{\n\tconst float sca = 0.0010;\n    const float amp = 300.0;\n    p *= sca;\n    vec3 e = fbmd_9( p + vec2(1.0,-2.0) );\n    vec2 c = smoothstepd( -0.08, -0.01, e.x );\n\te.x = e.x + 0.15*c.x;\n\te.yz = e.yz + 0.15*c.y*e.yz;    \n    e.x *= amp;\n    e.yz *= amp*sca;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\nvec3 terrainNormal( in vec2 pos )\n{\n#if 1\n    return terrainMapD(pos).yzw;\n#else    \n    vec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(pos-e.xy).x - terrainMap(pos+e.xy).x,\n                           2.0*e.x,\n                           terrainMap(pos-e.yx).x - terrainMap(pos+e.yx).x ) );\n#endif    \n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint )\n{\n    float res = 1.0;\n    float t = mint;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei/t );\n        if( res<0.0001 ) break;\n        t += clamp( hei, 1.0+t*0.1, 50.0 );\n    }\n#else\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei/t );\n        if( res<0.0001 ) break;\n        t += clamp( hei, 0.5+t*0.05, 25.0 );\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 raymarchTerrain( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    //float tt = (150.0-ro.y)/rd.y; if( tt>0.0 ) tmax = min( tmax, tt );\n    \n    float dis, th;\n    float t2 = -1.0;\n    float t = tmin; \n    float ot = t;\n    float odis = 0.0;\n    float odis2 = 0.0;\n    for( int i=ZERO; i<400; i++ )\n    {\n        th = 0.001*t;\n\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = env.x;\n\n        // tree envelope\n        float dis2 = pos.y - (hei+kMaxTreeHeight*1.1);\n        if( dis2<th ) \n        {\n            if( t2<0.0 )\n            {\n                t2 = ot + (th-odis2)*(t-ot)/(dis2-odis2); // linear interpolation for better accuracy\n            }\n        }\n        odis2 = dis2;\n        \n        // terrain\n        dis = pos.y - hei;\n        if( dis<th ) break;\n        \n        ot = t;\n        odis = dis;\n        t += dis*0.8*(1.0-0.75*env.y); // slow down in step areas\n        if( t>tmax ) break;\n    }\n\n    if( t>tmax ) t = -1.0;\n    else t = ot + (th-odis)*(t-ot)/(dis-odis); // linear interpolation for better accuracy\n    return vec2(t,t2);\n}\n\nvec4 renderTerrain( in vec3 ro, in vec3 rd, in vec2 tmima, out float teShadow, out vec2 teDistance, inout float resT )\n{\n    vec4 res = vec4(0.0);\n    teShadow = 0.0;\n    teDistance = vec2(0.0);\n    \n    vec2 t = raymarchTerrain( ro, rd, tmima.x, tmima.y );\n    if( t.x>0.0 )\n    {\n        vec3 pos = ro + t.x*rd;\n        vec3 nor = terrainNormal( pos.xz );\n\n        // bump map\n        nor = normalize( nor + 0.8*(1.0-abs(nor.y))*0.8*fbmd_8( pos*0.3*vec3(1.0,0.2,1.0) ).yzw );\n        \n        vec3 col = vec3(0.18,0.11,0.10)*.75;\n        col = 1.0*mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7,0.9,nor.y) );      \n        \n\t\t//col *= 1.0 + 2.0*fbm( pos*0.2*vec3(1.0,4.0,1.0) );\n        \n        float sha = 0.0;\n        float dif =  clamp( dot( nor, kSunDir), 0.0, 1.0 ); \n        if( dif>0.0001 ) \n        {\n            sha = terrainShadow( pos+nor*0.01, kSunDir, 0.01 );\n            //if( sha>0.0001 ) sha *= cloudsShadow( pos+nor*0.01, kSunDir, 0.01, 1000.0 );\n            dif *= sha;\n        }\n        vec3  ref = reflect(rd,nor);\n    \tfloat bac = clamp( dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 )*clamp( (pos.y+100.0)/100.0, 0.0,1.0);\n        float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n        vec3  lin  = 1.0*0.2*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.7,0.9,1.0),dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\n              lin += 1.0*5.0*vec3(1.0,0.9,0.8)*dif;        \n              lin += 1.0*0.35*vec3(1.0)*bac;\n        \n\t    col *= lin;\n\n        col = fog(col,t.x);\n\n        teShadow = sha;\n        teDistance = t;\n        res = vec4( col, 1.0 );\n        resT = t.x;\n    }\n    \n    return res;\n}\n\n//------------------------------------------------------------------------------------------\n// trees\n//------------------------------------------------------------------------------------------\n\nfloat treesMap( in vec3 p, in float rt, out float oHei, out float oMat, out float oDis )\n{\n    oHei = 1.0;\n    oDis = 0.1;\n    oMat = 0.0;\n        \n    float base = terrainMap(p.xz).x; \n    \n    float d = 10.0;\n    vec2 n = floor( p.xz );\n    vec2 f = fract( p.xz );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash2( n + g );\n        vec2  v = hash2( n +g + vec2(13.1,71.7) );\n        vec2  r = g - f + o;\n\n        float height = kMaxTreeHeight * (0.4+0.8*v.x);\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\n        vec3  q = vec3(r.x,p.y-base-height*0.5,r.y);\n        float k = sdEllipsoidY( q, vec2(width,0.5*height) );\n\n        if( k<d )\n        { \n            d = k;\n            //oMat = hash1(o); //fract(o.x*7.0 + o.y*15.0);\n            oMat = o.x*7.0 + o.y*15.0;\n            oHei = (p.y - base)/height;\n            oHei *= 0.5 + 0.5*length(q) / width;\n        }\n    }\n    oMat = fract(oMat);\n\n    // distort ellipsoids to make them look like trees (works only in the distance really)\n    #ifdef LOWQUALITY\n    if( rt<350.0 )\n    #else\n    if( rt<500.0 )\n    #endif\n    {\n        float s = fbm_4( p*3.0 );\n        s = s*s;\n        oDis = s;\n        #ifdef LOWQUALITY\n        float att = 1.0-smoothstep(150.0,350.0,rt);\n        #else\n        float att = 1.0-smoothstep(200.0,500.0,rt);\n        #endif\n        d += 2.0*s*att*att;\n    }\n    \n    return d;\n}\n\nfloat treesShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.02;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<50; i++ )\n    {\n        float kk1, kk2, kk3;\n        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h/t );\n        t += h;\n        if( res<0.001 || t>20.0 ) break;\n    }\n#else\n    for( int i=ZERO; i<150; i++ )\n    {\n        float kk1, kk2, kk3;\n        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h/t );\n        t += h;\n        if( res<0.001 || t>120.0 ) break;\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 treesNormal( in vec3 pos, in float t )\n{\n    float kk1, kk2, kk3;\n#if 0    \n    const float eps = 0.005;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*treesMap( pos + e.xyy, t, kk1, kk2, kk3 ) + \n                      e.yyx*treesMap( pos + e.yyx, t, kk1, kk2, kk3 ) + \n                      e.yxy*treesMap( pos + e.yxy, t, kk1, kk2, kk3 ) + \n                      e.xxx*treesMap( pos + e.xxx, t, kk1, kk2, kk3 ) );            \n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*treesMap(pos+0.005*e, t, kk1, kk2, kk3);\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 treesShade( in vec3 pos, in vec3 tnor, in vec3 enor, in float hei, in float mid, in float dis, in float rt, in vec3 rd, float terrainShadow )\n{\n    vec3 nor = normalize( tnor + 2.5*enor );\n\n    // --- lighting ---\n    float sha = terrainShadow;\n    vec3  ref = reflect(rd,nor);\n    float occ = clamp(hei,0.0,1.0) * pow(1.0-2.0*dis,3.0);\n    float dif = clamp( 0.1 + 0.9*dot( nor, kSunDir), 0.0, 1.0 ); \n    if( dif>0.0001 && terrainShadow>0.001 )\n    {\n        //sha *= clamp( 10.0*dot(tnor,kSunDir), 0.0, 1.0 ) * pow(clamp(1.0-13.0*dis,0.0,1.0),4.0);//treesShadow( pos+nor*0.1, kSunDir ); // only cast in non-terrain-occluded areas\n        sha *= treesShadow( pos+nor*0.1, kSunDir ); // only cast in non-terrain-occluded areas\n    }\n    float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n    float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n    float spe = pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*dif*sha*(0.2+0.8*pow(fre,5.0))*occ;\n\n    // --- lights ---\n    vec3 lin  = 1.0*0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\n\t\t #ifdef SOFTTREES\n         lin += 1.0*15.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\n\t\t #else\n         lin += 1.0*10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\n\t\t #endif\n         lin += 1.0*0.5*vec3(0.9,1.0,0.8)*pow(fre,3.0)*occ;\n         lin += 1.0*0.05*vec3(0.15,0.4,0.1)*occ;\n   \n    // --- material ---\n    float brownAreas = fbm_4( pos.zx*0.03 );\n    vec3 col = vec3(0.08,0.09,0.02);\n    \t col = mix( col, vec3(0.09,0.07,0.02), smoothstep(0.2,1.0,mid) );\n         col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,enor.y) );\n         col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,enor.y) );\n         col *= 1.6;\n\n    // --- brdf * material ---\n    col *= lin;\n    col += spe*1.2*vec3(1.0,1.1,2.5);\n\n    // --- fog ---\n    col = fog( col, rt );\n\n    return col;\n}\n\nvec4 renderTrees( in vec3 ro, in vec3 rd, float tmin, float tmax, float terrainShadow, inout float resT )\n{\n\t//if( tmin>300.0 ) return vec4(0.0);\n    float t = tmin;\n    float hei, mid, displa;\n\n    for(int i=ZERO; i<64; i++) \n    { \n        vec3  pos = ro + t*rd; \n        float dis = treesMap( pos, t, hei, mid, displa); \n        if( dis<(0.0001*t) ) break;\n        t += dis;\n        if( t>tmax ) return vec4(0.0);\n    }\n    \n    vec3 pos = ro + t*rd;\n\n    vec3 enor = terrainNormal( pos.xz );\n    vec3 tnor = treesNormal( pos, t );            \n\n    vec3 col = treesShade( pos, tnor, enor, hei, mid, displa, t, rd, terrainShadow );\n\tresT = t;\n    \n    return vec4(col,1.0);\n}\n\n\n//------------------------------------------------------------------------------------------\n// sky\n//------------------------------------------------------------------------------------------\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\n\n    // clouds\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = fbm_9( uv*0.002 );\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.4*dl );\n    }\n    \n\t// sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.6*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    \n\treturn col;\n}\n\n\n//------------------------------------------------------------------------------------------\n// main image making function\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = hash2( float(iFrame) ) - 0.5;\n    \n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/ iResolution.y;\n    \n    //----------------------------------\n    // setup\n    //----------------------------------\n\n    // camera\n    #ifdef  STATIC_CAMERA\n    vec3 ro = vec3(0.0, -99.25, 5.0);\n    vec3 ta = vec3(0.0, -99.0, 0.0);\n\t#else\n    float time = iTime;\n    vec3 ro = vec3(0.0, -99.25, 5.0) + vec3(10.0*sin(0.02*time),0.0,-10.0*sin(0.2+0.031*time));\n    vec3 ta = vec3(0.0, -98.25, -45.0 + ro.z );\n    #endif\n    \n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n\n\tfloat resT = 1000.0;\n\n    //----------------------------------\n    // sky\n    //----------------------------------\n\n    vec3 col = renderSky( ro, rd );\n    \n    //----------------------------------\n    // terrain\n    //----------------------------------\n    vec2 teDistance;\n    float teShadow;\n    \n    vec2 tmima = vec2(15.0,1000.0);\n    {\n        vec4 res = renderTerrain( ro, rd, tmima, teShadow, teDistance, resT );\n        col = col*(1.0-res.w) + res.xyz;\n    }                        \n\n    //----------------------------------\n    // trees\n    //----------------------------------\n    if( teDistance.y>0.0 )\n    {\n        tmima = vec2( teDistance.y, (teDistance.x>0.0)?teDistance.x:tmima.y );\n        vec4 res = renderTrees( ro, rd, tmima.x, tmima.y, teShadow, resT );\n        col = col*(1.0-res.w) + res.xyz;\n    }\n\n    //----------------------------------\n    // clouds\n    //----------------------------------\n    {\n        vec4 res = renderClouds( ro, rd, 0.0, (teDistance.x>0.0)?teDistance.x:tmima.y, resT );\n        col = col*(1.0-res.w) + res.xyz;\n    }\n\n    //----------------------------------\n    // final\n    //----------------------------------\n    \n    // sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.25*vec3(1.0,0.4,0.2)*pow( sun, 4.0 );\n \n    // gamma\n    col = sqrt(col);\n\n    //----------------------------------\n    // color grading\n    //----------------------------------\n\n    col = col*0.15 + 0.85*col*col*(3.0-2.0*col);            // contrast\n    col = pow( col, vec3(1.0,0.92,1.0) );   // soft green\n    col *= vec3(1.02,0.99,0.99);            // tint red\n    col.z = (col.z+0.1)/1.1;                // bias blue\n    col = mix( col, col.yyy, 0.15 );       // desaturate\n     \n    col = clamp( col, 0.0, 1.0 );\n    \n    \n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\n    mat4 oldCam = mat4( textureLod(iChannel0,vec2(0.5,0.5)/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(1.5,0.5)/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(2.5,0.5)/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*resT,1.0);\n    // camera space\n    vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = 1.5 * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    // undo dither\n    spos -= o/iResolution.xy;\n\t// raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.1 );\n    }\n\n    //----------------------------------\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<3.0 )\n    {\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, 1.0 );\n    }\n}\n",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "it looks so awesome. Keep up the perfect job",
        "date": "1558363731",
        "username": "Mary_Cream",
        "userpicture": "/media/users/Mary_Cream/profile.jpeg",
        "id": "llSyzK",
        "hidden": 0
      },
      {
        "text": "965M\uff1a15.5-17.9fps",
        "date": "1557063251",
        "username": "Geralt_of_China",
        "userpicture": "/media/users/Geralt_of_China/profile.jpeg",
        "id": "XtjyDW",
        "hidden": 0
      },
      {
        "text": "Thanks, that helps explain it. I also saw something else (I think it was by P_Malins) that helped too.",
        "date": "1551848324",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "XllyRS",
        "hidden": 0
      },
      {
        "text": "@scratch13764 He's using a small portion of the ch0's output buffer to store the current camera transform (ca[0], ca[1], ca[2]), so that he can read it in the next frame as oldCam.\n\nThen he transforms the current frag's world space position to screen space and reverts (undoes) the screen space shifting o in order to get an aligned frame (o is used to slightly shift the rendering, so that when mixing with the new frame, partial super-sampling is effectivelly achieved - this is one of the most clever and effective AA techniques I've seen).\n\nAfter that, he goes from screen space to raster space, samples the old frame (texLod(ch0, spos)) and mixes in the new color. The output is essentially used as a IIR history / accumulation buffer.",
        "date": "1548941457",
        "username": "spawner64",
        "userpicture": "/img/profile.jpg",
        "id": "XlsyRr",
        "hidden": 0
      },
      {
        "text": "Can someone explain how the old frame averaging works in this? I can see that the frame is mapped to the terrain and it's really freaking me out how it works.",
        "date": "1547621567",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "XsBfWV",
        "hidden": 0
      },
      {
        "text": "Amazing!",
        "date": "1529399552",
        "username": "yuletian",
        "userpicture": "/media/users/yuletian/profile.png",
        "id": "4djczy",
        "hidden": 0
      },
      {
        "text": "for mouse control camera rotation (only slow movements, please :-) :\nadd in bufA line 834\n    vec2 A = 3.14*(2.*iMouse.xy/iResolution.xy-1.);\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n    ta = vec3(0,0,1); ta.xz *= rot(A.x);  ta.yz *= rot(-A.y); \n    ta += ro;\n",
        "date": "1525971048",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MdByR1",
        "hidden": 0
      },
      {
        "text": "looks like the sight from my living room :-)",
        "date": "1525936724",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ldScRh",
        "hidden": 0
      },
      {
        "text": "Next project: GTA V",
        "date": "1525369606",
        "username": "akhgary",
        "userpicture": "/img/profile.jpg",
        "id": "4sBcRz",
        "hidden": 0
      },
      {
        "text": "It's awesome graphics!!!!!\n\nTIP: if you want to run in IE change \"textureLod\" to \"texture\"\n",
        "date": "1521387437",
        "username": "songinnight",
        "userpicture": "/img/profile.jpg",
        "id": "XsXcW4",
        "hidden": 0
      },
      {
        "text": "Insane. Level god. ",
        "date": "1514949551",
        "username": "jpupper",
        "userpicture": "/img/profile.jpg",
        "id": "4lyXzy",
        "hidden": 0
      },
      {
        "text": "@hammedshh, because it's raymarched, because there are no meshes, because it's running on WebGL, because your GPU is not meant to run this. In normal OpenGL this would be full framerate in HD. But this is not what Shadertoy is about",
        "date": "1514264651",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XtyXDD",
        "hidden": 0
      },
      {
        "text": "@hamedshh - That's nearly a 6 year old gfx card!  :)  I have a gtx680 and that's 26fps in a window...",
        "date": "1513029933",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XlVXzW",
        "hidden": 0
      },
      {
        "text": "why is it run slowly with 8.8 fps on my PC whereas i have GT630 as Graphic card and core i5 as CPU ",
        "date": "1513029491",
        "username": "hamedshh",
        "userpicture": "/img/profile.jpg",
        "id": "XtVXzW",
        "hidden": 0
      },
      {
        "text": "i think a [foggy valley] would look good (as in, easily believable and high geometry detail) and have good performance, even when valleys are seeded noise.\nFog in valleys basically replaces the occlusion that a mountain would have there otherwise.\n\nmost people do distance fog poorly, by making it spherical around the camera, and not making it diminishing fog with increasing height. google image search [fog valley] for inspiration. most photos look down into valleys, because looking out of a fog is just not as characteristic.\n\ndiminishing fog by height (volume marching a cloud in a valley) makes it easy to look \"up\" from inside a foggy valley, so you likely see birds and nearby mountain peaks.\nThis mostly diminishes looking nearly-horizontally along or trough a foggy valley.\nThen you put all your high detail geometry inside a foggy valley  (along rivers), where it is more realistically occluded by fog and surrounded by either mountains or more valley-fog.\n\nyou can fly into valleys and over them, giving the illusion of more detail than there is per frame, from memory of what you saw there.",
        "date": "1510144676",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "MltSRj",
        "hidden": 0
      },
      {
        "text": "so sick!! but yes, a bit heavy load.",
        "date": "1510127308",
        "username": "jcyuan",
        "userpicture": "/img/profile.jpg",
        "id": "4tdXR2",
        "hidden": 0
      },
      {
        "text": "Looks beautiful. I just wish my GPU did better than 26fps. (1070)",
        "date": "1508603375",
        "username": "Uneclipsed",
        "userpicture": "/img/profile.jpg",
        "id": "Xt3XDH",
        "hidden": 0
      },
      {
        "text": "Awesome colors :D Thats great",
        "date": "1504262726",
        "username": "Osgrot",
        "userpicture": "/media/users/Osgrot/profile.jpeg",
        "id": "MlG3Ww",
        "hidden": 0
      },
      {
        "text": "Colours and shading are amazing.",
        "date": "1504171629",
        "username": "Docculd",
        "userpicture": "/media/users/Docculd/profile.png",
        "id": "4lyGDw",
        "hidden": 0
      },
      {
        "text": "test render at [video]https://www.youtube.com/watch?v=YtaYCKtBg4M&[/video]\n\nthird time is the charm",
        "date": "1495327859",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "4dKXWK",
        "hidden": 0
      },
      {
        "text": "I can hear the rainforest inside my laptop when this runs.... \"Whooosh\"",
        "date": "1495266309",
        "username": "dagelf",
        "userpicture": "/img/profile.jpg",
        "id": "ldGSDV",
        "hidden": 0
      },
      {
        "text": "30fps on a Titan X (Maxwell), Ubuntu, for me. Is the 1080 simply better than the old Titan X?",
        "date": "1491780849",
        "username": "etale_cohomology",
        "userpicture": "/media/users/etale_cohomology/profile.png",
        "id": "ldGSD1",
        "hidden": 0
      },
      {
        "text": "Very nice lush colors :)",
        "date": "1488085976",
        "username": "Passion",
        "userpicture": "/img/profile.jpg",
        "id": "XsdSWj",
        "hidden": 0
      },
      {
        "text": "I\u00f1igo, cada vez estoy m\u00e1s impresionado de tus habilidades. Incre\u00edbles tus trabajos.",
        "date": "1487762943",
        "username": "Damasko",
        "userpicture": "/img/profile.jpg",
        "id": "lstSDS",
        "hidden": 0
      },
      {
        "text": "Wow :)",
        "date": "1487332172",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "4sdXRs",
        "hidden": 0
      },
      {
        "text": "TAA = Temporal Anti Aliasing",
        "date": "1486075927",
        "username": "mag",
        "userpicture": "/img/profile.jpg",
        "id": "4d3Xz2",
        "hidden": 0
      },
      {
        "text": "What's TAA refer to in the source comments?",
        "date": "1485965722",
        "username": "SarahC",
        "userpicture": "/img/profile.jpg",
        "id": "Xs3XRj",
        "hidden": 0
      },
      {
        "text": "It looks like Intel is not affected by this weirdness: 5fps in chrome in both desktop and Angle modes",
        "date": "1483142077",
        "username": "casty",
        "userpicture": "/img/profile.jpg",
        "id": "4scXz4",
        "hidden": 0
      },
      {
        "text": "Canvas: 800x450, Windows 10, GTX 980 Mobile\r\n\r\nRainForest: 23 fps Microsoft Edge\r\nRainForest: 15 fps Chrome (Angle)\r\nRainForest: 35 fps Chrome with --use-gl=desktop\r\nRainForest: 15 fps Firefox (Angle)\r\nRainForest: 28 fps Firefox with Disable.Angle (and zero compilation time)\r\n\r\nSnail: 30 fps Microsoft Edge\r\nSnail: 44 fps Chrome (Angle)\r\nSnail: 60 fps Chrome with --use-gl=desktop\r\nSnail: 34 fps Firefox (Angle)\r\nSnail: 44 fps Firefox with Disable.Angle (and zero compilation time)\r\n\r\nClearly, Angle (Firefox and Chrome's WebGL/GLSL to DirectX/HLSL translation layer) is fucking things up quite a bit...\r\n\r\nRainforest: [url]https://www.shadertoy.com/view/4ttSWf[/url]\r\nSnail: [url]https://www.shadertoy.com/view/ld3Gz2[/url]",
        "date": "1483138975",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XdcXz4",
        "hidden": 0
      },
      {
        "text": "Canvas : 800x450, Chromium, Debian Linux, GTX 1070\nSnail: 60fps\nRainForest: 60 fps",
        "date": "1483093621",
        "username": "manolopm",
        "userpicture": "/img/profile.jpg",
        "id": "4d3Sz4",
        "hidden": 0
      },
      {
        "text": "Ok, Canvas 800x450, Chrome Win 10 GTX1070\nSnail: 60 fps\nRainforest: 30 fps\nRight click, inspect in chrome and you can also read the size of the canvas in the attributes of the canvas",
        "date": "1483085786",
        "username": "Andre",
        "userpicture": "/img/profile.jpg",
        "id": "XdcSR4",
        "hidden": 0
      },
      {
        "text": "To those people getting 60fps in this shader with 1060/1070\n\nCould you please test theIQ's Snail shader and tell me the fps? Please make sure you are in the 1080 layot and canvas is 800x450 (you can check the canvas size with Fabriceneyret2's iResloution shader)",
        "date": "1483081991",
        "username": "casty",
        "userpicture": "/img/profile.jpg",
        "id": "lsdXzH",
        "hidden": 0
      },
      {
        "text": "Thanks for the detailed info Andre. Let me know Casty how your investigations go",
        "date": "1482990606",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ldtXz8",
        "hidden": 0
      },
      {
        "text": "6700K and a GTX1070 here on Chrome and Win10.\n60fps on smallest browser window (canvas is 500x281)\n14 when i make browser window bigger (canvas is 1200x675)\n\nEdge browser gives me 20fps on largest in browser (canvas 1200x675)\nFirefox ~23fps varies between 20 and 28",
        "date": "1482945870",
        "username": "Andre",
        "userpicture": "/img/profile.jpg",
        "id": "XddSzH",
        "hidden": 0
      },
      {
        "text": "IQ, \n\nI'm getting 20fps which is way more than any Intel can do. And it is shader dependent, Snail and pool shaders do run at their theoretical speed. So it has to be something else. At least other ppl are running at 60fps so I should be able to troubleshoot it.\n\nThanks",
        "date": "1482934219",
        "username": "casty",
        "userpicture": "/img/profile.jpg",
        "id": "XstXRH",
        "hidden": 0
      },
      {
        "text": "Browser seems to make a big difference: 54.1 fps in Chrome, 60.0 fps in Firefox, on a 1080 (Windows 10).",
        "date": "1482930746",
        "username": "Jacoby",
        "userpicture": "/img/profile.jpg",
        "id": "XsdSRH",
        "hidden": 0
      },
      {
        "text": "Absolutely incredible. Thanks for sharing!",
        "date": "1482930217",
        "username": "Jacoby",
        "userpicture": "/img/profile.jpg",
        "id": "4ddSRH",
        "hidden": 0
      },
      {
        "text": "Awesome!!!. 60 Fps on 1070 ",
        "date": "1482920028",
        "username": "manolopm",
        "userpicture": "/img/profile.jpg",
        "id": "XsdXz8",
        "hidden": 0
      },
      {
        "text": "Also, a friend said the 1060 was balcklisted on his Chrome, he had to enable it by hand, otherwise the Intel was kicking in for him too.",
        "date": "1482902415",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XdtXz8",
        "hidden": 0
      },
      {
        "text": "It should run at about 60 fps on your 1060 Casty. Are you in a laptop? You are probably using the Intel integrated card (close all browser tabs and restart Chrome with right_click + Nvidia GPU). We have tested on a 1060M, it does run full framerate. It is 16 fps on my (now old) 980M.",
        "date": "1482902356",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4sdSz8",
        "hidden": 0
      },
      {
        "text": "@834144373 I don't know why I'm getting only 20fps with my 1060, are you using the 1080 layout? ",
        "date": "1482852120",
        "username": "casty",
        "userpicture": "/img/profile.jpg",
        "id": "4stSR8",
        "hidden": 0
      },
      {
        "text": "Brilliant!! Love your works so much!\nI hope I can code such beautiful things like all genius here.\nUnfortunately, I have no graphic mathematics concepts. How to learn from the beginning?",
        "date": "1482832524",
        "username": "siuyy",
        "userpicture": "/img/profile.jpg",
        "id": "lscXzH",
        "hidden": 0
      },
      {
        "text": "haha... 50.5fps on GTX1060",
        "date": "1482824213",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "ld3XzH",
        "hidden": 0
      },
      {
        "text": "Outstanding, as always! ^^ \n\n@keelo \n\"fbm\" stands for [url=https://thebookofshaders.com/13/]\"Fractal Brownian Motion\"[/url]",
        "date": "1482749621",
        "username": "revers",
        "userpicture": "/media/users/revers/profile.gif",
        "id": "Ms3Xz8",
        "hidden": 0
      },
      {
        "text": "Very impressive !",
        "date": "1482694130",
        "username": "Phi",
        "userpicture": "/media/users/Phi/profile.jpeg",
        "id": "lscSR8",
        "hidden": 0
      },
      {
        "text": "I'm in awe, beautiful work.",
        "date": "1482547761",
        "username": "public_int_i",
        "userpicture": "/img/profile.jpg",
        "id": "XdcSz8",
        "hidden": 0
      },
      {
        "text": "Please tell us you're working on a new demo. I REALLY would love to see Elevated 2.",
        "date": "1482546667",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "Xs3Sz8",
        "hidden": 0
      },
      {
        "text": "gorgeous! what does fbm stand for?",
        "date": "1482525319",
        "username": "keelo",
        "userpicture": "/img/profile.jpg",
        "id": "XscSR8",
        "hidden": 0
      },
      {
        "text": "Great work! ",
        "date": "1482518409",
        "username": "stb",
        "userpicture": "/img/profile.jpg",
        "id": "4dcSR8",
        "hidden": 0
      },
      {
        "text": "padauz!! so much detail... i really like the clouds falling over the mountains",
        "date": "1482501901",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "lstXzr",
        "hidden": 0
      },
      {
        "text": "Amazing. The best looking single shader terrain scene to date.",
        "date": "1482489793",
        "username": "drift",
        "userpicture": "/img/profile.jpg",
        "id": "MsdSzr",
        "hidden": 0
      },
      {
        "text": "Fixed, I hope!",
        "date": "1482481111",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MdtSzr",
        "hidden": 0
      },
      {
        "text": "@iq, in renderTerrain function out variables teShadow and teDistance are not initialised/set in all program paths. Because of the uninitialised teDistance on mac mini the sky is corrupted. I can't see the difference due to teShadow, but surely it should be initialised.\nbtw 25 fps in smallest resolution (500x280) on mac mini with intel iris. 13 fps in 640x360. :D",
        "date": "1482476988",
        "username": "coyote",
        "userpicture": "/img/profile.jpg",
        "id": "MsdXRr",
        "hidden": 0
      },
      {
        "text": "The sense of magnitude in this scene is great, appears far from finite!",
        "date": "1482475388",
        "username": "KylBlz",
        "userpicture": "/media/users/KylBlz/profile.jpeg",
        "id": "lsdXRr",
        "hidden": 0
      },
      {
        "text": "Wow...",
        "date": "1482451944",
        "username": "Draedrus",
        "userpicture": "/media/users/Draedrus/profile.png",
        "id": "lddSRr",
        "hidden": 0
      },
      {
        "text": "Beautiful, beautiful terrain running at 19 fps on my workstation!",
        "date": "1482447326",
        "username": "starea",
        "userpicture": "/media/users/starea/profile.jpeg",
        "id": "MdtXzn",
        "hidden": 0
      },
      {
        "text": "Awesome!",
        "date": "1482432734",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "MstSzn",
        "hidden": 0
      },
      {
        "text": "A little slow, but looks incredible! ",
        "date": "1482430049",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "lsdXRn",
        "hidden": 0
      },
      {
        "text": "Incroyable ! Are you working for the \"next Avatar movie\"or just preparing the next elevated 4k - 10th  happy birthday ? ;-p",
        "date": "1482429077",
        "username": "Unix",
        "userpicture": "/img/profile.jpg",
        "id": "lddXRn",
        "hidden": 0
      },
      {
        "text": "excellent. 0.7 fps in rdp software mode",
        "date": "1482426933",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "lsdSRn",
        "hidden": 0
      },
      {
        "text": ":love:",
        "date": "1482426640",
        "username": "Duke",
        "userpicture": "/img/profile.jpg",
        "id": "MddSRn",
        "hidden": 0
      },
      {
        "text": "It is a bit strange, I'm getting 20 fps with the GTX1060, but the old Quadro 4000M (equivalent to GTS 450) is showing 7 fps\n\nIn other shaders I get the theoretical 700% diference (Snail and Pool to name a couple)",
        "date": "1482425744",
        "username": "casty",
        "userpicture": "/img/profile.jpg",
        "id": "lddSRn",
        "hidden": 0
      },
      {
        "text": ":love: the lack of aliasing! Nice clouds and backdrop too. It is very slow though.",
        "date": "1482423302",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MdtSRn",
        "hidden": 0
      },
      {
        "text": "It's insanely good. Almost can't believe my eyes.",
        "date": "1482420896",
        "username": "kuvkar",
        "userpicture": "/media/users/kuvkar/profile.png",
        "id": "ldtSRn",
        "hidden": 0
      },
      {
        "text": "Gobsmacked. Pure Magic!",
        "date": "1482420380",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "4sdXzr",
        "hidden": 0
      },
      {
        "text": "few lines?? have you missed the 'Buf A' tab? ;)",
        "date": "1482411678",
        "username": "xeronimo74",
        "userpicture": "/img/profile.jpg",
        "id": "4stXzr",
        "hidden": 0
      },
      {
        "text": "fantastic!",
        "date": "1482408971",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "XstXzr",
        "hidden": 0
      },
      {
        "text": "This is Incredibly Awesome! WOW!!! ",
        "date": "1482407983",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "4dtXzr",
        "hidden": 0
      },
      {
        "text": ":love: A movie quality scene constructed with a few lines of text by one person. Utterly amazing!",
        "date": "1482405720",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "XdtXzr",
        "hidden": 0
      },
      {
        "text": "Awesome.",
        "date": "1482403516",
        "username": "mantra",
        "userpicture": "/img/profile.jpg",
        "id": "4sdSzr",
        "hidden": 0
      },
      {
        "text": "1fps in fullscreen on a GTX950. Totally worth it :-D",
        "date": "1482401327",
        "username": "russ",
        "userpicture": "/img/profile.jpg",
        "id": "XsdSzr",
        "hidden": 0
      },
      {
        "text": "Hell Yeah! Brilliant! :love:\nCan't stop watching it...",
        "date": "1482398544",
        "username": "coyote",
        "userpicture": "/img/profile.jpg",
        "id": "XdtSzr",
        "hidden": 0
      },
      {
        "text": "Breathtaking!",
        "date": "1482395991",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "4ddXRr",
        "hidden": 0
      },
      {
        "text": "It looks stunning! quite literally as I have been staring at it for more than 20 minutes...\nThe strokes in the clouds are intriguing, very painterly.",
        "date": "1482395425",
        "username": "blackjero",
        "userpicture": "/img/profile.jpg",
        "id": "XddXRr",
        "hidden": 0
      },
      {
        "text": "This resembles a photograph. Both in realism and framerate :D",
        "date": "1482392786",
        "username": "s23b",
        "userpicture": "/media/users/s23b/profile.png",
        "id": "4stXRr",
        "hidden": 0
      },
      {
        "text": "Amazing!",
        "date": "1482392138",
        "username": "xeronimo74",
        "userpicture": "/img/profile.jpg",
        "id": "XstXRr",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "MdGfzh",
      "date": "1527594357",
      "viewed": 12290,
      "name": "Himalayas",
      "username": "reinder",
      "description": "This is my first attempt to render volumetric clouds in a fragment shader. I started this shader by trying to model the clouds of Horizon Zero Dawn and render them using the integration method of volumetric media as described by S\u00e9bastien Hillaire (SebH).",
      "likes": 222,
      "published": 3,
      "flags": 32,
      "tags": [
        "volume",
        "clouds",
        "light",
        "sky",
        "volumetric",
        "scattering",
        "realtime",
        "atmospheric",
        "cloudscape",
        "himalayas"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// I started this shader by trying to implement the clouds of Horizon Zero Dawn, as\n// described in \"The real-time volumetric cloudscapes of Horizon Zero Dawn\" by \n// Andrew Schneider and Nathan Vos.[1] To model the shape of the clouds, two look-up\n// textures are created with different frequencies of (Perlin -) Worley noise:\n//\n// Buffer A: The main look-up texture for the cloud shapes. \n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\n//           \n// Because it is not possible (yet) to create buffers with fixed size, or 3D buffers, the\n// look-up texture in Buffer A is 2D, and a slice of the volume that is described in the \n// article. Therefore, and because I didn't have any slots left (in Buffer C) to use a \n// cloud type/cloud coverage texture, the modelling of the cloud shapes in this shader is \n// in the end mostly based on trial and error, and is probably far from the code used in \n// Horizon Zero Dawn.\n//\n// Buffer D: Rendering of the clouds.\n//\n// I render the clouds using the improved integration method of volumetric media, as described \n// in \"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\" by \n// S\u00e9bastien Hillaire.[2]\n//\n// You can find the (excellent) example shaders of S\u00e9bastien Hillaire (SebH) here:\n//\n// https://www.shadertoy.com/view/XlBSRz\n// https://www.shadertoy.com/view/MdlyDs\n//\n// Buffer C: Landscape\n//\n// To create an interesting scene and to add some scale to the clouds, I render a \n// terrain using a simple heightmap, based on the work by \u00cd\u00f1igo Qu\u00edlez on value noise and its \n// analytical derivatives.[3]\n//\n// In fact, the heightmap of this shader is almost exactly the same as the heightmap that \n// is used in \u00cd\u00f1igo Qu\u00edlez' shader Elevated:\n//\n// https://www.shadertoy.com/view/MdX3Rr\n//\n// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain \n// (Buffer C)) separatly. The temporal reprojection code is based on code from the shader\n// \"Rain Forest\" (again by \u00cd\u00f1igo Qu\u00edlez):\n//\n// https://www.shadertoy.com/view/4ttSWf\n// \n// Finally, in the Image tab, clouds and terrain are combined, a small humanoid is added\n// (by Hazel Quantock) and post processing is done.\n//\n// [1] https://www.guerrilla-games.com/read/the-real-time-volumetric-cloudscapes-of-horizon-zero-dawn\n// [2] https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n// [3] http://iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n\n#define AA 3\n\n//\n// Cheap 2D Humanoid SDF for dropping into scenes to add a sense of scale.\n// Hazel Quantock 2018\n//\n// Based on: https://www.shadertoy.com/view/4scBWN\n//\nfloat RoundMax( float a, float b, float r ) {\n    a += r; b += r;    \n    float f = ( a > 0. && b > 0. ) ? sqrt(a*a+b*b) : max(a,b);    \n    return f - r;\n}\n\nfloat RoundMin( float a, float b, float r ) {\n    return -RoundMax(-a,-b,r);\n}\n\nfloat Humanoid( in vec2 uv, in float phase ) {\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \"pose\"\n    float n0 = sin((uv.y+uv.x*1.1)*23.+phase*2.)*.007;\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase*4.)*.004;\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase*8.)*.002;\n\n    \n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\n    float neck = length(uv-vec2(0,1.5))-.05;\n    float torso = abs(uv.x)-.25 - uv.x*.3;\n\n    torso = RoundMax( torso, uv.y-1.5, .2 );\n    torso = RoundMax( torso, -(uv.y-.6), .0 );\n\n    float f = RoundMin(head,neck,.04);\n    f = RoundMin(f,torso,.02);\n    \n    float leg = abs(abs(uv.x+(uv.y-.9)*.1*cos(phase*3.))-.15+.075*uv.y)-.07-.07*uv.y; \n    leg = max( leg, uv.y-1. );\n    \n    f = RoundMin(f,leg,.1);\n\n    float stick = max(abs(uv.x+.4-uv.y*.04)-0.025, uv.y-1.15);\n    float arm = max(max(abs(uv.y-1.-uv.x*.3) - .06, uv.x), -uv.x-.4);\n    \n    f = RoundMin(f, stick, 0.0);\n    f = RoundMin(f, arm, 0.05);\n    \n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\n    \n    return max( f, -uv.y );\n}\n\n//\n// Lens flare, original based on:\n// musk's lens flare by mu6k  \n//\n// https://www.shadertoy.com/view/4sX3Rs\n//\nfloat lensflare(vec2 fragCoord) {\n    vec3 ro, ta;\n    mat3 cam = getCamera( iTime, iMouse/iResolution.xyxy, ro, ta );\n    vec3 cpos = SUN_DIR*cam; \n    vec2 pos = CAMERA_FL * cpos.xy / cpos.z;\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n\tvec2 uvd = uv*(length(uv));\n\tfloat f = 0.1/(length(uv-pos)*16.0+1.0);\n\tf += max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*0.25;\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\tf += max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tf += max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tuvx = mix(uv,uvd,-0.4);\n\tf += max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n    \n\treturn f;\n}\n\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    vec3  ds = ro - sph.xyz;\n    float bs = dot(rd, ds);\n    float cs = dot(ds, ds) - sph.w*sph.w;\n    float ts = bs*bs - cs;\n\t\n    if( ts > 0.0 ) {\n        ts = -bs - sqrt( ts );\n\t\tif( ts>0. ) {\n\t\t\treturn true;\n\t\t}\n    }\n    return false;\n}\n\nbool intersectPlane (in vec3 ro, in vec3 rd, in vec3 n, in vec3 p0, inout float dist) {   \n    dist = dot(p0 - ro, n)/dot(rd,n);\n    return dist > 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    if( letterBox(fragCoord, iResolution.xy, 2.35) ) {\n        fragColor = vec4( 0., 0., 0., 1. );\n    } else {\n        vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        vec4 clouds = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \t\n        col.rgb = clouds.rgb + col.rgb * clouds.a;\n       \n        vec3 ro, rd, ta;\n\t\tmat3 cam = getCamera( iTime, iMouse/iResolution.xyxy, ro, ta );\n        float dist;\n        vec4 tcol = vec4(0.);\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n        rd = cam * normalize(vec3(p,CAMERA_FL)); \n        \n        if (intersectSphere(ro,rd,vec4(FLAG_POSITION,HUMANOID_SCALE*INV_SCENE_SCALE*2.))) {\n            for(int x=0; x<AA; x++) {\n                for(int y=0; y<AA; y++) {\n                    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)/float(AA) - .5))/iResolution.y;\n                    rd = cam * normalize(vec3(p,CAMERA_FL)); \n\n                    if (intersectPlane(ro, rd, vec3(0,0,1), FLAG_POSITION, dist) && dist < col.w) {\n                        vec3 pos = ro + rd * dist;\n                        vec2 uv = (pos.xy - FLAG_POSITION.xy)*(SCENE_SCALE/HUMANOID_SCALE);\n                        uv.x = -uv.x + uv.y*0.05;\n                        float sdf = Humanoid( uv, 3. );\n                        float a = smoothstep(.4,.6,.5-.5*sdf/(abs(sdf)+.002));\n                        float sdf2 = Humanoid( uv+vec2(.025,0.05), 3. );\n                        float a2 = smoothstep(.4,.6,.5-.5*sdf2/(abs(sdf2)+.002));\n                        float c = (a-a2)*2.;\n                        c = clamp(c+uv.x*.2+.6,0.,1.); c*=c; c*=c;\n                        tcol += vec4(mix(vec3(.04,0.05,0.06),SUN_COLOR,c),a);\n                    }\n                }\n            }\n            tcol /= float(AA*AA);\n        }\n        \n        col.rgb = mix(col.rgb, tcol.rgb, tcol.w);    \n            \n        // lens flare\n        col.rgb += SUN_COLOR*lensflare(fragCoord)*smoothstep(-.3,.5,dot(rd,SUN_DIR));       \n        col.rgb = clamp(col.rgb, vec3(0), vec3(1));\n        \n        // gamma and contrast\n        col.rgb = mix(col.rgb, pow(col.rgb, vec3(1./2.2)), .85);\n        col.rgb = mix( col.rgb, col.bbb, 0.2 ); \n     \n        // vignette\n        vec2 uv = fragCoord / iResolution.xy;\n        col.rgb = mix(col.rgb*col.rgb, col.rgb, pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ));\n        \n        // noise\n        col.rgb -= hash12(fragCoord)*.025;\n        \n        fragColor = vec4( col.rgb, 1. );\n    }\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// 1 unit correspondents to SCENE_SCALE meter.\n\n#define SCENE_SCALE (10.)\n#define INV_SCENE_SCALE (.1)\n\n#define MOUNTAIN_HEIGHT (5000.)\n#define MOUNTAIN_HW_RATIO (0.00016)\n\n#define SUN_DIR normalize(vec3(-.7,.5,.75))\n#define SUN_COLOR (vec3(1.,.9,.85)*1.4)\n\n#define FLAG_POSITION (vec3(3900.5,720.,-2516.)*INV_SCENE_SCALE)\n#define HUMANOID_SCALE (2.)\n\n#define CAMERA_RO (vec3(3980.,730.,-2650.)*INV_SCENE_SCALE)\n#define CAMERA_FL 2.\n\n#define HEIGHT_BASED_FOG_B 0.02\n#define HEIGHT_BASED_FOG_C 0.05\n\n\nmat3 getCamera( in float time, in vec4 mouse, inout vec3 ro, inout vec3 ta ) {\n    ro = CAMERA_RO;\n    vec3 cw;\n    if (mouse.z > 0.) {\n        vec2 m = (mouse.xy - .5) * 2.3;\n        float my = -sin(m.y);\n        cw = normalize(vec3(-sin(-m.x), my+.15, cos(-m.x)));\n    } else {\n    \tro.x += -cos(time*.13)*5.*INV_SCENE_SCALE;\n    \tro.z += (-cos(time*.1)*100.+20.)*INV_SCENE_SCALE;\n    \tcw = normalize(vec3(-.1,.18,1.));\n    }   \n    ta = ro + cw*(200.*INV_SCENE_SCALE);\n\tvec3 cp = vec3(0.0,1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid getRay( in float time, in vec2 fragCoord, in vec2 resolution, in vec4 mouse, inout vec3 ro, inout vec3 rd) {\n\tvec3 ta;\n\tmat3 cam = getCamera( time, mouse, ro, ta );\n    vec2 p = (-resolution.xy + 2.0*(fragCoord))/resolution.y;\n    rd = cam * normalize(vec3(p,CAMERA_FL));     \n}\n\n//\n// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain \n// (Buffer C) seperatly. The temporal repojection code is based on code from the shader\n// \"Rain Forest\" (again by \u00cd\u00f1igo Qu\u00edlez):\n//\n// https://www.shadertoy.com/view/4ttSWf\n// \nvec4 saveCamera( in float time, in vec2 fragCoord, in vec4 mouse ) {   \n    vec3 ro, ta;\n    mat3 cam = getCamera( time, mouse, ro, ta );\n    vec4 fragColor;\n    \n    if( abs(fragCoord.x-4.5)<0.5 ) fragColor = vec4( cam[2], -dot(cam[2],ro) );\n    if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );\n    if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );\n    \n    return fragColor;\n}\n\nvec2 reprojectPos( in vec3 pos, in vec2 resolution, in sampler2D storage ) {\n    mat4 oldCam = mat4( texelFetch(storage,ivec2(2,0),0),\n                        texelFetch(storage,ivec2(3,0),0),\n                        texelFetch(storage,ivec2(4,0),0),\n                        0.0, 0.0, 0.0, 1.0 );\n\n    vec4 wpos = vec4(pos,1.0);\n    vec3 cpos = (wpos*oldCam).xyz; \n    vec2 npos = CAMERA_FL * cpos.xy / cpos.z;\n    return 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);\n}\n\n//\n// Fast skycolor function by \u00cd\u00f1igo Qu\u00edlez\n// https://www.shadertoy.com/view/MdX3Rr\n//\nvec3 getSkyColor(vec3 rd) {\n    float sundot = clamp(dot(rd,SUN_DIR),0.0,1.0);\n\tvec3 col = vec3(0.2,0.5,0.85)*1.1 - max(rd.y,0.01)*max(rd.y,0.01)*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow(1.0-max(rd.y,0.0), 6.0) );\n\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.20*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    \n    col += clamp((0.1-rd.y)*10., 0., 1.) * vec3(.0,.1,.2);\n    col += 0.2*vec3(1.0,0.8,0.6)*pow( sundot, 8.0 );\n    return col;\n}\n\nbool letterBox(vec2 fragCoord, const vec2 resolution, const float aspect) { \n    if( fragCoord.x < 0. || fragCoord.x > resolution.x ||\n        abs(2.*fragCoord.y-resolution.y) > resolution.x * (1./aspect) ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n//\n// Noise functions\n//\n// Hash without Sine by DaveHoskins \n//\n// https://www.shadertoy.com/view/4djSRW\n//\nfloat hash12( vec2 p ) {\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash13(vec3 p3) {\n    p3  = fract(p3 * 1031.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat valueHash(vec3 p3) {\n    p3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//\n// Noise functions used for cloud shapes\n//\nfloat valueNoise( in vec3 x, float tile ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( valueHash(mod(p+vec3(0,0,0),tile)), \n                        valueHash(mod(p+vec3(1,0,0),tile)),f.x),\n                   mix( valueHash(mod(p+vec3(0,1,0),tile)), \n                        valueHash(mod(p+vec3(1,1,0),tile)),f.x),f.y),\n               mix(mix( valueHash(mod(p+vec3(0,0,1),tile)), \n                        valueHash(mod(p+vec3(1,0,1),tile)),f.x),\n                   mix( valueHash(mod(p+vec3(0,1,1),tile)), \n                        valueHash(mod(p+vec3(1,1,1),tile)),f.x),f.y),f.z);\n}\n\nfloat voronoi( vec3 x, float tile ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float res = 100.;\n    for(int k=-1; k<=1; k++){\n        for(int j=-1; j<=1; j++) {\n            for(int i=-1; i<=1; i++) {\n                vec3 b = vec3(i, j, k);\n                vec3 c = p + b;\n\n                if( tile > 0. ) {\n                    c = mod( c, vec3(tile) );\n                }\n\n                vec3 r = vec3(b) - f + hash13( c );\n                float d = dot(r, r);\n\n                if(d < res) {\n                    res = d;\n                }\n            }\n        }\n    }\n\n    return 1.-res;\n}\n\nfloat tilableVoronoi( vec3 p, const int octaves, float tile ) {\n    float f = 1.;\n    float a = 1.;\n    float c = 0.;\n    float w = 0.;\n\n    if( tile > 0. ) f = tile;\n\n    for( int i=0; i<octaves; i++ ) {\n        c += a*voronoi( p * f, f );\n        f *= 2.0;\n        w += a;\n        a *= 0.5;\n    }\n\n    return c / w;\n}\n\nfloat tilableFbm( vec3 p, const int octaves, float tile ) {\n    float f = 1.;\n    float a = 1.;\n    float c = 0.;\n    float w = 0.;\n\n    if( tile > 0. ) f = tile;\n\n    for( int i=0; i<octaves; i++ ) {\n        c += a*valueNoise( p * f, f );\n        f *= 2.0;\n        w += a;\n        a *= 0.5;\n    }\n\n    return c / w;\n}\n\n",
        "name": "Common",
        "description": "",
        "type": "common"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// Buffer A: The main look-up texture for the cloud shapes. \n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\n// \nbool resolutionChanged() {\n    return floor(texelFetch(iChannel1, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    if (resolutionChanged()) {\n        vec2 vUV = fragCoord / iResolution.xy;\n        vec3 coord = fract(vec3(vUV + vec2(.2,0.62), .5));\n        \n        vec4 col = vec4(1);\n        \n        float mfbm = 0.9;\n        float mvor = 0.7;\n        \n        col.r = mix(1., tilableFbm( coord, 7, 4. ), mfbm) * \n            \tmix(1., tilableVoronoi( coord, 8, 9. ), mvor);\n        col.g = 0.625 * tilableVoronoi( coord + 0., 3, 15. ) +\n        \t\t0.250 * tilableVoronoi(  coord + 0., 3, 19. ) +\n        \t\t0.125 * tilableVoronoi( coord + 0., 3, 23. ) \n            \t-1.;\n        col.b = 1. - tilableVoronoi( coord + 0.5, 6, 9. );\n        \n\t    fragColor = col;\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XsXGR8",
            "channel": 0
          }
        ],
        "code": "// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// Buffer A: The main look-up texture for the cloud shapes. \n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\n// \nbool resolutionChanged() {\n    return floor(texelFetch(iChannel1, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    if (resolutionChanged()) {\n        // pack 32x32x32 3d texture in 2d texture (with padding)\n        float z = floor(fragCoord.x/34.) + 8.*floor(fragCoord.y/34.);\n        vec2 uv = mod(fragCoord.xy, 34.) - 1.;\n        vec3 coord = vec3(uv, z) / 32.;\n\n        float r = tilableVoronoi( coord, 16,  3. );\n        float g = tilableVoronoi( coord,  4,  8. );\n        float b = tilableVoronoi( coord,  4, 16. );\n\n        float c = max(0., 1.-(r + g * .5 + b * .25) / 1.75);\n\n        fragColor = vec4(c,c,c,c);\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}",
        "name": "Buffer B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4sXGR8",
            "channel": 0
          }
        ],
        "code": "// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n//\n// To create an interesting scene and to add some scale to the clouds, I render a \n// terrain using a simple heightmap, based on the work by \u00cd\u00f1igo Qu\u00edlez on value noise and its \n// analytical derivatives.[3]\n//\n// In fact, the heightmap of this shader is almost exactly the same as the heightmap that \n// is used in \u00cd\u00f1igo Qu\u00edlez' shader Elevated:\n//\n// https://www.shadertoy.com/view/MdX3Rr\n//\n// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain \n// (Buffer C)) separatly. The temporal reprojection code is based on code from the shader\n// \"Rain Forest\" (again by \u00cd\u00f1igo Qu\u00edlez):\n//\n// https://www.shadertoy.com/view/4ttSWf\n// \nvec3 noised( in vec2 x ) {\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    vec2 p = vec2(floor(x));\n    float a = hash12( (p+vec2(0,0)) );\n\tfloat b = hash12( (p+vec2(1,0)) );\n\tfloat c = hash12( (p+vec2(0,1)) );\n\tfloat d = hash12( (p+vec2(1,1)) );\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat terrainMap( in vec2 x, const int OCTAVES ) {\n\tvec2 p = x*(MOUNTAIN_HW_RATIO*SCENE_SCALE);\n    float s = mix(1., smoothstep(.0,.4, abs(p.y)), .75);\n    \n    float a = 0.;\n    float b = 1.;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<OCTAVES; i++ ) {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p;\n    }\n\treturn s*a*(MOUNTAIN_HEIGHT*INV_SCENE_SCALE*.5);\n}\n\nfloat terrainMapB( in vec2 x, const int OCTAVES ) {\n\tvec2 p = x*(MOUNTAIN_HW_RATIO*SCENE_SCALE);\n    float s = mix(1., smoothstep(.0,.4, abs(p.y)), .75);\n    \n    float a = 0.;\n    float b = 1.;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<OCTAVES; i++ ) {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p;\n    }\n\treturn s*a*(MOUNTAIN_HEIGHT*INV_SCENE_SCALE*.5);\n}\nvec3 calcNormal(in vec3 pos, float t, const int OCTAVES) {\n    vec2  eps = vec2( (0.0015)*t, 0.0 );\n    return normalize( vec3( terrainMap(pos.xz-eps.xy, OCTAVES) - terrainMap(pos.xz+eps.xy, OCTAVES),\n                            2.0*eps.x,\n                            terrainMap(pos.xz-eps.yx, OCTAVES) - terrainMap(pos.xz+eps.yx, OCTAVES) ) );\n}\n\nvec4 render( in vec3 ro, in vec3 rd ) {\n\tvec3 col, bgcol;\n    \n    float tmax = 10000.;\n    // bouding top plane\n    float topd = ((MOUNTAIN_HEIGHT*INV_SCENE_SCALE)-ro.y)/rd.y;\n    if( rd.y > 0.0 && topd > 0.0 ) {\n        tmax = min(tmax, topd);\n    }\n    \n    // intersect with heightmap\n    float t = 1.;\n\tfor( int i=0; i<128; i++ ) {\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainMap( pos.xz, 7 );\n        if(abs(h)<(0.003*t) || t>tmax ) break; // use abs(h) to bounce back if under terrain\n\t    t += .9 * h;\n\t}\n   \t\n    bgcol = col = getSkyColor(rd);\n\tif( t<tmax) {\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, 15);\n           \n        // terrain color - just back and white\n        float s = smoothstep(0.5,0.9,dot(nor, vec3(.3,1.,0.05)));\n        col = mix( vec3(.01), vec3(0.5,0.52,0.6), smoothstep(.1,.7,s ));\n\t\t\n        // lighting\t\n        // shadow is calculated based on the slope of a low frequency version of the heightmap\n        float shadow = .5 + clamp( -8.+ 16.*dot(SUN_DIR, calcNormal(pos, t, 5)), 0.0, .5 );\n        shadow *= smoothstep(20.,80.,pos.y);\n        \n        float ao = terrainMap(pos.xz, 10)-terrainMap(pos.xz,7);\n        ao = clamp(.25 + ao / (MOUNTAIN_HEIGHT*INV_SCENE_SCALE) * 200., 0., 1.);\n\n        float ambient  = max(0.5+0.5*nor.y,0.0);\n\t\tfloat diffuse  = max(dot(SUN_DIR, nor), 0.0);\n\t\tfloat backlight = max(0.5 + 0.5*dot( normalize( vec3(-SUN_DIR.x, 0., SUN_DIR.z)), nor), 0.0);\n\t \t\n        //\n        // use a 3-light setup as described by \u00cd\u00f1igo Qu\u00edlez\n        // http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n        //\n\t\tvec3 lin = (diffuse*shadow*3.) * SUN_COLOR;\n\t\tlin += (ao*ambient)*vec3(0.40,0.60,1.00);\n        lin += (backlight)*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        col *= (.6+.4*smoothstep(400.,100.,abs(pos.z))); // dark in the distance\n    \n        // height based fog, see http://iquilezles.org/www/articles/fog/fog.htm\n        float fogAmount = HEIGHT_BASED_FOG_C * (1.-exp( -t*rd.y*HEIGHT_BASED_FOG_B))/rd.y;\n        col = mix( col, bgcol, fogAmount);\n    } else {\n        t = 10000.;\n    }\n\n\treturn vec4( col, t );\n}\n\n\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel1, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nbool mouseChanged() {\n    return iMouse.z * texelFetch(iChannel1, ivec2(1,0), 1).w < 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if( letterBox(fragCoord, iResolution.xy, 2.25) ) {\n        fragColor = vec4( 0., 0., 0., 1. );\n        return;\n    } else {\n        vec3 ro, rd;\n        vec3 o = hash33( vec3(fragCoord,iFrame) ) - 0.5; // dither\n        getRay( iTime, (fragCoord+o.xy), iResolution.xy, iMouse/iResolution.xyxy, ro, rd);\n\n        vec4 res = render( ro + rd*o.z, rd );\n\n        vec2 spos = reprojectPos(ro+rd*res.w, iResolution.xy, iChannel1);\n        spos -= o.xy/iResolution.xy; // undo dither\n        \n        vec2 rpos = spos * iResolution.xy;\n        \n        if( !letterBox(rpos.xy, iResolution.xy, 2.3) \n            && !resolutionChanged() && !mouseChanged()) {\n            vec4 ocol = texture( iChannel0, spos, 0.0 );\n            res.rgb = mix(max(ocol.rgb,vec3(0)), res.rgb, .125);\n        }\n\n        fragColor = res;\n    }\n}",
        "name": "Buffer C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XdfGR8",
            "channel": 0
          }
        ],
        "code": "// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// I started this shader by trying to implement the clouds of Horizon Zero Dawn, as\n// described in \"The real-time volumetric cloudscapes of Horizon Zero Dawn\" by \n// Andrew Schneider and Nathan Vos.[1] To model the shape of the clouds, two look-up\n// textures are created with different frequencies of (Perlin -) Worley noise:\n//\n// Buffer A: The main look-up texture for the cloud shapes. \n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\n//           \n// Because it is not possible (yet) to create buffers with fixed size, or 3D buffers, the\n// look-up texture in Buffer A is 2D, and a slice of the volume that is described in the \n// article. Therefore, and because I didn't have any slots left (in Buffer C) to use a \n// cloud type/cloud coverage texture, the modelling of the cloud shapes in this shader is \n// in the end mostly based on trial and error, and is probably far from the code used in \n// Horizon Zero Dawn.\n//\n// Buffer D: Rendering of the clouds.\n//\n// I render the clouds using the improved integration method of volumetric media, as described \n// in \"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\" by \n// S\u00e9bastien Hillaire.[2]\n//\n// You can find the (excellent) example shaders of S\u00e9bastien Hillaire (SebH) here:\n//\n// https://www.shadertoy.com/view/XlBSRz\n// https://www.shadertoy.com/view/MdlyDs\n//\n#define CLOUD_MARCH_STEPS 12\n#define CLOUD_SELF_SHADOW_STEPS 6\n\n#define EARTH_RADIUS    (1500000.) // (6371000.)\n#define CLOUDS_BOTTOM   (1350.)\n#define CLOUDS_TOP      (2150.)\n\n#define CLOUDS_LAYER_BOTTOM   (-150.)\n#define CLOUDS_LAYER_TOP      (-70.)\n\n#define CLOUDS_COVERAGE (.52)\n#define CLOUDS_LAYER_COVERAGE (.41)\n\n#define CLOUDS_DETAIL_STRENGTH (.2)\n#define CLOUDS_BASE_EDGE_SOFTNESS (.1)\n#define CLOUDS_BOTTOM_SOFTNESS (.25)\n#define CLOUDS_DENSITY (.03)\n#define CLOUDS_SHADOW_MARGE_STEP_SIZE (10.)\n#define CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE (4.)\n#define CLOUDS_SHADOW_MARGE_STEP_MULTIPLY (1.3)\n#define CLOUDS_FORWARD_SCATTERING_G (.8)\n#define CLOUDS_BACKWARD_SCATTERING_G (-.2)\n#define CLOUDS_SCATTERING_LERP (.5)\n\n#define CLOUDS_AMBIENT_COLOR_TOP (vec3(149., 167., 200.)*(1.5/255.))\n#define CLOUDS_AMBIENT_COLOR_BOTTOM (vec3(39., 67., 87.)*(1.5/255.))\n#define CLOUDS_MIN_TRANSMITTANCE .1\n\n#define CLOUDS_BASE_SCALE 1.51\n#define CLOUDS_DETAIL_SCALE 20.\n\n//\n// Cloud shape modelling and rendering \n//\nfloat HenyeyGreenstein( float sundotrd, float g) {\n\tfloat gg = g * g;\n\treturn (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);\n}\n\nfloat interectCloudSphere( vec3 rd, float r ) {\n    float b = EARTH_RADIUS * rd.y;\n    float d = b * b + r * r + 2. * EARTH_RADIUS * r;\n    return -b + sqrt( d );\n}\n\nfloat linearstep( const float s, const float e, float v ) {\n    return clamp( (v-s)*(1./(e-s)), 0., 1. );\n}\n\nfloat linearstep0( const float e, float v ) {\n    return min( v*(1./e), 1. );\n}\n\nfloat remap(float v, float s, float e) {\n\treturn (v - s) / (e - s);\n}\n\nfloat cloudMapBase(vec3 p, float norY) {\n\tvec3 uv = p * (0.00005 * CLOUDS_BASE_SCALE);\n    vec3 cloud = texture(iChannel0, uv.xz).rgb;\n   \n    float n = norY*norY;\n    n *= cloud.b ;\n        n+= pow(1.-norY, 16.); \n\treturn remap( cloud.r - n, cloud.g, 1.);\n}\n\nfloat cloudMapDetail(vec3 p) { \n    // 3d lookup in 2d texture :(\n    p = abs(p) * (0.0016 * CLOUDS_BASE_SCALE * CLOUDS_DETAIL_SCALE);\n  \n    float yi = mod(p.y,32.);\n    ivec2 offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;\n    float a = texture(iChannel3, (mod(p.xz,32.)+vec2(offset.xy)+1.)/iResolution.xy).r;\n    \n    yi = mod(p.y+1.,32.);\n    offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;\n    float b = texture(iChannel3, (mod(p.xz,32.)+vec2(offset.xy)+1.)/iResolution.xy).r;\n    \n    return mix(a,b,fract(p.y));\n}\n\nfloat cloudGradient( float norY ) {\n    return linearstep( 0., .05, norY ) - linearstep( .8, 1.2, norY);\n}\n\nfloat cloudMap(vec3 pos, vec3 rd, float norY) {\n    vec3 ps = pos;\n    \n    float m = cloudMapBase(ps, norY);\n\tm *= cloudGradient( norY );\n\n\tfloat dstrength = smoothstep(1., 0.5, m);\n    \n    // erode with detail\n    if(dstrength > 0.) {\n\t\tm -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;\n    }\n\n\tm = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(CLOUDS_COVERAGE-1.) );\n    m *= linearstep0(CLOUDS_BOTTOM_SOFTNESS, norY);\n\n    return clamp(m * CLOUDS_DENSITY * (1.+max((ps.x-7000.)*0.005,0.)), 0., 1.);\n}\n\nfloat volumetricShadow(in vec3 from, in float sundotrd ) {\n    float dd = CLOUDS_SHADOW_MARGE_STEP_SIZE;\n    vec3 rd = SUN_DIR;\n    float d = dd * .5;\n    float shadow = 1.0;\n\n    for(int s=0; s<CLOUD_SELF_SHADOW_STEPS; s++) {\n        vec3 pos = from + rd * d;\n        float norY = (length(pos) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM));\n\n        if(norY > 1.) return shadow;\n\n        float muE = cloudMap( pos, rd, norY );\n        shadow *= exp(-muE * dd);\n\n        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;\n        d += dd;\n    }\n    return shadow;\n}\n\nvec4 renderClouds( vec3 ro, vec3 rd, inout float dist ) {\n    if( rd.y < 0. ) {\n        return vec4(0,0,0,10);\n    }\n\n    ro.xz *= SCENE_SCALE;\n    ro.y = sqrt(EARTH_RADIUS*EARTH_RADIUS-dot(ro.xz,ro.xz));\n\n    float start = interectCloudSphere( rd, CLOUDS_BOTTOM );\n    float end  = interectCloudSphere( rd, CLOUDS_TOP );\n    \n    if (start > dist) {\n        return vec4(0,0,0,10);\n    }\n    \n    end = min(end, dist);\n    \n    float sundotrd = dot( rd, -SUN_DIR);\n\n    // raymarch\n    float d = start;\n    float dD = (end-start) / float(CLOUD_MARCH_STEPS);\n\n    float h = hash13(rd + fract(iTime) );\n    d -= dD * h;\n\n    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),\n        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );\n\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n\n    dist = EARTH_RADIUS;\n\n    for(int s=0; s<CLOUD_MARCH_STEPS; s++) {\n        vec3 p = ro + d * rd;\n\n        float norY = clamp( (length(p) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM)), 0., 1.);\n\n        float alpha = cloudMap( p, rd, norY );\n\n        if( alpha > 0. ) {\n            dist = min( dist, d);\n            vec3 ambientLight = mix( CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, norY );\n\n            vec3 S = (ambientLight + SUN_COLOR * (scattering * volumetricShadow(p, sundotrd))) * alpha;\n            float dTrans = exp(-alpha * dD);\n            vec3 Sint = (S - S * dTrans) * (1. / alpha);\n            scatteredLight += transmittance * Sint; \n            transmittance *= dTrans;\n        }\n\n        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;\n\n        d += dD;\n    }\n\n    return vec4(scatteredLight, transmittance);\n}\n\n//\n//\n// !Because I wanted a second cloud layer (below the horizon), I copy-pasted \n// almost all of the code above:\n//\n\nfloat cloudMapLayer(vec3 pos, vec3 rd, float norY) {\n    vec3 ps = pos;\n\n    float m = cloudMapBase(ps, norY);\n\t// m *= cloudGradient( norY );\n\tfloat dstrength = smoothstep(1., 0.5, m);\n    \n    // erode with detail\n    if (dstrength > 0.) {\n\t\tm -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;\n    }\n\n\tm = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(CLOUDS_LAYER_COVERAGE-1.) );\n\n    return clamp(m * CLOUDS_DENSITY, 0., 1.);\n}\n\nfloat volumetricShadowLayer(in vec3 from, in float sundotrd ) {\n    float dd = CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE;\n    vec3 rd = SUN_DIR;\n    float d = dd * .5;\n    float shadow = 1.0;\n\n    for(int s=0; s<CLOUD_SELF_SHADOW_STEPS; s++) {\n        vec3 pos = from + rd * d;\n        float norY = clamp( (pos.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);\n\n        if(norY > 1.) return shadow;\n\n        float muE = cloudMapLayer( pos, rd, norY );\n        shadow *= exp(-muE * dd);\n\n        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;\n        d += dd;\n    }\n    return shadow;\n}\n\nvec4 renderCloudLayer( vec3 ro, vec3 rd, inout float dist ) {\n    if( rd.y > 0. ) {\n        return vec4(0,0,0,10);\n    }\n\n    ro.xz *= SCENE_SCALE;\n    ro.y = 0.;\n\n    float start = CLOUDS_LAYER_TOP/rd.y;\n    float end  = CLOUDS_LAYER_BOTTOM/rd.y;\n    \n    if (start > dist) {\n        return vec4(0,0,0,10);\n    }\n    \n    end = min(end, dist);\n    \n    float sundotrd = dot( rd, -SUN_DIR);\n\n    // raymarch\n    float d = start;\n    float dD = (end-start) / float(CLOUD_MARCH_STEPS);\n\n    float h = hash13(rd + fract(iTime) );\n    d -= dD * h;\n\n    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),\n        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );\n\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n\n    dist = EARTH_RADIUS;\n\n    for(int s=0; s<CLOUD_MARCH_STEPS; s++) {\n        vec3 p = ro + d * rd;\n\n        float norY = clamp( (p.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);\n\n        float alpha = cloudMapLayer( p, rd, norY );\n\n        if( alpha > 0. ) {\n            dist = min( dist, d);\n            vec3 ambientLight = mix( CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, norY );\n\n            vec3 S = .7 * (ambientLight +  SUN_COLOR * (scattering * volumetricShadowLayer(p, sundotrd))) * alpha;\n            float dTrans = exp(-alpha * dD);\n            vec3 Sint = (S - S * dTrans) * (1. / alpha);\n            scatteredLight += transmittance * Sint; \n            transmittance *= dTrans;\n        }\n\n        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;\n\n        d += dD;\n    }\n\n    return vec4(scatteredLight, transmittance);\n}\n\n//\n// Main function\n//\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel1, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nbool mouseChanged() {\n    return iMouse.z * texelFetch(iChannel1, ivec2(1,0), 1).w < 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {            \n    if (fragCoord.y < 1.5) {\n        fragColor = saveCamera(iTime, fragCoord, iMouse/iResolution.xyxy);\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4(iMouse);\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = mouseChanged() ? vec4(0) : vec4(iResolution.xy,0,0);\n    } else {\n        if( letterBox(fragCoord, iResolution.xy, 2.25) ) {\n        \tfragColor = vec4( 0., 0., 0., 1. );\n       \t\treturn;\n        } else {\n            float dist = texelFetch(iChannel2, ivec2(fragCoord),0).w * SCENE_SCALE;\n            vec4 col = vec4(0,0,0,1);\n            \n            vec3 ro, rd;\n    \t\tgetRay( iTime, fragCoord, iResolution.xy, iMouse/iResolution.xyxy, ro, rd);\n\n            if( rd.y > 0. ) {\n                // clouds\n                col = renderClouds(ro, rd, dist);\n                float fogAmount = 1.-(.1 + exp(-dist*0.0001));\n                col.rgb = mix(col.rgb, getSkyColor(rd)*(1.-col.a), fogAmount);\n            } else {\n                // cloud layer below horizon\n                col = renderCloudLayer(ro, rd, dist);\n                // height based fog, see http://iquilezles.org/www/articles/fog/fog.htm\n                float fogAmount = HEIGHT_BASED_FOG_C * \n                    (1.-exp( -dist*rd.y*(INV_SCENE_SCALE*HEIGHT_BASED_FOG_B)))/rd.y;\n                col.rgb = mix(col.rgb, getSkyColor(rd)*(1.-col.a), clamp(fogAmount,0.,1.));\n            }\n\n            if( col.w > 1. ) {\n                fragColor = vec4(0,0,0,1);\n            } else {\n                vec2 spos = reprojectPos(ro+rd*dist, iResolution.xy, iChannel1);\n                vec2 rpos = spos * iResolution.xy;\n\n        \t\tif( !letterBox(rpos.xy, iResolution.xy, 2.3) \n                    && !resolutionChanged() && !mouseChanged()) {\n                    vec4 ocol = texture( iChannel1, spos, 0.0 ).xyzw;\n                    col = mix(ocol, col, 0.05);\n                }\n                fragColor = col;\n            }\n        }\n    }\n}",
        "name": "Buffer D",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "Can't compare the before-and-after versions, but the (salt-like) graininess following each abrupt view change gradually disappears, leaving lovely clouds.  The convergence rate may depend on display resolution; who knows?",
        "date": "1540135995",
        "username": "dr2",
        "userpicture": "/img/profile.jpg",
        "id": "ldffDj",
        "hidden": 0
      },
      {
        "text": "Beautiful clouds and sky, your first time but still AMAZING!",
        "date": "1537064202",
        "username": "visuality",
        "userpicture": "/media/users/visuality/profile.jpeg",
        "id": "MsXBW7",
        "hidden": 0
      },
      {
        "text": "@dr2: I have changed the look-up in the detail map to linear interpolation. This should fix the noise artefacts on high-resolution displays.",
        "date": "1536142584",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "MssBD8",
        "hidden": 0
      },
      {
        "text": "360 at [video]https://www.youtube.com/watch?v=TZGtQq3_XJI[/video]",
        "date": "1534572566",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "4slBRM",
        "hidden": 0
      },
      {
        "text": "wow :-)",
        "date": "1529068982",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "MsjcDw",
        "hidden": 0
      },
      {
        "text": "Thanks for all the nice comments!\n\n@dr2: I'm on holidays with my laptop, so I can't see how the detail of the clouds look on 4K. The problem is (probably) that I use texelFetch without any form of interpolation for the 3D lookup (line 107 in buffer C - to keep the shader a bit fast). If I could precompute 3D buffers I would use a linear lookup (and mipmaps).\n\nI've added mouse-control to look around. Enjoy :)",
        "date": "1528021991",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "4d2cD1",
        "hidden": 0
      },
      {
        "text": "I really love your clouds ! Like REALLY",
        "date": "1527862016",
        "username": "Draedrus",
        "userpicture": "/media/users/Draedrus/profile.png",
        "id": "MsSyW1",
        "hidden": 0
      },
      {
        "text": "Inspiring image.\n\nBut on my 4K display the clouds seem to have a bit too much high frequency (anisotropic) noise - this observation may be subjective and/or display-dependent.\n\nAnd I support the idea of mouse-controlled view (just a few lines...) :)",
        "date": "1527851066",
        "username": "dr2",
        "userpicture": "/img/profile.jpg",
        "id": "MsByDh",
        "hidden": 0
      },
      {
        "text": "Thanks! @P_Malin, I have added your suggestion.",
        "date": "1527797443",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "MsSyWh",
        "hidden": 0
      },
      {
        "text": "Another great shader reinder!\n\n@flockaroo, @reinder - I see the black pixels too (when fullscreen). It looks like it could be some NaNs propagating when reprojected. For me it is fixed if I add this at line 147 in Buf C: \n\nocol = max( vec4(0), ocol );",
        "date": "1527780958",
        "username": "P_Malin",
        "userpicture": "/media/users/P_Malin/profile.jpeg",
        "id": "4dScD1",
        "hidden": 0
      },
      {
        "text": "Stunning! Great work!",
        "date": "1527765506",
        "username": "Pr0fed",
        "userpicture": "/media/users/Pr0fed/profile.png",
        "id": "4dByD1",
        "hidden": 0
      },
      {
        "text": "Very nice!",
        "date": "1527723187",
        "username": "Duke",
        "userpicture": "/img/profile.jpg",
        "id": "XsScW1",
        "hidden": 0
      },
      {
        "text": "Congrats on Shader of the Week!",
        "date": "1527720386",
        "username": "PlNG",
        "userpicture": "/img/profile.jpg",
        "id": "4sByW1",
        "hidden": 0
      },
      {
        "text": "The little guy makes this epic shader MORE EPIC!! :love:",
        "date": "1527710588",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "4sSyW1",
        "hidden": 0
      },
      {
        "text": "Masterpiece!",
        "date": "1527702332",
        "username": "starea",
        "userpicture": "/media/users/starea/profile.jpeg",
        "id": "4dBcDh",
        "hidden": 0
      },
      {
        "text": "Marvelous!",
        "date": "1527696690",
        "username": "tigertang",
        "userpicture": "/img/profile.jpg",
        "id": "4dByDh",
        "hidden": 0
      },
      {
        "text": "looks amazing",
        "date": "1527681176",
        "username": "kuvkar",
        "userpicture": "/media/users/kuvkar/profile.png",
        "id": "XdScWh",
        "hidden": 0
      },
      {
        "text": "this is super cool!\ni seem to have strange black artifacts bleeding out from a horizontal line (y position about 1/3 screen height), though...",
        "date": "1527678636",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "4dSyWh",
        "hidden": 0
      },
      {
        "text": "Haha! Wow. So pleased to see my humanoid used in such an amazing scene!",
        "date": "1527671926",
        "username": "TekF",
        "userpicture": "/media/users/TekF/profile.png",
        "id": "MdjcDz",
        "hidden": 0
      },
      {
        "text": "Fantastic very realistic !",
        "date": "1527670207",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "Md2yDz",
        "hidden": 0
      },
      {
        "text": "Amazing job!",
        "date": "1527658367",
        "username": "tehsauce",
        "userpicture": "/media/users/tehsauce/profile.jpeg",
        "id": "ldjyDz",
        "hidden": 0
      },
      {
        "text": "So beautiful Himalayas!!!",
        "date": "1527655902",
        "username": "rcrookie",
        "userpicture": "/media/users/rcrookie/profile.jpeg",
        "id": "Ms2cWz",
        "hidden": 0
      },
      {
        "text": "what PING says!  love it",
        "date": "1527648535",
        "username": "EvilRyu",
        "userpicture": "/media/users/EvilRyu/profile.jpeg",
        "id": "Md2cWz",
        "hidden": 0
      },
      {
        "text": "I like the small man!",
        "date": "1527647095",
        "username": "iY0Yi",
        "userpicture": "/media/users/iY0Yi/profile.jpeg",
        "id": "ld2cWz",
        "hidden": 0
      },
      {
        "text": ":love: Beautiful scene. It runs well too.",
        "date": "1527644408",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "MsjcWz",
        "hidden": 0
      },
      {
        "text": "Amazing clouds!",
        "date": "1527635677",
        "username": "mmerchante",
        "userpicture": "/media/users/mmerchante/profile.jpeg",
        "id": "MdjcWz",
        "hidden": 0
      },
      {
        "text": "majestic\n",
        "date": "1527626806",
        "username": "akhgary",
        "userpicture": "/img/profile.jpg",
        "id": "Md2yWz",
        "hidden": 0
      },
      {
        "text": "you sir are a gentleman and a scholar!",
        "date": "1527624845",
        "username": "valentingalea",
        "userpicture": "/img/profile.jpg",
        "id": "ld2yWz",
        "hidden": 0
      },
      {
        "text": "Superb!",
        "date": "1527618274",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "Ms2cDR",
        "hidden": 0
      },
      {
        "text": "very cool, but we want to control the camera ! :-)\n( and autoplay when not )",
        "date": "1527615661",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Md2cDR",
        "hidden": 0
      },
      {
        "text": "Awesome !",
        "date": "1527614219",
        "username": "XT95",
        "userpicture": "/media/users/XT95/profile.png",
        "id": "ld2cDR",
        "hidden": 0
      },
      {
        "text": "Holy crap there's a little dude!",
        "date": "1527610838",
        "username": "PlNG",
        "userpicture": "/img/profile.jpg",
        "id": "lsjcDR",
        "hidden": 0
      },
      {
        "text": "Awesome!",
        "date": "1527602083",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "MsjyDR",
        "hidden": 0
      },
      {
        "text": "It looks gorgeous, I love the little alpinist, so few pixels but so much impact.  ",
        "date": "1527600384",
        "username": "blackjero",
        "userpicture": "/img/profile.jpg",
        "id": "MdjyDR",
        "hidden": 0
      },
      {
        "text": "It could be a photo, amazing work.",
        "date": "1527600039",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "ldjyDR",
        "hidden": 0
      },
      {
        "text": "Wow Wow Wow",
        "date": "1527599057",
        "username": "duvengar",
        "userpicture": "/img/profile.jpg",
        "id": "Ms2cWR",
        "hidden": 0
      },
      {
        "text": "brilliant ! +1 for \"a small humanoid is added\" ^^",
        "date": "1527596653",
        "username": "nicoptere",
        "userpicture": "/img/profile.jpg",
        "id": "ls2cWR",
        "hidden": 0
      },
      {
        "text": "Looks really cool! The hiker is a nice touch. Why the black bands though?",
        "date": "1527596501",
        "username": "Klems",
        "userpicture": "/media/users/Klems/profile.png",
        "id": "Md2cWR",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "MdX3Rr",
      "date": "1360495251",
      "viewed": 123122,
      "name": "Elevated",
      "username": "iq",
      "description": "A raymarched version of the demo Elevated from 2009.",
      "likes": 532,
      "published": 3,
      "flags": 32,
      "tags": [
        "procedural",
        "3d",
        "raymarching",
        "distancefield",
        "terrain",
        "motionblur",
        "vr"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// on the derivatives based noise: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n// on the soft shadow technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// on the fog calculations: http://iquilezles.org/www/articles/fog/fog.htm\n// on the lighting: http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// on the raymarching: http://iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n\n    vec3 col = vec3(0.0);\n    if( data.w < 0.0 )\n    {\n        col = data.xyz;\n    }\n    else\n    {\n        // decompress velocity vector\n        float ss = mod(data.w,256.0)/255.0;\n        float st = floor(data.w/256.0)/255.0;\n\n        // motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col = vec3(0.0);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)/31.0;\n            vec2 pos = uv + dir*h;\n            col += texture( iChannel0, pos ).xyz;\n        }\n        col /= 32.0;\n    }\n    \n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4dXGzn",
            "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
            "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// on the derivatives based noise: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n// on the soft shadow technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// on the fog calculations: http://iquilezles.org/www/articles/fog/fog.htm\n// on the lighting: http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// on the raymarching: http://iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\n\n\n#define AA 1   // make this 2 or even 3 if you have a really powerful GPU\n\n\n#define SC (250.0)\n\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n\nfloat terrainH( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<15; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn SC*120.0*a;\n}\n\nfloat terrainM( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn SC*120.0*a;\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn SC*120.0*a;\n}\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<300; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( abs(h)<(0.002*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainM( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y>(SC*200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0 ).x;\n    return f/0.9375;\n}\n\nconst float kMaxT = 5000.0*SC;\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    // bounding plane\n    float tmin = 1.0;\n    float tmax = kMaxT;\n#if 1\n    float maxh = 300.0*SC;\n    float tp = (maxh-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = interesct( ro, rd, tmin, tmax );\n    if( t>tmax)\n    {\n        // sky\t\t\n        col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n        t = -1.0;\n\t}\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        //nor = normalize( nor + 0.5*( vec3(-1.0,0.0,-1.0) + vec3(2.0,1.0,2.0)*texture(iChannel1,0.01*pos.xz).xyz) );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n        // rock\n\t\tfloat r = texture( iChannel0, (7.0/SC)*pos.xz/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), \n                                     texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)/SC).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\n\t\t// snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y/SC + 25.0*fbm(0.01*pos.xz/SC) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         // lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*SC*0.05,light1);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(7.00,5.00,3.00)*1.3*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,1.00)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        //col += s*0.1*pow(fre,4.0)*vec3(7.0,5.0,3.0)*sh * pow( clamp(dot(nor,hal), 0.0, 1.0),16.0);\n        col += s*\n               (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0))*\n               vec3(7.0,5.0,3.0)*dif*sh*\n               pow( clamp(dot(nor,hal), 0.0, 1.0),16.0);\n        \n        \n        col += s*0.1*pow(fre,4.0)*vec3(0.4,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n\t\t// fog\n        float fo = 1.0-exp(-pow(0.001*t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);// + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n        col = mix( col, fco, fo );\n\n\t}\n    // sun scatter\n    col += 0.3*vec3(1.0,0.7,0.3)*pow( sundot, 8.0 );\n\n    // gamma\n\tcol = sqrt(col);\n    \n\treturn vec4( col, t );\n}\n\nvec3 camPath( float time )\n{\n\treturn SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrainL( ro.xz ) + 19.0*SC;\n\tta.y = ro.y - 20.0*SC;\n\tfloat cr = 0.2*cos(0.1*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.1 - 0.1 + 0.3 + 4.0*iMouse.x/iResolution.x;\n\n    // camera position\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n\n    // camera2world transform    \n    mat3 cam = setCamera( ro, ta, cr );\n\n    // pixel\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    float t = kMaxT;\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 s = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t#else    \n        vec2 s = p;\n\t#endif\n\n        // camera ray    \n        vec3 rd = cam * normalize(vec3(s,fl));\n\n        vec4 res = render( ro, rd );\n        t = min( t, res.w );\n \n        tot += res.xyz;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n\n    //-------------------------------------\n\t// velocity vectors (through depth reprojection)\n    //-------------------------------------\n    float vel = 0.0;\n    if( t<0.0 )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        // old camera position\n        float oldTime = time - 0.1 * 1.0/30.0; // 1/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        // world space\n        #if AA>1\n        vec3 rd = cam * normalize(vec3(p,fl));\n        #endif\n        vec3 wpos = ro + rd*t;\n        // camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        // ndc space\n        vec2 npos = oldFl * cpos.xy / cpos.z;\n        // screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n\n\n        // compress velocity vector in a single float\n        vec2 uv = fragCoord/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*255.0) + floor(spos.y*255.0)*256.0;\n    }\n    \n    fragColor = vec4( tot, vel );\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "The motion blur is awesome!",
        "date": "1551293213",
        "username": "felipunkerito",
        "userpicture": "/img/profile.jpg",
        "id": "ltXyD7",
        "hidden": 0
      },
      {
        "text": "How come I didn't like this shader! Done!",
        "date": "1551293191",
        "username": "felipunkerito",
        "userpicture": "/img/profile.jpg",
        "id": "MlfcW7",
        "hidden": 0
      },
      {
        "text": "Nice servers by the way...",
        "date": "1548008232",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "XsSfDc",
        "hidden": 0
      },
      {
        "text": "Smooths out the camera by averaging the camera position over 1 second in each direction.",
        "date": "1548008207",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "4dSfDc",
        "hidden": 0
      },
      {
        "text": "Smooths out the camera by averaging the camera position over 1 second in each direction.",
        "date": "1548008185",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "XdSfDc",
        "hidden": 0
      },
      {
        "text": "Line 260: [code]\nro.y = 0.;\n    for (float i = -.3; i <= .3; i += .1)\n    {\n\t    ro.y += terrainL( camPath(time + i).xz);\n    }\n    ro.y /= 5.;\n    ro.y += 19.0*SC;\n[/code]",
        "date": "1548008121",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "4sBBDc",
        "hidden": 0
      },
      {
        "text": "360 at [video]https://www.youtube.com/watch?v=tIaiRM0YLuA[/video]",
        "date": "1508250509",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "XlcSWr",
        "hidden": 0
      },
      {
        "text": "This shader is awesome, but i think the extra texture read line 20 is pretty much useless, since the color is already stored in \"data.rgb\".:)",
        "date": "1506209514",
        "username": "stduhpf",
        "userpicture": "/media/users/stduhpf/profile.jpeg",
        "id": "MlG3WV",
        "hidden": 0
      },
      {
        "text": "@iq what did you use to do the 3d render video you posted?  brilliant work as always, learning so much from you.  ",
        "date": "1500028966",
        "username": "MacroMachines",
        "userpicture": "/media/users/MacroMachines/profile.jpeg",
        "id": "4ldGDM",
        "hidden": 0
      },
      {
        "text": "[This comment has been hidden by the shader author]",
        "date": "1494047989",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4sKXzc",
        "hidden": 1
      },
      {
        "text": "I've seen the part of noise derivative in the blog but I was wondering if someone know from where the calculation of a += b*n.x/(1.0+dot(d,d)); (line 91). My understanding is that we use cubic noise interpolation (together with derivatives) and before calculating final noise value we differentiate once more to go from cubic to quintic. Btw what is the\"m2\" matrice? A domain wrapping shift to change the sampled noise position?",
        "date": "1490642789",
        "username": "red1939",
        "userpicture": "/img/profile.jpg",
        "id": "ldGXzw",
        "hidden": 0
      },
      {
        "text": "I rendered a 360 version of this shader, if you are curious to see in your mobile or GearVR headset or something:\r\n\r\n[video]https://www.youtube.com/watch?v=r_6aTdscdZw[/video]",
        "date": "1490397248",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ldVXRD",
        "hidden": 0
      },
      {
        "text": "iq, I find there is flashing in the adjacent frames, especially the areas far away the camera, if there is any method avoid the flashing.",
        "date": "1461669603",
        "username": "webber",
        "userpicture": "/img/profile.jpg",
        "id": "4lSSzW",
        "hidden": 0
      },
      {
        "text": "iq, your work is very inspiring - thank you for sharing it with us!\n",
        "date": "1446072919",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "ltf3W7",
        "hidden": 0
      },
      {
        "text": "fantacy, you are genius",
        "date": "1427776927",
        "username": "liyonghelpme",
        "userpicture": "/img/profile.jpg",
        "id": "4ssSWX",
        "hidden": 0
      },
      {
        "text": "Yeah, it's black for me too. It used to work.",
        "date": "1422269013",
        "username": "TekF",
        "userpicture": "/media/users/TekF/profile.png",
        "id": "MdsSWM",
        "hidden": 0
      },
      {
        "text": "I'm not seeing anything (everything is black) :( I've tried changing some stuff, and it seems that has something to do with the interesct function (if i comment the else i see the mountains but not the sky)\nI'm on chrome at windows 7 with a NVidia GeForce GTX 760",
        "date": "1418417943",
        "username": "bolt304",
        "userpicture": "/img/profile.jpg",
        "id": "4dsXDn",
        "hidden": 0
      },
      {
        "text": "Ohh.. it's fantastic to fly over that snowy mountain landscape...\nEver thought to add a keyboard handling to steer the camera by hand?",
        "date": "1411648091",
        "username": "tholzer",
        "userpicture": "/media/users/tholzer/profile.png",
        "id": "Md23Dd",
        "hidden": 0
      },
      {
        "text": "Incredibly unique! If only there were more comments on the code. :(",
        "date": "1380945003",
        "username": "diegoperini",
        "userpicture": "/img/profile.jpg",
        "id": "4ss3DB",
        "hidden": 0
      },
      {
        "text": "Well, I always wanted to wander in original Elevated - now, I can:\n\n\t//vec3 ro = camPath( time );\n\t//vec3 ta = camPath( time + 3.0 );\n\tvec3 ro = vec3( iMouse.x, 0.0, iMouse.y );\n\tvec3 ta = vec3( iMouse.x, 0.0, iMouse.y + 1000.0 );\n\n:D\n\nThanks!",
        "date": "1378227838",
        "username": "Yosh",
        "userpicture": "/img/profile.jpg",
        "id": "lsf3Rf",
        "hidden": 0
      },
      {
        "text": "wow, how one should do to be this good?",
        "date": "1372763612",
        "username": "bebensiganteng",
        "userpicture": "/img/profile.jpg",
        "id": "lslGW4",
        "hidden": 0
      },
      {
        "text": "This is totally awesome! I wouldn't mind using a picture from this shader as my facebook cover picture.",
        "date": "1372156110",
        "username": "jobromedia",
        "userpicture": "/media/users/jobromedia/profile.png",
        "id": "MsXGWN",
        "hidden": 0
      },
      {
        "text": "Mindoblowing!",
        "date": "1369240457",
        "username": "myk45",
        "userpicture": "/img/profile.jpg",
        "id": "lssGDr",
        "hidden": 0
      },
      {
        "text": "First of all, this is amazing!\n\nAnd being that I can't find anyone asking about this I feel like the odd man out.\nWhere do the numbers in the hash and noise functions come from?? To be specific the 43758.5453123, 57, 113 etc...\n\nI mean they are not even prime numbers.\n\nIf there is a place where this is talked about please point me to it.\nIf these are numbers that where found through experimenting just say so, I could except that as an answer. It would be easy to believe that someone who could make this incredible shader would have a good gut instinct on what magic numbers to use.\n\n",
        "date": "1363274162",
        "username": "ahrimen",
        "userpicture": "/img/profile.jpg",
        "id": "MsX3z8",
        "hidden": 0
      },
      {
        "text": "Thanks for putting together this site!  A wonderful playground for the mind.",
        "date": "1361896009",
        "username": "Mipmap",
        "userpicture": "/img/profile.jpg",
        "id": "ldX3zn",
        "hidden": 0
      },
      {
        "text": "wow++;",
        "date": "1361837780",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "ldf3Rn",
        "hidden": 0
      },
      {
        "text": "wow!!",
        "date": "1361785568",
        "username": "eloinischith",
        "userpicture": "/img/profile.jpg",
        "id": "MsXGRn",
        "hidden": 0
      },
      {
        "text": "Amazing, as usual. ;)",
        "date": "1360980751",
        "username": "jmk",
        "userpicture": "/img/profile.jpg",
        "id": "XdfGRr",
        "hidden": 0
      },
      {
        "text": "Awesome! Good to see the code,thx :)!",
        "date": "1360969732",
        "username": "XT95",
        "userpicture": "/media/users/XT95/profile.png",
        "id": "4sf3zn",
        "hidden": 0
      },
      {
        "text": "Incredibly beautiful! Just awesome!",
        "date": "1360888618",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "4sX3zn",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "MdX3zr",
      "date": "1360969512",
      "viewed": 101273,
      "name": "Flame",
      "username": "XT95",
      "description": "Simple flame in distance field.",
      "likes": 675,
      "published": 3,
      "flags": 0,
      "tags": [
        "3d",
        "distancefield",
        "transparency"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [],
        "code": "float noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n\n",
        "name": "",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Arts!",
        "date": "1553894604",
        "username": "Hongbo_Miao",
        "userpicture": "/media/users/Hongbo_Miao/profile.jpeg",
        "id": "4lXcDX",
        "hidden": 0
      },
      {
        "text": "That was like a year ago and now I know what noise is xD",
        "date": "1541641855",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "Xsjfzh",
        "hidden": 0
      },
      {
        "text": "Also, narrowing the area of raymarching gave me fps boost from 15-20 to 40-50. Though have to be careful not to cut off the flame.\n\nline 56: \nfloat limits = 0.5;\nvec4 p = (v.x > -limits && v.x < limits) ? raymarch(org, dir) : vec4(0.);",
        "date": "1488800109",
        "username": "coldshine",
        "userpicture": "/img/profile.jpg",
        "id": "4sdSDl",
        "hidden": 0
      },
      {
        "text": "Does the numbers in the noise function at line 4 were pre-calculated?",
        "date": "1488664135",
        "username": "coldshine",
        "userpicture": "/img/profile.jpg",
        "id": "ld3SDl",
        "hidden": 0
      },
      {
        "text": "I just have no idea how you could possibly make something so complicated!! Maybe I'm just a newbie at this? :octopus:",
        "date": "1488347558",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "ld3SWf",
        "hidden": 0
      },
      {
        "text": "I've tried this shader in cocos2d-x, it didn't work and the 'raymarch' function made cpu 100% :(",
        "date": "1471425276",
        "username": "sgamerw",
        "userpicture": "/img/profile.jpg",
        "id": "lsd3RB",
        "hidden": 0
      },
      {
        "text": "Very exciting.",
        "date": "1454590667",
        "username": "ss_shader",
        "userpicture": "/img/profile.jpg",
        "id": "4t23D3",
        "hidden": 0
      },
      {
        "text": "So amazing~ \u00f0\u0178\u02dc\u201e",
        "date": "1451459565",
        "username": "leomondream",
        "userpicture": "/img/profile.jpg",
        "id": "llB3WR",
        "hidden": 0
      },
      {
        "text": "Simple yet beautiful.",
        "date": "1445240272",
        "username": "Jack41EL",
        "userpicture": "/img/profile.jpg",
        "id": "Mlf3WN",
        "hidden": 0
      },
      {
        "text": "Very hot :)",
        "date": "1444904508",
        "username": "mememaestro",
        "userpicture": "/img/profile.jpg",
        "id": "Mtl3DH",
        "hidden": 0
      },
      {
        "text": "Very cool work.  That's a lot of trig :-)\nAny suggestions on how to constrain it to the quad itself (so it doesn't have a flat top)?  I've been tinkering but to no avail yet, the noise can push it quite high.",
        "date": "1442370099",
        "username": "davepl",
        "userpicture": "/media/users/davepl/profile.jpeg",
        "id": "Xtl3R4",
        "hidden": 0
      },
      {
        "text": "it's so cool~flame effect is common~but this look real cool~ ",
        "date": "1429939941",
        "username": "arafat5547",
        "userpicture": "/img/profile.jpg",
        "id": "ldjXRz",
        "hidden": 0
      },
      {
        "text": "Hypnotic, so \"realistic\".",
        "date": "1402746920",
        "username": "cyanux",
        "userpicture": "/media/users/cyanux/profile.jpeg",
        "id": "ld2GRK",
        "hidden": 0
      },
      {
        "text": "@revers : Hi, what a great tool you have here ! No problem for using this shader, i'm glad you share it :)!",
        "date": "1392747747",
        "username": "XT95",
        "userpicture": "/media/users/XT95/profile.png",
        "id": "4sBGWR",
        "hidden": 0
      },
      {
        "text": "cool.",
        "date": "1374392217",
        "username": "sumingnan",
        "userpicture": "/img/profile.jpg",
        "id": "4sfGzS",
        "hidden": 0
      },
      {
        "text": "Nice one dude !",
        "date": "1363255604",
        "username": "Eybor",
        "userpicture": "/img/profile.jpg",
        "id": "ldX3z8",
        "hidden": 0
      },
      {
        "text": "so good! lush looking flames - enjoyable and not scary!",
        "date": "1362186311",
        "username": "shabtronic",
        "userpicture": "/img/profile.jpg",
        "id": "4slGzn",
        "hidden": 0
      },
      {
        "text": "Love it!",
        "date": "1361922616",
        "username": "Conan",
        "userpicture": "/img/profile.jpg",
        "id": "MdXGRr",
        "hidden": 0
      },
      {
        "text": "Excellent!",
        "date": "1361323857",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "4sf3Rr",
        "hidden": 0
      },
      {
        "text": "Impressive!",
        "date": "1361010754",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "XsfGRr",
        "hidden": 0
      },
      {
        "text": "Very cool :)",
        "date": "1360974693",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "XdXGRr",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "MddGzf",
      "date": "1451884800",
      "viewed": 41375,
      "name": "Bricks Game",
      "username": "iq",
      "description": "Use arrow keys or the mouse to move the paddle. Use space to restart. This shader uses the new Multipass system",
      "likes": 286,
      "published": 3,
      "flags": 112,
      "tags": [
        "procedural",
        "2d",
        "game",
        "bricks",
        "multipass"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdX3RN",
            "filepath": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03",
            "previewfilepath": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03",
            "type": "musicstream",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//\n// Game rendering. Regular 2D distance field rendering.\n//\n\n\n// storage register/texel addresses\nconst ivec2 txBallPosVel = ivec2(0,0);\nconst ivec2 txPaddlePos  = ivec2(1,0);\nconst ivec2 txPoints     = ivec2(2,0);\nconst ivec2 txState      = ivec2(3,0);\nconst ivec2 txLastHit    = ivec2(4,0);\nconst ivec4 txBricks     = ivec4(0,1,13,12);\n\nconst float ballRadius = 0.035;\nconst float paddleSize = 0.30;\nconst float paddleWidth = 0.06;\nconst float paddlePosY  = -0.90;\nconst float brickW = 2.0/13.0;\nconst float brickH = 1.0/15.0;\n\n//----------------\n\nconst vec2 shadowOffset = vec2(-0.03,0.03);\n\n//=================================================================================================\n// distance functions\n//=================================================================================================\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udHorizontalSegment( in vec2 p, in float xa, in float xb, in float y )\n{\n    vec2 pa = p - vec2(xa,y);\n    float ba = xb - xa;\n    pa.x -= ba*clamp( pa.x/ba, 0.0, 1.0 );\n    return length( pa );\n}\n\nfloat udRoundBox( in vec2 p, in vec2 c, in vec2 b, in float r )\n{\n  return length(max(abs(p-c)-b,0.0))-r;\n}\n\n//=================================================================================================\n// utility\n//=================================================================================================\n\nfloat hash1( in float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\nint PrintInt( in vec2 uv, in int value )\n{\n    const int maxDigits = 3;\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\n//=================================================================================================\n\nfloat doBrick( in ivec2 id, out vec3 col, out float glo, out vec2 cen )\n{\n    float alp = 0.0;\n    \n    glo = 0.0;\n    col = vec3(0.0);\n    cen = vec2(0.0);\n    \n    if( id.x>0 && id.x<13 && id.y>=0 && id.y<12 )\n    {\n        vec2 brickHere = texelFetch( iChannel0, txBricks.xy+id, 0 ).xy;\n\n        alp = 1.0;\n        glo = 0.0;\n        if( brickHere.x < 0.5 )\n        {\n            float t = max(0.0,iTime-brickHere.y-0.1);\n            alp = exp(-2.0*t );\n            glo = exp(-4.0*t );\n        }\n         \n        if( alp>0.001 )\n        {\n            float fid = hash1( float(id.x*3 + id.y*16) );\n            col = vec3(0.5,0.5,0.6) + 0.4*sin( fid*2.0 + 4.5 + vec3(0.0,1.0,1.0) );\n            if( hash1(fid*13.1)>0.85 )\n            {\n                col = 1.0 - 0.9*col;\n                col.xy += 0.2;\n            }\n        }\n        \n        cen = vec2( -1.0 + float(id.x)*brickW + 0.5*brickW,\n                     1.0 - float(id.y)*brickH - 0.5*brickH );\n    }\n\n    return alp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    //------------------------\n    // load game state\n    //------------------------\n    vec2  ballPos   = texelFetch( iChannel0, txBallPosVel, 0 ).xy;\n    float paddlePos = texelFetch( iChannel0, txPaddlePos, 0 ).x;\n    float points    = texelFetch( iChannel0, txPoints, 0 ).x;\n    float state     = texelFetch( iChannel0, txState, 0 ).x;\n    vec3  lastHit   = texelFetch( iChannel0, txLastHit, 0 ).xyz;\n\n    \n    //------------------------\n    // draw\n    //------------------------\n    vec3 col = vec3(0.0);\n    vec3 emi = vec3(0.0);\n    \n    // board\n    {\n        col = 0.6*vec3(0.4,0.6,0.7)*(1.0-0.4*length( uv ));\n        col *= 1.0 - 0.1*smoothstep( 0.0,1.0,sin(uv.x*80.0)*sin(uv.y*80.0))*(1.0 - smoothstep( 1.0, 1.01, abs(uv.x) ) );\n    }    \n\n    // bricks\n    {\n        float b = brickW*0.17;\n\n        // soft shadow\n        {\n            vec2 st = uv + shadowOffset;\n            ivec2 id = ivec2(floor( vec2( (1.0+st.x)/brickW, (1.0-st.y)/brickH) ));\n\n            vec3 bcol; vec2 bcen; float bglo;\n\n            float sha = 0.0;\n            for( int j=-1; j<=1; j++ )\n        \tfor( int i=-1; i<=1; i++ )\n        \t{\n                ivec2 idr = id + ivec2(i, j );\n                float alp = doBrick( idr, bcol, bglo, bcen );\n                float f = udRoundBox( st, bcen, 0.5*vec2(brickW,brickH)-b, b );\n                float s = 1.0 - smoothstep( -brickH*0.5, brickH*1.0, f ); \n                s = mix( 0.0, s, alp );\n                sha = max( sha, s );\n            }\n            col = mix( col, col*0.4, sha );\n        }\n    \n\n        ivec2 id = ivec2(floor( vec2( (1.0+uv.x)/brickW, (1.0-uv.y)/brickH) ));\n        \n        // shape\n        {\n            vec3 bcol; vec2 bcen; float bglo;\n            float alp = doBrick( id, bcol, bglo, bcen );\n            if( alp>0.0001 )\n            {\n                float f = udRoundBox( uv, bcen, 0.5*vec2(brickW,brickH)-b, b );\n                bglo  += 0.6*smoothstep( -4.0*px, 0.0, f );\n\n                bcol *= 0.7 + 0.3*smoothstep( -4.0*px, -2.0*px, f );\n                bcol *= 0.5 + 1.7*bglo;\n                col = mix( col, bcol, alp*(1.0-smoothstep( -px, px, f )) );\n            }\n        }\n        \n        // gather glow\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            ivec2 idr = id + ivec2(i, j );\n            vec3 bcol = vec3(0.0); vec2 bcen; float bglo;\n            float alp = doBrick( idr, bcol, bglo, bcen );\n            float f = udRoundBox( uv, bcen, 0.5*vec2(brickW,brickH)-b, b );\n            emi += bcol*bglo*exp(-600.0*f*f);\n        }\n    }    \n    \n    \n    // ball \n    {\n        float hit = exp(-4.0*(iTime-lastHit.y) );\n\n        // shadow\n        float f = 1.0-smoothstep( ballRadius*0.5, ballRadius*2.0, length( uv - ballPos + shadowOffset ) );\n        col = mix( col, col*0.4, f );\n\n        // shape\n        f = length( uv - ballPos ) - ballRadius;\n        vec3 bcol = vec3(1.0,0.6,0.2);\n        bcol *= 1.0 + 0.7*smoothstep( -3.0*px, -1.0*px, f );\n        bcol *= 0.7 + 0.3*hit;\n        col = mix( col, bcol, 1.0-smoothstep( 0.0, px, f ) );\n        \n        emi  += bcol*0.75*hit*exp(-500.0*f*f );\n    }\n    \n    \n    // paddle\n    {\n        float hit = exp(-4.0*(iTime-lastHit.x) ) * sin(20.0*(iTime-lastHit.x));\n        float hit2 = exp(-4.0*(iTime-lastHit.x) );\n        float y = uv.y + 0.04*hit * (1.0-pow(abs(uv.x-paddlePos)/(paddleSize*0.5),2.0));\n\n        // shadow\n        float f = udHorizontalSegment( vec2(uv.x,y)+shadowOffset, paddlePos-paddleSize*0.5,paddlePos+paddleSize*0.5,paddlePosY );\n        f = 1.0-smoothstep( paddleWidth*0.5*0.5, paddleWidth*0.5*2.0, f );\n        col = mix( col, col*0.4, f );\n\n        // shape\n        f = udHorizontalSegment( vec2(uv.x,y), paddlePos-paddleSize*0.5, paddlePos+paddleSize*0.5,paddlePosY ) - paddleWidth*0.5;\n        vec3 bcol = vec3(1.0,0.6,0.2);\n        bcol *= 1.0 + 0.7*smoothstep( -3.0*px, -1.0*px, f );\n        bcol *= 0.7 + 0.3*hit2;\n        col = mix( col, bcol, 1.0-smoothstep( -px, px, f ) );\n        emi  += bcol*0.75*hit2*exp( -500.0*f*f );\n\n    }\n\n    \n    // borders\n    {\n        float f = abs(abs(uv.x)-1.02);\n        f = min( f, udHorizontalSegment(uv,-1.0,1.0,1.0) );\n        f *= 2.0;\n        float a = 0.8 + 0.2*sin(2.6*iTime) + 0.1*sin(4.0*iTime);\n        float hit  = exp(-4.0*(iTime-lastHit.z) );\n        //\n        a *= 1.0-0.3*hit;\n        col += a*0.5*vec3(0.6,0.30,0.1)*exp(- 30.0*f*f);\n        col += a*0.5*vec3(0.6,0.35,0.2)*exp(-150.0*f*f);\n        col += a*1.7*vec3(0.6,0.50,0.3)*exp(-900.0*f*f);\n    }\n    \n    // score\n    {\n        float f = float(PrintInt( (uv-vec2(-1.5,0.8))*10.0, int(points) ));\n        col = mix( col, vec3(1.0,1.0,1.0), f );\n    }\n    \n    \n    // add emmission\n    col += emi;\n    \n\n    //------------------------\n    // game over\n    //------------------------\n    col = mix( col, vec3(1.0,0.5,0.2), state * (0.5+0.5*sin(30.0*iTime)) );\n\n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4dXGRr",
            "filepath": "/presets/tex00.jpg",
            "previewfilepath": "/presets/tex00.jpg",
            "type": "keyboard",
            "channel": 1,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//\n// Gameplay computation.\n//\n// The gameplay buffer is 14x14 pixels. The whole game is run/played for each one of these\n// pixels. A filter in the end of the shader takes only the bit  of infomration that needs \n// to be stored in each texl of the game-logic texture.\n\n// storage register/texel addresses\nconst ivec2 txBallPosVel = ivec2(0,0);\nconst ivec2 txPaddlePos  = ivec2(1,0);\nconst ivec2 txPoints     = ivec2(2,0);\nconst ivec2 txState      = ivec2(3,0);\nconst ivec2 txLastHit    = ivec2(4,0);\nconst ivec4 txBricks     = ivec4(0,1,13,12);\n\nconst float ballRadius = 0.035;\nconst float paddleSize = 0.30;\nconst float paddleWidth = 0.06;\nconst float paddlePosY  = -0.90;\nconst float brickW = 2.0/13.0;\nconst float brickH = 1.0/15.0;\n\nconst float gameSpeed =  3.0;\nconst float inputSpeed = 2.0;\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\n\n//----------------------------------------------------------------------------------------------\n\nfloat hash1( float n ) { return fract(sin(n)*138.5453123); }\n\n// intersect a disk sweept in a linear segment with a line/plane. \nfloat iPlane( in vec2 ro, in vec2 rd, float rad, vec3 pla )\n{\n    float a = dot( rd, pla.xy );\n    if( a>0.0 ) return -1.0;\n    float t = (rad - pla.z - dot(ro,pla.xy)) / a;\n    if( t>=1.0 ) t=-1.0;\n    return t;\n}\n\n// intersect a disk sweept in a linear segment with a box \nvec3 iBox( in vec2 ro, in vec2 rd, in float rad, in vec2 bce, in vec2 bwi ) \n{\n    vec2 m = 1.0/rd;\n    vec2 n = m*(ro - bce);\n    vec2 k = abs(m)*(bwi+rad);\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n\tfloat tN = max( t1.x, t1.y );\n\tfloat tF = min( t2.x, t2.y );\n\tif( tN > tF || tF < 0.0) return vec3(-1.0);\n    if( tN>=1.0 ) return vec3(-1.0);\n\tvec2 nor = -sign(rd)*step(t1.yx,t1.xy);\n\treturn vec3( tN, nor );\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n \n    // don't compute gameplay outside of the data area\n    if( fragCoord.x > 14.0 || fragCoord.y>14.0 ) discard;\n    \n    //---------------------------------------------------------------------------------   \n\t// load game state\n\t//---------------------------------------------------------------------------------\n    vec4  balPosVel = loadValue( txBallPosVel );\n    float paddlePos = loadValue( txPaddlePos ).x;\n    float points    = loadValue( txPoints ).x;\n    float state     = loadValue( txState ).x;\n    vec3  lastHit   = loadValue( txLastHit ).xyz;        // paddle, brick, wall\n    vec2  brick     = loadValue( ipx ).xy;               // visible, hittime\n\t\n    //---------------------------------------------------------------------------------\n    // reset\n\t//---------------------------------------------------------------------------------\n\tif( iFrame==0 ) state = -1.0;\n\t\n    if( state < -0.5 )\n    {\n        state = 0.0;\n        balPosVel = vec4(0.0,paddlePosY+ballRadius+paddleWidth*0.5+0.001, 0.6,1.0);\n        paddlePos = 0.0;\n        points = 0.0;\n        state = 0.0;\n        brick = vec2(1.0,-5.0);\n        lastHit = vec3(-1.0);\n        \n        \n        if( fragCoord.x<1.0 || fragCoord.x>12.0 )\n        {\n            brick.x = 0.0;\n            brick.y = -10.0;\n        }\n        \n\n    }\n\n    //---------------------------------------------------------------------------------\n    // do game\n    //---------------------------------------------------------------------------------\n\n    // game over (or won), wait for space key press to resume\n    if( state > 0.5 )\n    {\n        float pressSpace = texelFetch( iChannel1, ivec2(KEY_SPACE,0.0), 0 ).x;\n        if( pressSpace>0.5 )\n        {\n            state = -1.0;\n        }\n    }\n    \n    // if game mode (not game over), play game\n    else if( state < 0.5 ) \n\t{\n\n        //-------------------\n        // paddle\n        //-------------------\n        float oldPaddlePos = paddlePos;\n        if( iMouse.w>0.01 )\n        {\n            // move with mouse\n            paddlePos = (-1.0 + 2.0*iMouse.x/iResolution.x)*iResolution.x/iResolution.y;\n        }\n        else\n        {\n            // move with keyboard\n            float moveRight = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x;\n            float moveLeft  = texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x;\n            paddlePos += 0.02*inputSpeed*(moveRight - moveLeft);\n        }\n        paddlePos = clamp( paddlePos, -1.0+0.5*paddleSize+paddleWidth*0.5, 1.0-0.5*paddleSize-paddleWidth*0.5 );\n\n        float moveTotal = sign( paddlePos - oldPaddlePos );\n\n        //-------------------\n        // ball\n\t\t//-------------------\n        float dis = 0.01*gameSpeed*(iTimeDelta*60.0);\n        \n        // do up to 3 sweep collision detections (usually 0 or 1 will happen only)\n        for( int j=0; j<3; j++ )\n        {\n            ivec3 oid = ivec3(-1);\n            vec2 nor;\n            float t = 1000.0;\n\n            // test walls\n            const vec3 pla1 = vec3(-1.0, 0.0,1.0 ); \n            const vec3 pla2 = vec3( 1.0, 0.0,1.0 ); \n            const vec3 pla3 = vec3( 0.0,-1.0,1.0 ); \n            float t1 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla1 ); if( t1>0.0         ) { t=t1; nor = pla1.xy; oid.x=1; }\n            float t2 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla2 ); if( t2>0.0 && t2<t ) { t=t2; nor = pla2.xy; oid.x=2; }\n            float t3 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla3 ); if( t3>0.0 && t3<t ) { t=t3; nor = pla3.xy; oid.x=3; }\n            \n            // test paddle\n            vec3  t4 = iBox( balPosVel.xy, dis*balPosVel.zw, ballRadius, vec2(paddlePos,paddlePosY), vec2(paddleSize*0.5,paddleWidth*0.5) );\n            if( t4.x>0.0 && t4.x<t ) { t=t4.x; nor = t4.yz; oid.x=4;  }\n            \n            // test bricks\n            ivec2 idr = ivec2(floor( vec2( (1.0+balPosVel.x)/brickW, (1.0-balPosVel.y)/brickH) ));\n            ivec2 vs = ivec2(sign(balPosVel.zw));\n            for( int j=0; j<3; j++ )\n            for( int i=0; i<3; i++ )\n            {\n                ivec2 id = idr + ivec2( vs.x*i,-vs.y*j);\n                if( id.x>=0 && id.x<13 && id.y>=0 && id.y<12 )\n                {\n                    float brickHere = texelFetch( iChannel0, (txBricks.xy+id), 0 ).x;\n                    if( brickHere>0.5 )\n                    {\n                        vec2 ce = vec2( -1.0 + float(id.x)*brickW + 0.5*brickW,\n                                         1.0 - float(id.y)*brickH - 0.5*brickH );\n                        vec3 t5 = iBox( balPosVel.xy, dis*balPosVel.zw, ballRadius, ce, 0.5*vec2(brickW,brickH) );\n                        if( t5.x>0.0 && t5.x<t )\n                        {\n                            oid = ivec3(5,id);\n                            t = t5.x;\n                            nor = t5.yz;\n                        }\n                    }\n                }\n            }\n    \n            // no collisions\n            if( oid.x<0 ) break;\n\n            \n            // bounce\n            balPosVel.xy += t*dis*balPosVel.zw;\n            dis *= 1.0-t;\n            \n            // did hit walls\n            if( oid.x<4 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                lastHit.z = iTime;\n            }\n            // did hit paddle\n            else if( oid.x<5 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                // borders bounce back\n                     if( balPosVel.x > (paddlePos+paddleSize*0.5) ) balPosVel.z =  abs(balPosVel.z);\n                else if( balPosVel.x < (paddlePos-paddleSize*0.5) ) balPosVel.z = -abs(balPosVel.z);\n                balPosVel.z += 0.37*moveTotal;\n                balPosVel.z += 0.11*hash1( float(iFrame)*7.1 );\n                balPosVel.z = clamp( balPosVel.z, -0.9, 0.9 );\n                balPosVel.zw = normalize(balPosVel.zw);\n                \n                // \n                lastHit.x = iTime;\n                lastHit.y = iTime;\n            }\n            // did hit a brick\n            else if( oid.x<6 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                lastHit.y = iTime;\n                points += 1.0;\n                if( points>131.5 )\n                {\n                    state = 2.0; // won game!\n                }\n\n                if( ipx == txBricks.xy+oid.yz )\n                {\n                    brick = vec2(0.0, iTime);\n                }\n            }\n        }\n        \n        balPosVel.xy += dis*balPosVel.zw;\n        \n        // detect miss\n        if( balPosVel.y<-1.0 )\n        {\n            state = 1.0; // game over\n        }\n    }\n    \n\t//---------------------------------------------------------------------------------\n\t// store game state\n\t//---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n    \n \n    storeValue( txBallPosVel, vec4(balPosVel),             fragColor, ipx );\n    storeValue( txPaddlePos,  vec4(paddlePos,0.0,0.0,0.0), fragColor, ipx );\n    storeValue( txPoints,     vec4(points,0.0,0.0,0.0),    fragColor, ipx );\n    storeValue( txState,      vec4(state,0.0,0.0,0.0),     fragColor, ipx );\n    storeValue( txLastHit,    vec4(lastHit,0.0),           fragColor, ipx );\n    storeValue( txBricks,     vec4(brick,0.0,0.0),         fragColor, ipx );\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "Yall have got any more of those...\n...BRICKS",
        "date": "1535671765",
        "username": "Quadrizoid",
        "userpicture": "/img/profile.jpg",
        "id": "4sXBWH",
        "hidden": 0
      },
      {
        "text": "Yes, the iOS is kept up to date, it should be working fine: [url]https://itunes.apple.com/us/app/shadertoy/id717961814?mt=8[/url]",
        "date": "1519104279",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4dXyRH",
        "hidden": 0
      },
      {
        "text": "Thank you demofox, your feedback is greatly appreciated. I've noticed that this Shader does not work on the iOS app. After digging into the code, I couldn't tell why. The iOS app does not seems to be maintained and I'm not sure if it did work at some point. Does anyone have some insight on this topic?",
        "date": "1493750673",
        "username": "neosettler",
        "userpicture": "/img/profile.jpg",
        "id": "XdGSR3",
        "hidden": 0
      },
      {
        "text": "I can help with that (:\n32 is the ascii character code for space.  0.5 is added to that because in a texture, the color of a pixel is in the center of the pixel.\nHere are some other ascii character codes if you want to find other keys:\n[url]http://www.asciitable.com/[/url]",
        "date": "1493742160",
        "username": "demofox",
        "userpicture": "/media/users/demofox/profile.jpeg",
        "id": "MsKSzV",
        "hidden": 0
      },
      {
        "text": "Nice work, about this line:\n\nconst float KEY_SPACE = 32.5/256.0;\n\nHow did you come up with 32.5? Could you elaborate on the logic of mapping keyboard keys?",
        "date": "1493741863",
        "username": "neosettler",
        "userpicture": "/img/profile.jpg",
        "id": "lsKSzV",
        "hidden": 0
      },
      {
        "text": "The speed of the player/paddle seems to be framerate-dependent. The game is almost unplayable on my 144Hz monitor, as the paddle moves very fast.",
        "date": "1490538593",
        "username": "tajjada",
        "userpicture": "/img/profile.jpg",
        "id": "XdGSRm",
        "hidden": 0
      },
      {
        "text": "I am quite confused as to how you got a moving object working, but this is fantastic!",
        "date": "1488744882",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "ldcXDs",
        "hidden": 0
      },
      {
        "text": "This is great! I've almost completed the level, but it's tough!",
        "date": "1487053922",
        "username": "hjw3001",
        "userpicture": "/img/profile.jpg",
        "id": "Xs3XRl",
        "hidden": 0
      },
      {
        "text": "I win!!! full ready game only on gpu it is really unreal XD",
        "date": "1477470095",
        "username": "Ruins",
        "userpicture": "/img/profile.jpg",
        "id": "lsV3Wh",
        "hidden": 0
      },
      {
        "text": "good template. i like how the game code is one shader and its shell for style is a second shader.\n\n\nA distance function comes down to a gradient were y=brightness=distance. and it is pretty easy to apply a simple f(x) function that modifies a linear gradient into something with a fuzzy glowinf brder, like smax(step(0.,1.,x),smoothstep(0.,1.,x+1.)) ?\na glow effect can come down to a variantt of many smax() smooth maximum functions. glow comes down to quadratic functions.\n\nsome are simpler, as this has lines 273 274 275 just sum up 3 colors that glare with exp(square function) scaled with with sin(time) and scaled wih some events.",
        "date": "1474668831",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4syGRz",
        "hidden": 0
      },
      {
        "text": "I can't find any doc on the buffers feature (Buf A, Buf B etc). Is there a paragraph or 3 anywhere?",
        "date": "1468832955",
        "username": "pix",
        "userpicture": "/img/profile.jpg",
        "id": "lsdGRN",
        "hidden": 0
      },
      {
        "text": "132 Effect O.O :D",
        "date": "1460727342",
        "username": "bytewave",
        "userpicture": "/media/users/bytewave/profile.jpeg",
        "id": "llXXDs",
        "hidden": 0
      },
      {
        "text": "Nevermind about my corruption.  My system has some strange gfx issues with things besides shadertoy that other systems don't have... maybe some driver or hardware problem.",
        "date": "1454104238",
        "username": "demofox",
        "userpicture": "/media/users/demofox/profile.jpeg",
        "id": "MljGDG",
        "hidden": 0
      },
      {
        "text": "Buf A, line 95, do this\n\nfloat paddlePos = loadValue( txBallPosVel ).x;\n\nAnd it plays itself which is quite entertaining.",
        "date": "1453872575",
        "username": "squeakyneb",
        "userpicture": "/media/users/squeakyneb/profile.jpeg",
        "id": "Mt2GRt",
        "hidden": 0
      },
      {
        "text": "I am curious, lets say for those edges.  Lets say you had a traditional solid orange line.  How do you make it look like a glowing line?",
        "date": "1452650134",
        "username": "cubby208",
        "userpicture": "/img/profile.jpg",
        "id": "4tSGzG",
        "hidden": 0
      },
      {
        "text": "Damn, outstanding",
        "date": "1452626593",
        "username": "wax78",
        "userpicture": "/media/users/wax78/profile.jpeg",
        "id": "Mt2GDm",
        "hidden": 0
      },
      {
        "text": "Hey IQ, I seem to get what looks to be corruption in the image.  Check this out to see what i mean:\nhttp://imgur.com/gclMfMv\n\nwin 7 enterprise, chrome 47.0.2526.106 m\n\nLet me know if there's any more info I can provide!",
        "date": "1452617001",
        "username": "demofox",
        "userpicture": "/media/users/demofox/profile.jpeg",
        "id": "ltjGWm",
        "hidden": 0
      },
      {
        "text": "Fantastic! Very awesome presentation.",
        "date": "1452558961",
        "username": "fizzer",
        "userpicture": "/media/users/fizzer/profile.jpeg",
        "id": "Xt2GDw",
        "hidden": 0
      },
      {
        "text": "@iq\nYou should be able to use cross origin textures if you set crossOrigin='' on the image element before loading.\nIf the server returns a \"access-control-allow-origin:*\" header it is allowed, a lot of image sites already do this.\n\n[url]http://blog.chromium.org/2011/07/using-cross-domain-images-in-webgl-and.html[/url]\n\nThe philosophical issue still remains though ;)",
        "date": "1452419132",
        "username": "Andre",
        "userpicture": "/img/profile.jpg",
        "id": "ltj3DW",
        "hidden": 0
      },
      {
        "text": "Amazingly cool! Only issue is I feel like a lousy programmer comparing myself to this :P",
        "date": "1452354119",
        "username": "DRMASTER",
        "userpicture": "/img/profile.jpg",
        "id": "4l2GWD",
        "hidden": 0
      },
      {
        "text": "Buffers!! And the shader is perfectly awesome! ))",
        "date": "1452268623",
        "username": "warlock",
        "userpicture": "/media/users/warlock/profile.jpeg",
        "id": "MlS3WW",
        "hidden": 0
      },
      {
        "text": "Great job! How large is the default buffer? I assume it is as large as the current resolution and has 4 channels.\nFor those who want to see the gameplay buffer, add in line 293:\nif ( fragCoord.x < 56.5 && fragCoord.y < 56.5 ) col = texture2D(iChannel0, fragCoord.xy/iResolution.xy/4.0).rgb; Might want to set the filter to nearest BTW.",
        "date": "1452261495",
        "username": "Klems",
        "userpicture": "/media/users/Klems/profile.png",
        "id": "MtSGWW",
        "hidden": 0
      },
      {
        "text": "weird, on different pc, the ball not have the same speed.",
        "date": "1452205696",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "4tS3DW",
        "hidden": 0
      },
      {
        "text": "super hyper uber cool!",
        "date": "1452192075",
        "username": "knighty",
        "userpicture": "/img/profile.jpg",
        "id": "ll23D1",
        "hidden": 0
      },
      {
        "text": "it may be cool to permit buffer use by sound shader for doing some sound for any event like ball on paddle, ball on wall, or ball on brick. its not possible ?",
        "date": "1452125113",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "lt2GWh",
        "hidden": 0
      },
      {
        "text": "iq/poljere:\nGreat to see more and more features on ShaderToy after\nsome time of relative stagnation!\nI love the new render buffer addition for its simplicity and usability.\nIt is definitely great for shadowmaps and feedback effects.\nMaybe a bit hacky for game logic, but in some sense those hacks have its charm ;)\n\nAt the same time, I couldn't resist to port your game example to PolyCube that is featuring (from some time already) GLSL translation to JS, so you can run your game logic in a bit less hacky way on a CPU:\nhttp://polycu.be/edit/?h=06yXe2\nI hope you don't mind ^^\n",
        "date": "1452119547",
        "username": "tomkh",
        "userpicture": "/media/users/tomkh/profile.jpeg",
        "id": "4l23D1",
        "hidden": 0
      },
      {
        "text": "iq, totally understand, in a sense too, keeping the limitation is enforcing creativity, which is an important sentiment.",
        "date": "1452114645",
        "username": "dine909",
        "userpicture": "/media/users/dine909/profile.jpeg",
        "id": "4l2GD1",
        "hidden": 0
      },
      {
        "text": "Congrats on the new feature guys, and nice demo!",
        "date": "1452099766",
        "username": "jcowles",
        "userpicture": "/img/profile.jpg",
        "id": "Xt2GDh",
        "hidden": 0
      },
      {
        "text": "Nice game!And the BackBuffer is very cool on shadertoy!",
        "date": "1452061616",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "ltB3D1",
        "hidden": 0
      },
      {
        "text": "IT IS SOOOOOOO COOOOOOOOOOOL!!!!!",
        "date": "1452057705",
        "username": "532789623",
        "userpicture": "/img/profile.jpg",
        "id": "ltBGD1",
        "hidden": 0
      },
      {
        "text": "This is great! You've reduced a powerful modern GPU to the power of an Atari 800 through massively inefficient techniques. \u00f0\u0178\u02dc\u201a\n\nPS: It's a joke \n",
        "date": "1452055827",
        "username": "optimizer",
        "userpicture": "/img/profile.jpg",
        "id": "MtSGD1",
        "hidden": 0
      },
      {
        "text": "....aaaaand there goes my social life!",
        "date": "1452023932",
        "username": "dirkadirkadan",
        "userpicture": "/img/profile.jpg",
        "id": "ltBGWh",
        "hidden": 0
      },
      {
        "text": "dine909, WebGL doesn't allow external images (cross domain textures, that is). The only way would be if Shadertoy itself hosts the images, but then that's a bigger discussion. Also, even without that limitation, there's still philosophical issues with custom textures. We'll see, it might happen, maybe, or maybe not, or maybe yes.",
        "date": "1451965143",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "Ml23Dz",
        "hidden": 0
      },
      {
        "text": "Cool!!!",
        "date": "1451964626",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "ll23Dz",
        "hidden": 0
      },
      {
        "text": "Amazing!! Please though, PLEASE can we have a source fo external image?",
        "date": "1451959586",
        "username": "dine909",
        "userpicture": "/media/users/dine909/profile.jpeg",
        "id": "Mlj3Dz",
        "hidden": 0
      },
      {
        "text": "You can also set gameSpeed to 15.0  in line 26 to speed the process up. Too high values will break the game though, because I had to limit the number of collision detections per game step to 3, otherwise the compiler would crash.",
        "date": "1451953729",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ltj3Dz",
        "hidden": 0
      },
      {
        "text": "haha love the hack! Demo mode :)",
        "date": "1451953256",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "ll2GDz",
        "hidden": 0
      },
      {
        "text": "AMAZING!\nI love the win screen at the end!\n\nFor those who can't play but want to see the awesome grand finale at the end: set Buf A line 143 to paddlePos = balPosVel.x;\n\n;)",
        "date": "1451952667",
        "username": "rodolphito",
        "userpicture": "/img/profile.jpg",
        "id": "Mt2GDz",
        "hidden": 0
      },
      {
        "text": "what is this feedback buffer ?",
        "date": "1451949452",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "ltjGDz",
        "hidden": 0
      },
      {
        "text": "BTW It is possible to cheat in the game. Press \"pause\", then press \"reset time\". Now you can move paddle using arrow keys and the game will be only updated when some key is pressed. ",
        "date": "1451945020",
        "username": "revers",
        "userpicture": "/media/users/revers/profile.gif",
        "id": "llj3Wz",
        "hidden": 0
      },
      {
        "text": "Wow! This is amazing! Great job! :D",
        "date": "1451944783",
        "username": "revers",
        "userpicture": "/media/users/revers/profile.gif",
        "id": "Mtj3Wz",
        "hidden": 0
      },
      {
        "text": "WOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO!\n\nThanks for multi-pass and feedback buffer Beautypi :D!",
        "date": "1451936731",
        "username": "public_int_i",
        "userpicture": "/img/profile.jpg",
        "id": "ltj3DR",
        "hidden": 0
      },
      {
        "text": "Oh wow, both history and multi-pass rendering at once!!\n\nAlso, please add a second of wait before the game begins.",
        "date": "1451935743",
        "username": "nimitz",
        "userpicture": "/media/users/nimitz/profile.png",
        "id": "Mt2GDR",
        "hidden": 0
      },
      {
        "text": "and it seems to be that this feature is not supported by my mobile (black screen on my BB Passport for all the multipass shaders)",
        "date": "1451927612",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "Mt23WR",
        "hidden": 0
      },
      {
        "text": "hmm, i guess my GPU isn't supported. it seems to draw OK and can move the paddle, but the ball is flickering and can't play :( ubuntu+intel gpu",
        "date": "1451921892",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "Mlj3WR",
        "hidden": 0
      },
      {
        "text": "OH NO!! :D :love:",
        "date": "1451911666",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Ml2GWR",
        "hidden": 0
      },
      {
        "text": "THIS\nCHANGES\nEVERYTHING!!!\n:-0",
        "date": "1451911345",
        "username": "TekF",
        "userpicture": "/media/users/TekF/profile.png",
        "id": "ll2GWR",
        "hidden": 0
      },
      {
        "text": "WOW!!!! A New World!!! :)",
        "date": "1451907226",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "lljGWR",
        "hidden": 0
      },
      {
        "text": "think how awesome it would be if you could export this into a single executable file.",
        "date": "1451907050",
        "username": "Mourtz",
        "userpicture": "/media/users/Mourtz/profile.jpeg",
        "id": "MtjGWR",
        "hidden": 0
      },
      {
        "text": "Hey I have a question that I assume is basic:\nIn Buf A line 72 you specify 3 param for texture2D, what is the use of the third one ?\nThere is no mimpmap, right ?",
        "date": "1451906687",
        "username": "antonOTI",
        "userpicture": "/media/users/antonOTI/profile.png",
        "id": "ltjGWR",
        "hidden": 0
      },
      {
        "text": "LEELOO DALLAS MULTIPASS!\nI'm sorry for the awful joke... :P\n\nThank you for the render buffers!",
        "date": "1451902411",
        "username": "vgs",
        "userpicture": "/media/users/vgs/profile.jpeg",
        "id": "4l23Dz",
        "hidden": 0
      },
      {
        "text": "Wow... great!!",
        "date": "1451900596",
        "username": "Nrx",
        "userpicture": "/media/users/Nrx/profile.png",
        "id": "Xl23Dz",
        "hidden": 0
      },
      {
        "text": "Great job. Congrats!",
        "date": "1451899937",
        "username": "reality3d",
        "userpicture": "/img/profile.jpg",
        "id": "4t23Dz",
        "hidden": 0
      },
      {
        "text": "Wow, really nice :)!",
        "date": "1451897616",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "Xt23Dz",
        "hidden": 0
      },
      {
        "text": "Shadertoy is dead, long live Shadertoy!  :D",
        "date": "1451896636",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "4lj3Dz",
        "hidden": 0
      },
      {
        "text": "Thanks iq!",
        "date": "1451896477",
        "username": "antonOTI",
        "userpicture": "/media/users/antonOTI/profile.png",
        "id": "Xlj3Dz",
        "hidden": 0
      },
      {
        "text": "great :) i cant inmagine a thing like this was possible with shader . thanks shadertoy",
        "date": "1451894584",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "4tj3Dz",
        "hidden": 0
      },
      {
        "text": "Welcome games to Shadertoy! Multipass is here :love:",
        "date": "1451889698",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "4l2GDz",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "MdfBRX",
      "date": "1498981597",
      "viewed": 44484,
      "name": "The Drive Home",
      "username": "BigWIngs",
      "description": "See comment block for details. Use mouse to scrub time. Hope you like it!\n\nVideo of the effect:\nhttps://www.youtube.com/watch?v=WrxZ4AZPdOQ\n\nMaking of tutorial:\nhttps://www.youtube.com/watch?v=eKtsY7hYTPg",
      "likes": 428,
      "published": 1,
      "flags": 64,
      "tags": [
        "bokeh",
        "glass",
        "rain",
        "window",
        "nightdrive"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dsSRX",
            "filepath": "https://soundcloud.com/zefora/cheyah",
            "previewfilepath": "https://soundcloud.com/zefora/cheyah",
            "type": "musicstream",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 0
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// \"The Drive Home\" by Martijn Steinrucken aka BigWings - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n//\n// I was looking for something 3d, that can be made just with a point-line distance function.\n// Then I saw the cover graphic of the song I'm using here on soundcloud, which is a bokeh traffic\n// shot which is a perfect for for what I was looking for.\n//\n// It took me a while to get to a satisfying rain effect. Most other people use a render buffer for\n// this so that is how I started. In the end though, I got a better effect without. Uncomment the\n// DROP_DEBUG define to get a better idea of what is going on.\n//\n// If you are watching this on a weaker device, you can uncomment the HIGH_QUALITY define\n//\n// Music:\n// Mr. Bill - Cheyah (Zefora's digital rain remix) \n// https://soundcloud.com/zefora/cheyah\n//\n// Video can be found here:\n// https://www.youtube.com/watch?v=WrxZ4AZPdOQ\n//\n// Making of tutorial:\n// https://www.youtube.com/watch?v=eKtsY7hYTPg\n//\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define B(a, b, edge, t) S(a-edge, a+edge, t)*S(b+edge, b-edge, t)\n#define sat(x) clamp(x,0.,1.)\n\n#define streetLightCol vec3(1., .7, .3)\n#define headLightCol vec3(.8, .8, 1.)\n#define tailLightCol vec3(1., .1, .1)\n\n#define HIGH_QUALITY\n#define CAM_SHAKE 1.\n#define LANE_BIAS .5\n#define RAIN\n//#define DROP_DEBUG\n\nvec3 ro, rd;\n\nfloat N(float t) {\n\treturn fract(sin(t*10234.324)*123423.23512);\n}\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n \nvec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n    // returns the closest point on ray r to point p\n    return ro + max(0., dot(p-ro, rd))*rd;\n}\n\nfloat Remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\nfloat BokehMask(vec3 ro, vec3 rd, vec3 p, float size, float blur) {\n\tfloat d = DistLine(ro, rd, p);\n    float m = S(size, size*(1.-blur), d);\n    \n    #ifdef HIGH_QUALITY\n    m *= mix(.7, 1., S(.8*size, size, d));\n    #endif\n    \n    return m;\n}\n\n\n\nfloat SawTooth(float t) {\n    return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n}\n\nfloat DeltaSawTooth(float t) {\n    return 0.4*cos(2.*t)+0.08*cos(4.*t) - (1.-sin(t))*sin(t+cos(t));\n}  \n\nvec2 GetDrops(vec2 uv, float seed, float m) {\n    \n    float t = iTime+m*30.;\n    vec2 o = vec2(0.);\n    \n    #ifndef DROP_DEBUG\n    uv.y += t*.05;\n    #endif\n    \n    uv *= vec2(10., 2.5)*2.;\n    vec2 id = floor(uv);\n    vec3 n = N31(id.x + (id.y+seed)*546.3524);\n    vec2 bd = fract(uv);\n    \n    vec2 uv2 = bd;\n    \n    bd -= .5;\n    \n    bd.y*=4.;\n    \n    bd.x += (n.x-.5)*.6;\n    \n    t += n.z * 6.28;\n    float slide = SawTooth(t);\n    \n    float ts = 1.5;\n    vec2 trailPos = vec2(bd.x*ts, (fract(bd.y*ts*2.-t*2.)-.5)*.5);\n    \n    bd.y += slide*2.;\t\t\t\t\t\t\t\t// make drops slide down\n    \n    #ifdef HIGH_QUALITY\n    float dropShape = bd.x*bd.x;\n    dropShape *= DeltaSawTooth(t);\n    bd.y += dropShape;\t\t\t\t\t\t\t\t// change shape of drop when it is falling\n    #endif\n    \n    float d = length(bd);\t\t\t\t\t\t\t// distance to main drop\n    \n    float trailMask = S(-.2, .2, bd.y);\t\t\t\t// mask out drops that are below the main\n    trailMask *= bd.y;\t\t\t\t\t\t\t\t// fade dropsize\n    float td = length(trailPos*max(.5, trailMask));\t// distance to trail drops\n    \n    float mainDrop = S(.2, .1, d);\n    float dropTrail = S(.1, .02, td);\n    \n    dropTrail *= trailMask;\n    o = mix(bd*mainDrop, trailPos, dropTrail);\t\t// mix main drop and drop trail\n    \n    #ifdef DROP_DEBUG\n    if(uv2.x<.02 || uv2.y<.01) o = vec2(1.);\n    #endif\n    \n    return o;\n}\n\nvoid CameraSetup(vec2 uv, vec3 pos, vec3 lookat, float zoom, float m) {\n\tro = pos;\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    float t = iTime;\n    \n    vec2 offs = vec2(0.);\n    #ifdef RAIN\n    vec2 dropUv = uv; \n    \n    #ifdef HIGH_QUALITY\n    float x = (sin(t*.1)*.5+.5)*.5;\n    x = -x*x;\n    float s = sin(x);\n    float c = cos(x);\n    \n    mat2 rot = mat2(c, -s, s, c);\n   \n    #ifndef DROP_DEBUG\n    dropUv = uv*rot;\n    dropUv.x += -sin(t*.1)*.5;\n    #endif\n    #endif\n    \n    offs = GetDrops(dropUv, 1., m);\n    \n    #ifndef DROP_DEBUG\n    offs += GetDrops(dropUv*1.4, 10., m);\n    #ifdef HIGH_QUALITY\n    offs += GetDrops(dropUv*2.4, 25., m);\n    //offs += GetDrops(dropUv*3.4, 11.);\n    //offs += GetDrops(dropUv*3., 2.);\n    #endif\n    \n    float ripple = sin(t+uv.y*3.1415*30.+uv.x*124.)*.5+.5;\n    ripple *= .005;\n    offs += vec2(ripple*ripple, ripple);\n    #endif\n    #endif\n    vec3 center = ro + f*zoom;\n    vec3 i = center + (uv.x-offs.x)*r + (uv.y-offs.y)*u;\n    \n    rd = normalize(i-ro);\n}\n\nvec3 HeadLights(float i, float t) {\n    float z = fract(-t*2.+i);\n    vec3 p = vec3(-.3, .1, z*40.);\n    float d = length(p-ro);\n    \n    float size = mix(.03, .05, S(.02, .07, z))*d;\n    float m = 0.;\n    float blur = .1;\n    m += BokehMask(ro, rd, p-vec3(.08, 0., 0.), size, blur);\n    m += BokehMask(ro, rd, p+vec3(.08, 0., 0.), size, blur);\n    \n    #ifdef HIGH_QUALITY\n    m += BokehMask(ro, rd, p+vec3(.1, 0., 0.), size, blur);\n    m += BokehMask(ro, rd, p-vec3(.1, 0., 0.), size, blur);\n    #endif\n    \n    float distFade = max(.01, pow(1.-z, 9.));\n    \n    blur = .8;\n    size *= 2.5;\n    float r = 0.;\n    r += BokehMask(ro, rd, p+vec3(-.09, -.2, 0.), size, blur);\n    r += BokehMask(ro, rd, p+vec3(.09, -.2, 0.), size, blur);\n    r *= distFade*distFade;\n    \n    return headLightCol*(m+r)*distFade;\n}\n\n\nvec3 TailLights(float i, float t) {\n    t = t*1.5+i;\n    \n    float id = floor(t)+i;\n    vec3 n = N31(id);\n    \n    float laneId = S(LANE_BIAS, LANE_BIAS+.01, n.y);\n    \n    float ft = fract(t);\n    \n    float z = 3.-ft*3.;\t\t\t\t\t\t// distance ahead\n    \n    laneId *= S(.2, 1.5, z);\t\t\t\t// get out of the way!\n    float lane = mix(.6, .3, laneId);\n    vec3 p = vec3(lane, .1, z);\n    float d = length(p-ro);\n    \n    float size = .05*d;\n    float blur = .1;\n    float m = BokehMask(ro, rd, p-vec3(.08, 0., 0.), size, blur) +\n    \t\t\tBokehMask(ro, rd, p+vec3(.08, 0., 0.), size, blur);\n    \n    #ifdef HIGH_QUALITY\n    float bs = n.z*3.;\t\t\t\t\t\t// start braking at random distance\t\t\n    float brake = S(bs, bs+.01, z);\n    brake *= S(bs+.01, bs, z-.5*n.y);\t\t// n.y = random brake duration\n    \n    m += (BokehMask(ro, rd, p+vec3(.1, 0., 0.), size, blur) +\n    \tBokehMask(ro, rd, p-vec3(.1, 0., 0.), size, blur))*brake;\n    #endif\n    \n    float refSize = size*2.5;\n    m += BokehMask(ro, rd, p+vec3(-.09, -.2, 0.), refSize, .8);\n    m += BokehMask(ro, rd, p+vec3(.09, -.2, 0.), refSize, .8);\n    vec3 col = tailLightCol*m*ft; \n    \n    float b = BokehMask(ro, rd, p+vec3(.12, 0., 0.), size, blur);\n    b += BokehMask(ro, rd, p+vec3(.12, -.2, 0.), refSize, .8)*.2;\n    \n    vec3 blinker = vec3(1., .7, .2);\n    blinker *= S(1.5, 1.4, z)*S(.2, .3, z);\n    blinker *= sat(sin(t*200.)*100.);\n    blinker *= laneId;\n    col += blinker*b;\n    \n    return col;\n}\n\nvec3 StreetLights(float i, float t) {\n\t float side = sign(rd.x);\n    float offset = max(side, 0.)*(1./16.);\n    float z = fract(i-t+offset); \n    vec3 p = vec3(2.*side, 2., z*60.);\n    float d = length(p-ro);\n\tfloat blur = .1;\n    vec3 rp = ClosestPoint(ro, rd, p);\n    float distFade = Remap(1., .7, .1, 1.5, 1.-pow(1.-z,6.));\n    distFade *= (1.-z);\n    float m = BokehMask(ro, rd, p, .05*d, blur)*distFade;\n    \n    return m*streetLightCol;\n}\n\nvec3 EnvironmentLights(float i, float t) {\n\tfloat n = N(i+floor(t));\n    \n    float side = sign(rd.x);\n    float offset = max(side, 0.)*(1./16.);\n    float z = fract(i-t+offset+fract(n*234.));\n    float n2 = fract(n*100.);\n    vec3 p = vec3((3.+n)*side, n2*n2*n2*1., z*60.);\n    float d = length(p-ro);\n\tfloat blur = .1;\n    vec3 rp = ClosestPoint(ro, rd, p);\n    float distFade = Remap(1., .7, .1, 1.5, 1.-pow(1.-z,6.));\n    float m = BokehMask(ro, rd, p, .05*d, blur);\n    m *= distFade*distFade*.5;\n    \n    m *= 1.-pow(sin(z*6.28*20.*n)*.5+.5, 20.);\n    vec3 randomCol = vec3(fract(n*-34.5), fract(n*4572.), fract(n*1264.));\n    vec3 col = mix(tailLightCol, streetLightCol, fract(n*-65.42));\n    col = mix(col, randomCol, n);\n    return m*col*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec3 col = vec3(0.);\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 pos = vec3(.3, .15, 0.);\n    \n    float bt = t * 5.;\n    float h1 = N(floor(bt));\n    float h2 = N(floor(bt+1.));\n    float bumps = mix(h1, h2, fract(bt))*.1;\n    bumps = bumps*bumps*bumps*CAM_SHAKE;\n    \n    pos.y += bumps;\n    float lookatY = pos.y+bumps;\n    vec3 lookat = vec3(0.3, lookatY, 1.);\n    vec3 lookat2 = vec3(0., lookatY, .7);\n    lookat = mix(lookat, lookat2, sin(t*.1)*.5+.5);\n    \n    uv.y += bumps*4.;\n    CameraSetup(uv, pos, lookat, 2., mouse.x);\n   \n    t *= .03;\n    t += mouse.x;\n    \n    // fix for GLES devices by MacroMachines\n    #ifdef GL_ES\n\tconst float stp = 1./8.;\n\t#else\n\tfloat stp = 1./8.\n\t#endif\n    \n    for(float i=0.; i<1.; i+=stp) {\n       col += StreetLights(i, t);\n    }\n    \n    for(float i=0.; i<1.; i+=stp) {\n        float n = N(i+floor(t));\n    \tcol += HeadLights(i+n*stp*.7, t);\n    }\n    \n    #ifndef GL_ES\n    #ifdef HIGH_QUALITY\n    stp = 1./32.;\n    #else\n    stp = 1./16.;\n    #endif\n    #endif\n    \n    for(float i=0.; i<1.; i+=stp) {\n       col += EnvironmentLights(i, t);\n    }\n    \n    col += TailLights(0., t);\n    col += TailLights(.5, t);\n    \n    col += sat(rd.y)*vec3(.6, .5, .9);\n    \n\tfragColor = vec4(col, 0.);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "@zisko  No problem. Curious to see the final result! Drop me a link.",
        "date": "1559778187",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "MtScDG",
        "hidden": 0
      },
      {
        "text": "This is beautiful! I'm going to use a modified version for my personal website (and will credit/link you!)",
        "date": "1559774280",
        "username": "zisko",
        "userpicture": "/img/profile.jpg",
        "id": "llByDG",
        "hidden": 0
      },
      {
        "text": "@victor\nYeah you can use this on any non-commercial project as long as you put me in the credits and supply a link. :)\n\n@justPlayin\nI guess you are right. I'm too lazy to change it now though. You can change it on your own version if you follow the tutorial :)",
        "date": "1552603747",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "MllyzX",
        "hidden": 0
      },
      {
        "text": "by the way, the code is totally open source and you can check it out here: https://github.com/victorqribeiro/radio ",
        "date": "1552576768",
        "username": "victorqribeiro",
        "userpicture": "/img/profile.jpg",
        "id": "4llyzf",
        "hidden": 0
      },
      {
        "text": "Hi man, how are you? My name is Victor Ribeiro and I'm a software engineering undergrad. I'm working on a personal project that is visualizations for webradios. I'm not making money off of it. I writing to asking you if you mind me using this shader on my project. All credits to you, I'm only gonna make the port to webgl using three.js. \n the link for the project is https://victorribeiro.com/radio. All the radios available on the project have given me green light to use their stream. Anyways, thanks a lot. Love the work.",
        "date": "1552576563",
        "username": "victorqribeiro",
        "userpicture": "/img/profile.jpg",
        "id": "Xllyzf",
        "hidden": 0
      },
      {
        "text": "Impressive effect.  I hope you don't mind me making a suggestion (not a critisism!).  I tried to change the code to illustrate my point but I'm not good enough to make it work!  As you're travelling at speed the headwind would make water droplets move up the windshield. I think the staggered movement you have would look fine, just reversed.  If you could simulate the ~30 degree slope of the screen rather than the flat plate that would be icing on the cake :) ",
        "date": "1552331933",
        "username": "JustPlayin",
        "userpicture": "/img/profile.jpg",
        "id": "4tfcRX",
        "hidden": 0
      },
      {
        "text": "pretty!",
        "date": "1552031694",
        "username": "neoneye",
        "userpicture": "/img/profile.jpg",
        "id": "4lXyz2",
        "hidden": 0
      },
      {
        "text": "dude, i've been following on youtube. you rock!!! thanks a lot for the videos.",
        "date": "1549864473",
        "username": "victorqribeiro",
        "userpicture": "/img/profile.jpg",
        "id": "llfyz7",
        "hidden": 0
      },
      {
        "text": "Beautiful!",
        "date": "1538657480",
        "username": "smart61",
        "userpicture": "/img/profile.jpg",
        "id": "MdXBRX",
        "hidden": 0
      },
      {
        "text": "Respect bruv",
        "date": "1534826021",
        "username": "ROAG99",
        "userpicture": "/media/users/ROAG99/profile.jpeg",
        "id": "ldsBz7",
        "hidden": 0
      },
      {
        "text": "nice...",
        "date": "1531908942",
        "username": "devshin",
        "userpicture": "/img/profile.jpg",
        "id": "XdjyWV",
        "hidden": 0
      },
      {
        "text": "lovely",
        "date": "1524834820",
        "username": "akhgary",
        "userpicture": "/img/profile.jpg",
        "id": "MslcDX",
        "hidden": 0
      },
      {
        "text": "That's Cool,man",
        "date": "1523434387",
        "username": "prohell",
        "userpicture": "/media/users/prohell/profile.jpeg",
        "id": "lssyRl",
        "hidden": 0
      },
      {
        "text": "That's Cool,man",
        "date": "1523434376",
        "username": "prohell",
        "userpicture": "/media/users/prohell/profile.jpeg",
        "id": "MdsyRl",
        "hidden": 0
      },
      {
        "text": "oups [url=https://www.shadertoy.com/playlist/featured]https://www.shadertoy.com/playlist/featured[/url]",
        "date": "1521314130",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "lsscW8",
        "hidden": 0
      },
      {
        "text": "there is also the playslit for featured :) [url=https://www.shadertoy.com/playlist/featured]https://www.shadertoy.com/playlist/featured(/url]",
        "date": "1521314106",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "MdscW8",
        "hidden": 0
      },
      {
        "text": "Sweeet",
        "date": "1521085291",
        "username": "purple_marine",
        "userpicture": "/img/profile.jpg",
        "id": "MsfyW8",
        "hidden": 0
      },
      {
        "text": "don't you guys know that there is now a playlist associated to each categorie ? :-) SotW: [url]https://www.shadertoy.com/playlist/week[/url] . But I didn't found another occurence here (but I missed some). Maybe it was the other category.",
        "date": "1521046203",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XsfyDH",
        "hidden": 0
      },
      {
        "text": "ye i think it was shader of the week before. around the time i commented first. 2017-07-06",
        "date": "1521043726",
        "username": "GottZ",
        "userpicture": "/img/profile.jpg",
        "id": "4sXyDH",
        "hidden": 0
      },
      {
        "text": "Oww Shader of the week! Thanks ShaderToy gods ;)\n@P|NG - was this already shader of the week sometime? I wasn't aware of that.",
        "date": "1520975691",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4dfcW8",
        "hidden": 0
      },
      {
        "text": "it was a very long week :-p",
        "date": "1520949639",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XdXyW8",
        "hidden": 0
      },
      {
        "text": "Shader of the week again. Nice!",
        "date": "1520948190",
        "username": "PlNG",
        "userpicture": "/img/profile.jpg",
        "id": "ldscDr",
        "hidden": 0
      },
      {
        "text": "Why, oh why, you don't have sound volume slider, Shadertoy...",
        "date": "1520947526",
        "username": "metalim",
        "userpicture": "/media/users/metalim/profile.jpeg",
        "id": "MslcDr",
        "hidden": 0
      },
      {
        "text": "Magical!",
        "date": "1520939513",
        "username": "piero",
        "userpicture": "/media/users/piero/profile.jpeg",
        "id": "ldsyDr",
        "hidden": 0
      },
      {
        "text": "Incredible!",
        "date": "1520932753",
        "username": "mlkn",
        "userpicture": "/media/users/mlkn/profile.png",
        "id": "MslyDr",
        "hidden": 0
      },
      {
        "text": "very nice",
        "date": "1516902044",
        "username": "Fettmops",
        "userpicture": "/img/profile.jpg",
        "id": "MtKSRd",
        "hidden": 0
      },
      {
        "text": "You re rock Mr GIANT WIngs",
        "date": "1516846650",
        "username": "up209d",
        "userpicture": "/img/profile.jpg",
        "id": "llVSzt",
        "hidden": 0
      },
      {
        "text": "Beautifull. love the music also",
        "date": "1514949730",
        "username": "jpupper",
        "userpicture": "/img/profile.jpg",
        "id": "ltGSRG",
        "hidden": 0
      },
      {
        "text": "rain drop effect is nice :)",
        "date": "1511765924",
        "username": "Passion",
        "userpicture": "/img/profile.jpg",
        "id": "Xl3SWl",
        "hidden": 0
      },
      {
        "text": "@heliumsoft - I'm doing a video tutorial series on this shader. I haven't gotten to the rain yet, but will get there soon. Then you can just make it yourself.\n\nIf you want to use the whole effect, as is, then send me a mail countfrolic@gmail.com",
        "date": "1511110854",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "XlcXWj",
        "hidden": 0
      },
      {
        "text": "How are you?\nI did check your effect and wondering.\nI am developing mobile video app and want insert your rain effect in that app.\nThen license is \"Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\"\nHow can i get rain effect license.\nThanks.",
        "date": "1510888169",
        "username": "heliumsoft",
        "userpicture": "/img/profile.jpg",
        "id": "4t3SDS",
        "hidden": 0
      },
      {
        "text": "Very relaxing. Great idea and really good implementation.",
        "date": "1510838106",
        "username": "ingagard",
        "userpicture": "/img/profile.jpg",
        "id": "MttXRl",
        "hidden": 0
      },
      {
        "text": "I came up with the 2 step idea because it felt more intuitive and was easier to explain step-by-step in previous videos.\nHowever, you obviously know your stuff when it comes to computer graphics and you seem to feel more strongly about your approach than I feel about mine so I'll be sure to do it your way the next time I make a video :)",
        "date": "1510613699",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4l3Szl",
        "hidden": 0
      },
      {
        "text": "\"for the sake of understanding\" : it's the point I totally disagree with.\nIf you didn't had OpenGL classes explaining the series of frame transforms, you would never have come with this 2-step idea. \nWhile if you had in mind the basic algebra for geometry you learn at age 15, you know that scaling is multiplying coordinates by some scalar (later only you learn how to scale with distortions... that we don't want here).\nThat's why I say it's a corruption of mind by OpenGL (plus CS assassinating one's very basic math skills).\nIf it was only an optimization issue, I won't be so deeply annoyed by this pattern so frequently seen here. (Now, I'm more a math-phys scientist that's a CS guy. This may count :-) ).",
        "date": "1510596030",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4t3XRl",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret - Hehe... I was waiting for you to say something about it. ;)\nI think that for the sake of understanding, the aspect ratio approach is better and it only costs one extra instruction. You are right though, your solution is cleaner and more performant. I'll be sure to use yours next time.  ",
        "date": "1510593958",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4l3SRl",
        "hidden": 0
      },
      {
        "text": "Oh no, the life tutorial starts with the horrible aspect ratio thing, which is really knowledge of graphics pipeline corrupting people's mind !   \n-> to scale without distortion is just applying a real simple scaling by a float, the very first one people saw at school before long. -> just do / R.y .\nAnd if you want to center, just translate to center, period.\n->     vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n",
        "date": "1510562597",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "lltXRf",
        "hidden": 0
      },
      {
        "text": "so great, perfect in minimalism look and still conveying all aspects; how did I missed that in July ?",
        "date": "1510562258",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MttXRf",
        "hidden": 0
      },
      {
        "text": "THIS IS SOO BEAUTIFUL :)\nIt looks like dusk when you uncomment #define DROP_DEBUG tho..",
        "date": "1509985503",
        "username": "Imsure1200q_1UWE130",
        "userpicture": "/media/users/Imsure1200q_1UWE130/profile.jpeg",
        "id": "ltcSzj",
        "hidden": 0
      },
      {
        "text": "hey guys , im developing a native shadertoy like app free and opensource feel free to check it out and contribute if you are interested.\nhttps://github.com/arminkz/ShaderToy.NET\n",
        "date": "1509476626",
        "username": "arminkz",
        "userpicture": "/media/users/arminkz/profile.png",
        "id": "XtcSRS",
        "hidden": 0
      },
      {
        "text": "Beautiful! Can you add a wiper? :)",
        "date": "1509076734",
        "username": "jay3sh",
        "userpicture": "/img/profile.jpg",
        "id": "MttSDN",
        "hidden": 0
      },
      {
        "text": "This is really great, and completely captures that moment we've all experienced. I was about to suggest to add a turn signal, but you already did. This is perfect.",
        "date": "1509007806",
        "username": "Zavie",
        "userpicture": "/media/users/Zavie/profile.png",
        "id": "XtdXWN",
        "hidden": 0
      },
      {
        "text": "Wonderfull! Great execution",
        "date": "1508967324",
        "username": "XT95",
        "userpicture": "/media/users/XT95/profile.png",
        "id": "XldXW4",
        "hidden": 0
      },
      {
        "text": "This is beautiful. You should turn the wipers on and focus on the road though.",
        "date": "1508930022",
        "username": "P_Malin",
        "userpicture": "/media/users/P_Malin/profile.jpeg",
        "id": "MlcSW4",
        "hidden": 0
      },
      {
        "text": "@BigWings - Thank you very much!",
        "date": "1501576107",
        "username": "Sebquismoke",
        "userpicture": "/media/users/Sebquismoke/profile.jpeg",
        "id": "llt3Wf",
        "hidden": 0
      },
      {
        "text": "@MacroMachines - Thanks, added your fix.Regarding the real-time rain displacement, there are some racing games these days that have amazing rain.\n@Sebquismoke  - the rain is built into the camera. If you steal my cam function and use it in your own raytracer you should get the same drops. I'll see if I can lift it and make a simple effect you can use with a texture.\n@everyone else - Thanks for your nice words!",
        "date": "1500614478",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "Xtc3zs",
        "hidden": 0
      },
      {
        "text": "Super cool, love bokeh and I did rain displacement on this ford gig I did a while back: https://youtu.be/FOL9B-e2Oz8 and that took crazy time to render, loving getting into realtime.",
        "date": "1500468817",
        "username": "MacroMachines",
        "userpicture": "/media/users/MacroMachines/profile.jpeg",
        "id": "lldGRX",
        "hidden": 0
      },
      {
        "text": "to fix mobile I had to make the float stp into a const, \nline 336\n#ifdef GL_ES\nconst float stp = 1./8.;\n#else\nfloat stp = 1./8.\n#endif\n\nand then wrap the #ifdef HIGH_QUALITY with #ifndef GL_ES and #endif",
        "date": "1500467999",
        "username": "MacroMachines",
        "userpicture": "/media/users/MacroMachines/profile.jpeg",
        "id": "ltdGRX",
        "hidden": 0
      },
      {
        "text": "This would make a great art exhibition piece. Relaxing too.\n",
        "date": "1500337277",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4ld3z2",
        "hidden": 0
      },
      {
        "text": "Very nice!\nHow can i do if i'd like to replace the background by another image (iChannel1 for example)?\nThank you for your answer.",
        "date": "1500281427",
        "username": "Sebquismoke",
        "userpicture": "/media/users/Sebquismoke/profile.jpeg",
        "id": "4lc3zj",
        "hidden": 0
      },
      {
        "text": "This is really beautiful and clever.",
        "date": "1499571769",
        "username": "visuality",
        "userpicture": "/media/users/visuality/profile.jpeg",
        "id": "Xl33W4",
        "hidden": 0
      },
      {
        "text": "This shader is so cool, it should be illegal! XD",
        "date": "1499345711",
        "username": "dcbrwn",
        "userpicture": "/img/profile.jpg",
        "id": "4tdGDH",
        "hidden": 0
      },
      {
        "text": "Very cool!",
        "date": "1499329849",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "4lt3WH",
        "hidden": 0
      },
      {
        "text": "this deserves more visitors",
        "date": "1499327404",
        "username": "GottZ",
        "userpicture": "/img/profile.jpg",
        "id": "4tt3WH",
        "hidden": 0
      },
      {
        "text": "@flockaroo - it's an artifact from mirroring the streetlights to get better performance. It should be better now. :)\n@everyone: thanks!",
        "date": "1499200090",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "llc3D8",
        "hidden": 0
      },
      {
        "text": "very cool!!\nthe yellow bokeh's o the right side are clamped towards the middle - is that only on my system?",
        "date": "1499198609",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "ll33D8",
        "hidden": 0
      },
      {
        "text": "looks great",
        "date": "1499166775",
        "username": "kuvkar",
        "userpicture": "/media/users/kuvkar/profile.png",
        "id": "lt3GW8",
        "hidden": 0
      },
      {
        "text": "wow! true work of art :)",
        "date": "1499160159",
        "username": "glkt",
        "userpicture": "/media/users/glkt/profile.jpeg",
        "id": "Xl33DH",
        "hidden": 0
      },
      {
        "text": "Thanks everyone!",
        "date": "1499119355",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4l33WH",
        "hidden": 0
      },
      {
        "text": "Just gorgeous!!",
        "date": "1499064824",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "MltGDr",
        "hidden": 0
      },
      {
        "text": "\"As abstract examples go...\" - It'd be great to have a comment editing feature. :)",
        "date": "1499009543",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "lldGDn",
        "hidden": 0
      },
      {
        "text": "A abstract examples go, this is really well done.",
        "date": "1499009380",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "MtdGDn",
        "hidden": 0
      },
      {
        "text": "Amazing",
        "date": "1499009320",
        "username": "duvengar",
        "userpicture": "/img/profile.jpg",
        "id": "ltdGDn",
        "hidden": 0
      },
      {
        "text": "Some real raindrops, I'm impressed. 1 buffer also... Hella' good job.",
        "date": "1499006434",
        "username": "Yrai",
        "userpicture": "/media/users/Yrai/profile.jpeg",
        "id": "MttGDn",
        "hidden": 0
      },
      {
        "text": "Wow this is incredible. You should upload a video to YT with this :) ",
        "date": "1499006367",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "lttGDn",
        "hidden": 0
      },
      {
        "text": "Beautiful",
        "date": "1498995547",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "ltd3Wn",
        "hidden": 0
      },
      {
        "text": "Very cool. So nice drops.",
        "date": "1498991466",
        "username": "ocb",
        "userpicture": "/media/users/ocb/profile.jpeg",
        "id": "ltt3Wn",
        "hidden": 0
      },
      {
        "text": "Pretty!",
        "date": "1498984938",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "ltdGWn",
        "hidden": 0
      },
      {
        "text": "Wow! That's cool.. :)",
        "date": "1498982334",
        "username": "jTobergte",
        "userpicture": "/img/profile.jpg",
        "id": "MltGWn",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Ms2SD1",
      "date": "1411752810",
      "viewed": 403315,
      "name": "Seascape",
      "username": "TDM",
      "description": "fully-procedural sea surface computing. without textures.\n\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape",
      "likes": 1440,
      "published": 1,
      "flags": 0,
      "tags": [
        "procedural",
        "noise",
        "waves",
        "sea",
        "water",
        "subsurface"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "666",
        "date": "1559717256",
        "username": "aipame",
        "userpicture": "/img/profile.jpg",
        "id": "XtByWy",
        "hidden": 0
      },
      {
        "text": "mind blowing, i could spend entire life and ending up in 2d blue and white screen",
        "date": "1558690922",
        "username": "therepo90",
        "userpicture": "/img/profile.jpg",
        "id": "XtBczc",
        "hidden": 0
      },
      {
        "text": "there is a bug :( Black waves and flickering",
        "date": "1558161667",
        "username": "Imsure1200q_1UWE130",
        "userpicture": "/media/users/Imsure1200q_1UWE130/profile.jpeg",
        "id": "Mt2cRy",
        "hidden": 0
      },
      {
        "text": "Simply amazing wow\n",
        "date": "1557585101",
        "username": "JUMANJI",
        "userpicture": "/img/profile.jpg",
        "id": "MtjyDm",
        "hidden": 0
      },
      {
        "text": "Amazing!",
        "date": "1557563974",
        "username": "ikuto",
        "userpicture": "/media/users/ikuto/profile.png",
        "id": "Mt2cWm",
        "hidden": 0
      },
      {
        "text": "fantastic",
        "date": "1556871584",
        "username": "rebbecamoor",
        "userpicture": "/media/users/rebbecamoor/profile.jpeg",
        "id": "ltjyW1",
        "hidden": 0
      },
      {
        "text": "\u725b\u903c\u554a",
        "date": "1554269806",
        "username": "therainhasgone",
        "userpicture": "/img/profile.jpg",
        "id": "llsyDX",
        "hidden": 0
      },
      {
        "text": "Where it is?",
        "date": "1551436951",
        "username": "AnnaEverson",
        "userpicture": "/media/users/AnnaEverson/profile.jpeg",
        "id": "MlsyWM",
        "hidden": 0
      },
      {
        "text": "Looks great!",
        "date": "1549781893",
        "username": "TheRedstoneHive",
        "userpicture": "/img/profile.jpg",
        "id": "llfyRM",
        "hidden": 0
      },
      {
        "text": "How long has this been the most popular shader ever?",
        "date": "1547954731",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "XdBfW3",
        "hidden": 0
      },
      {
        "text": "gtx 1060 laptop, works fine, 970m on razer blade with artifacts, but rendered through the resolume source looks fine. tested on windows 10 64 latest chrome on both laptops",
        "date": "1542445739",
        "username": "dradutu",
        "userpicture": "/media/users/dradutu/profile.png",
        "id": "ls2BzD",
        "hidden": 0
      },
      {
        "text": "resolume 6 source https://mega.nz/#!l1FXAQbR!HGjv1cSIzhaRwLrr5mr0gNMiP2jeseIkC1Mmh9SdDgU",
        "date": "1542444968",
        "username": "dradutu",
        "userpicture": "/media/users/dradutu/profile.png",
        "id": "Md2BzD",
        "hidden": 0
      },
      {
        "text": "Or maybe try via his github -> https://github.com/tdmaav",
        "date": "1539247856",
        "username": "djmips",
        "userpicture": "/img/profile.jpg",
        "id": "Xdsfzs",
        "hidden": 0
      },
      {
        "text": "You need to ask on Resolume / FFGL / VJing forums",
        "date": "1539246490",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "4slfzs",
        "hidden": 0
      },
      {
        "text": "You need to ask on Resolume / FFGL / VJing forums",
        "date": "1539246471",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "Xslfzs",
        "hidden": 0
      },
      {
        "text": "hi can i use this codes resolume arena 6 any idea",
        "date": "1539220688",
        "username": "momsul",
        "userpicture": "/img/profile.jpg",
        "id": "4ssfzl",
        "hidden": 0
      },
      {
        "text": "Just great :)",
        "date": "1539087653",
        "username": "rodo",
        "userpicture": "/img/profile.jpg",
        "id": "lsfBzl",
        "hidden": 0
      },
      {
        "text": "Featured in this video :) ! [video]http://youtu.be/7BB8TkY4Aeg[/video]",
        "date": "1532120625",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "lsjcDV",
        "hidden": 0
      },
      {
        "text": "Wow!",
        "date": "1529399636",
        "username": "yuletian",
        "userpicture": "/media/users/yuletian/profile.png",
        "id": "Xsjczy",
        "hidden": 0
      },
      {
        "text": "Mesmerisingly beautiful.",
        "date": "1526682866",
        "username": "metayan",
        "userpicture": "/img/profile.jpg",
        "id": "MsjczW",
        "hidden": 0
      },
      {
        "text": "It seems that those artifacts (line, dots and planes) appearing randomly are Intel-specific errors. After switching to nVidia, they are gone. ",
        "date": "1521891807",
        "username": "pjdevpl",
        "userpicture": "/img/profile.jpg",
        "id": "XsfcD7",
        "hidden": 0
      },
      {
        "text": "Wow, incredible work ",
        "date": "1521806762",
        "username": "AnnaEverson",
        "userpicture": "/media/users/AnnaEverson/profile.jpeg",
        "id": "XsfcWM",
        "hidden": 0
      },
      {
        "text": "why how much stronger",
        "date": "1514617836",
        "username": "SummyRen",
        "userpicture": "/img/profile.jpg",
        "id": "MtGSWw",
        "hidden": 0
      },
      {
        "text": "Spectacular. Any idea how to eleminate that white plain \"fields\" appearing sometimes ? Or white lines/dots ?",
        "date": "1513687160",
        "username": "gaix",
        "userpicture": "/img/profile.jpg",
        "id": "ltVXWR",
        "hidden": 0
      },
      {
        "text": "TDM this one is really great! :love: :love: :love: IT! \n\n@zproxy\nThat 360 is really great, actually better than the real shader in terms of contrast. Very nice implement.",
        "date": "1510827431",
        "username": "ingagard",
        "userpicture": "/img/profile.jpg",
        "id": "lttSRl",
        "hidden": 0
      },
      {
        "text": "hey guys , im developing a native shadertoy like app free and opensource feel free to check it out and contribute if you are interested.\nhttps://github.com/arminkz/ShaderToy.NET\n",
        "date": "1508086768",
        "username": "arminkz",
        "userpicture": "/media/users/arminkz/profile.png",
        "id": "XltSzM",
        "hidden": 0
      },
      {
        "text": "360 at [video]https://www.youtube.com/watch?v=c1bwIQs0F2k[/video]",
        "date": "1505763534",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "4lG3DG",
        "hidden": 0
      },
      {
        "text": "great one) ",
        "date": "1505219377",
        "username": "MarioNaybor",
        "userpicture": "/img/profile.jpg",
        "id": "llKGzK",
        "hidden": 0
      },
      {
        "text": "random black things appearing on this shader...",
        "date": "1501691579",
        "username": "Imsure1200q_1UWE130",
        "userpicture": "/media/users/Imsure1200q_1UWE130/profile.jpeg",
        "id": "llt3Ws",
        "hidden": 0
      },
      {
        "text": "Hi,Here is Chinese friends",
        "date": "1501128556",
        "username": "AlexZhou",
        "userpicture": "/img/profile.jpg",
        "id": "Ml33Dj",
        "hidden": 0
      },
      {
        "text": "This is so beautiful my heart can barely take it no more",
        "date": "1500882386",
        "username": "etale_cohomology",
        "userpicture": "/media/users/etale_cohomology/profile.png",
        "id": "XtcGDS",
        "hidden": 0
      },
      {
        "text": "Shader Tater. I like this. Why did i say 'Shader tater'..? Okay, well all i have to say, you are good with shader.",
        "date": "1500860088",
        "username": "KittenXilla",
        "userpicture": "/img/profile.jpg",
        "id": "XlcGWS",
        "hidden": 0
      },
      {
        "text": "I'm blown away! This is gorgeous!",
        "date": "1500226522",
        "username": "Bitzawolf",
        "userpicture": "/media/users/Bitzawolf/profile.png",
        "id": "MldGRB",
        "hidden": 0
      },
      {
        "text": "[b]nexor[/b], Thanks",
        "date": "1496759551",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "MlcGzr",
        "hidden": 0
      },
      {
        "text": "At the 54th line you use PI as number and not as the variable you made.",
        "date": "1496757749",
        "username": "nexor",
        "userpicture": "/img/profile.jpg",
        "id": "llcGzr",
        "hidden": 0
      },
      {
        "text": "crazy cool!!!!",
        "date": "1496176856",
        "username": "seaside",
        "userpicture": "/img/profile.jpg",
        "id": "MdVSDc",
        "hidden": 0
      },
      {
        "text": "Wow!Amazing!!!",
        "date": "1495848824",
        "username": "Nurutomo",
        "userpicture": "/img/profile.jpg",
        "id": "XsKXW3",
        "hidden": 0
      },
      {
        "text": "how to put in ENB series v0.306",
        "date": "1493743941",
        "username": "RitongaA1991",
        "userpicture": "/img/profile.jpg",
        "id": "MsKXzV",
        "hidden": 0
      },
      {
        "text": "http://i.imgur.com/2QSKDkH.png",
        "date": "1491861149",
        "username": "djmips",
        "userpicture": "/img/profile.jpg",
        "id": "MdKSDh",
        "hidden": 0
      },
      {
        "text": "For the first time this no longer works for me, tried in two browsers. Some strange artifacts (GTX 1080 - 376.53)",
        "date": "1491860830",
        "username": "djmips",
        "userpicture": "/img/profile.jpg",
        "id": "ldKSDh",
        "hidden": 0
      },
      {
        "text": "This is simply awesome!",
        "date": "1489770850",
        "username": "Heresticus",
        "userpicture": "/img/profile.jpg",
        "id": "4sVXzh",
        "hidden": 0
      },
      {
        "text": "If I move the camera origin by adjusting the y component of ori, it can only be raised by a little before the results become pretty bad.  Is there anything that I can do to allow the camera to be set to an arbitrary altitude, while still getting good results?",
        "date": "1488406322",
        "username": "kyfwana",
        "userpicture": "/img/profile.jpg",
        "id": "XsdXWf",
        "hidden": 0
      },
      {
        "text": "This is awesome\nCould you please link some articles to read about the math behind generating sea waves that you used?",
        "date": "1487625159",
        "username": "madcake",
        "userpicture": "/img/profile.jpg",
        "id": "ls3SDB",
        "hidden": 0
      },
      {
        "text": "Cool stuff, you are a genius!!!",
        "date": "1487338494",
        "username": "karl1972",
        "userpicture": "/img/profile.jpg",
        "id": "4ddSzs",
        "hidden": 0
      },
      {
        "text": "wow - looks really realistic",
        "date": "1484165996",
        "username": "DaniJan",
        "userpicture": "/img/profile.jpg",
        "id": "ldcXWr",
        "hidden": 0
      },
      {
        "text": "\u770b\u4e0d\u5230\uff1f",
        "date": "1482209280",
        "username": "WangYunpeng",
        "userpicture": "/img/profile.jpg",
        "id": "MdcSRn",
        "hidden": 0
      },
      {
        "text": "amazing",
        "date": "1482130603",
        "username": "ArtStealer",
        "userpicture": "/img/profile.jpg",
        "id": "XdcXRn",
        "hidden": 0
      },
      {
        "text": "amazing",
        "date": "1479314211",
        "username": "samuelalderson",
        "userpicture": "/img/profile.jpg",
        "id": "XdG3zc",
        "hidden": 0
      },
      {
        "text": "Things, even!  Though \"thinks\" may be one of my better Freudian slips on any subject lately...I love to ponder the beauty of shaders!",
        "date": "1479293512",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "XdG3Rc",
        "hidden": 0
      },
      {
        "text": "Well said, that I understand fully.  I've often thought ShaderToy (or shaders in general) could advance even further with a really definitive shader desktop app, one that can actually do thinks ST can't easily - introduce custom textures and meshes, and do a lot of vertex work.    I can only imagine how brilliant some of the best shaders on here could be if integrated with mesh tools, user textures, et cetera.  ",
        "date": "1479293356",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "4syGRc",
        "hidden": 0
      },
      {
        "text": "@CaliCoastReplay you are right, let me rephrase: originally I wanted to say there is no place for this shader in AAA because of it's over-reliance on (actually exclusively) ALU work: raymarching, noise functions, normals calculations etc. One of the main reasons for these is because of Shadertoy and its principles and limitations. The shader itself, its underlying principles of generating waves, mixing in nice colours and reflections, can be isolated, extracted and redone within other systems.\n\nWith all that said, TDM's work still stands on its own and continues to inspire and awe countless people - like the guy I mentioned in my original comment :D",
        "date": "1479292998",
        "username": "valentingalea",
        "userpicture": "/img/profile.jpg",
        "id": "XsyGRc",
        "hidden": 0
      },
      {
        "text": "So - \"there is no room for an effect this heavy in a AAA title\", but \"nothing here [is] so crucial that [it] cannot be replicated\"?\n\nI'm a bit unclear as to what you are trying to say, to put it mildly.",
        "date": "1479285265",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "XsGGRc",
        "hidden": 0
      },
      {
        "text": "@CaliCoastReplay you are overthinking it :) without detracting TDM's effort there is nothing here so crucial that cannot be replicated, just excellent detail work",
        "date": "1479143808",
        "username": "valentingalea",
        "userpicture": "/img/profile.jpg",
        "id": "lsV3zK",
        "hidden": 0
      },
      {
        "text": "I would guess that one of the reasons this water is so good is that it *doesn't* use vertex animation.  Meshes and vertices produce inaccuracy in the modeling, in much the same way that an MP3 is lossy when it comes to sound - because instead of modeling the actual position of the wave height at any given point between vertices, you're approximating it...now of course with modern shaders you can (and need to) do a lot better than simple lerps, and model actual curves, but even in the best of AAA titles these days I can still usually see a vertex transition that isn't curved well enough if I'm really looking.\n\nBut there are many reasons this shader excels - excellent specular reflections, great color choices, and also in particular noise modeling that accurately simulates real ocean surfaces.\n\nI don't know that one would be able to translate this model well to a mesh-based approach somehow - but I don't know that one wouldn't, either.  Perhaps TDM would have an opinion? ",
        "date": "1479129987",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "ldKGzK",
        "hidden": 0
      },
      {
        "text": "@CaliCoastReplay hard to say because a lot of this is very shadertoy specific and an explicit exercise in limitations. For example you can drop the raymarching and move to a vertex animation/tessellation system in a proper game.\n\nWhat makes this water so good btw? :) Is it the motion or shapes of the waves? Is it the colors? The reflections? I wouldn't say it's realistic but it offers a bit of everything in a nice round package...",
        "date": "1479128684",
        "username": "valentingalea",
        "userpicture": "/img/profile.jpg",
        "id": "lsV3RK",
        "hidden": 0
      },
      {
        "text": "Ahhhhh, I see.  \n\nActually this shader can be made reasonably performant with a few tweaks, but even then it's using a majority of the GPU, so I do understand where you're coming from.\n\nWhat do you think it'll take to actually allow shaders this realistic in the AAA space, if I may ask?",
        "date": "1479123135",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "ldK3RK",
        "hidden": 0
      },
      {
        "text": "@CaliCoastReplay my post had a sarcastic tone to it that maybe didn't make it thru. There is no room for an effect this heavy in a modern AAA title at the moment.",
        "date": "1479122772",
        "username": "valentingalea",
        "userpicture": "/img/profile.jpg",
        "id": "MsVGRK",
        "hidden": 0
      },
      {
        "text": "valentingalea:  Um, the license this was released on is for non-commercial use only.  If the Gears of War 4 team actually used it then Microsoft owes TDM some royalties...",
        "date": "1479122236",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "lsVGRK",
        "hidden": 0
      },
      {
        "text": "the amount of interest for this shader is amazing! I was part of the Gears of War 4 dev team and at some point an environment artist asked me if it's possible to use this :D I was like suuuuure :)",
        "date": "1478365008",
        "username": "valentingalea",
        "userpicture": "/img/profile.jpg",
        "id": "ldVGDm",
        "hidden": 0
      },
      {
        "text": "very good!I see that the fps is high,but this effect can be realized in the mobile with OpenGL ES 2.0?",
        "date": "1474976729",
        "username": "zhangshuangxue",
        "userpicture": "/img/profile.jpg",
        "id": "4dKGzz",
        "hidden": 0
      },
      {
        "text": "what programming language is used for this and how is this made?",
        "date": "1472665248",
        "username": "krellex",
        "userpicture": "/img/profile.jpg",
        "id": "Xst3zs",
        "hidden": 0
      },
      {
        "text": "great!",
        "date": "1472284206",
        "username": "FlashyTheCreeper",
        "userpicture": "/media/users/FlashyTheCreeper/profile.png",
        "id": "MstGRX",
        "hidden": 0
      },
      {
        "text": "[b]CaliCoastReplay[/b] Yes, hit me up with an email: tdmaav@gmail.com",
        "date": "1472239856",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "4ddGRf",
        "hidden": 0
      },
      {
        "text": "Probably my favorite ShaderToy shader of all time.  Is this available for commercial license?",
        "date": "1472220559",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "Xdt3zX",
        "hidden": 0
      },
      {
        "text": "great work",
        "date": "1468490801",
        "username": "pengcaochao",
        "userpicture": "/img/profile.jpg",
        "id": "XscGz4",
        "hidden": 0
      },
      {
        "text": "great work",
        "date": "1468490491",
        "username": "pengcaochao",
        "userpicture": "/img/profile.jpg",
        "id": "4dcGz4",
        "hidden": 0
      },
      {
        "text": "heightMapTracing() using the binary search,but map(p) is not sorted. :)",
        "date": "1467621910",
        "username": "hcf",
        "userpicture": "/img/profile.jpg",
        "id": "llSSWc",
        "hidden": 0
      },
      {
        "text": "60fps on GTX1080",
        "date": "1467259097",
        "username": "Takeyoshix",
        "userpicture": "/img/profile.jpg",
        "id": "XljSDV",
        "hidden": 0
      },
      {
        "text": "\u00e5\u00a4\u00aa\u00e7\u00be\u017d\u00e3\u20ac\u201a\u00e3\u20ac\u201a\u00e3\u20ac\u201a\u00e6\u02c6\u2018\u00e5\u00b7\u00b2\u00e7\u00bb\u008f\u00e6\u2022\u00a3\u00e8\u0090\u00bd\u00e4\u00ba\u2020\u00e4\u00b8\u20ac\u00e5\u0153\u00b0",
        "date": "1465365747",
        "username": "prohell",
        "userpicture": "/media/users/prohell/profile.jpeg",
        "id": "MlSXzV",
        "hidden": 0
      },
      {
        "text": "\u00e7\u00ae\u20ac\u00e7\u203a\u00b4\u00e5\u00b8\u2026",
        "date": "1464402287",
        "username": "qufangliu",
        "userpicture": "/img/profile.jpg",
        "id": "4ljSDw",
        "hidden": 0
      },
      {
        "text": "This is awesome. I am new to shadertoy and I am wondering what can I do with this other than watch it? Can I use this shader anywhere?",
        "date": "1462686071",
        "username": "Methexis_Studios",
        "userpicture": "/img/profile.jpg",
        "id": "ltBSDz",
        "hidden": 0
      },
      {
        "text": "works awesome on my 980ti (mac pro with OS X).\n\nhowever, on my macbook pro with intel graphics it flickers. might be shader precision?\n\nother than that: godly!",
        "date": "1461958508",
        "username": "Somian",
        "userpicture": "/img/profile.jpg",
        "id": "4tSSRm",
        "hidden": 0
      },
      {
        "text": "Very nice!",
        "date": "1460332110",
        "username": "maromero",
        "userpicture": "/media/users/maromero/profile.jpeg",
        "id": "XtlSWf",
        "hidden": 0
      },
      {
        "text": "I fix the problem by making some minor change in computation that avoid direct addition between SEA_TIME and uv here:\nhttps://www.shadertoy.com/view/MdGGzy",
        "date": "1455101578",
        "username": "fatcloud",
        "userpicture": "/img/profile.jpg",
        "id": "XtfSzr",
        "hidden": 0
      },
      {
        "text": "This is a great work!\nHowever I find a bug here. A lot white pixels appears on the sea after running for a while.\nSimply change the line\n\n    float SEA_TIME = iGlobalTime * SEA_SPEED;\n\nto\n\n    float SEA_TIME = iGlobalTime * SEA_SPEED + 100000.0;\n\nwill reproduce the bug immediately.\nIt guess the problem might be caused by loss of precision during addition of floating point numbers in uv + SEA_TIME in map and map_detailed.",
        "date": "1454989212",
        "username": "fatcloud",
        "userpicture": "/img/profile.jpg",
        "id": "lt2GDd",
        "hidden": 0
      },
      {
        "text": "So is this completely image based in the fragment shader? By this I mean there's no mesh vertex displacement happening?\n",
        "date": "1453215897",
        "username": "CogSimGuy",
        "userpicture": "/img/profile.jpg",
        "id": "Mtj3zK",
        "hidden": 0
      },
      {
        "text": "I love this! ",
        "date": "1452106252",
        "username": "owntheweb",
        "userpicture": "/media/users/owntheweb/profile.jpeg",
        "id": "4l2GW1",
        "hidden": 0
      },
      {
        "text": "Wonderful!",
        "date": "1448503338",
        "username": "lirentai",
        "userpicture": "/img/profile.jpg",
        "id": "Xll3D2",
        "hidden": 0
      },
      {
        "text": "I dunno when I can only write my own shader like this :'(\nI look at your codes and I totally don't understand what are u doing... lol\nCan someone who can give me some guides on how should I learn shader programming as I'm really interested in it",
        "date": "1445134758",
        "username": "birdkingz",
        "userpicture": "/img/profile.jpg",
        "id": "Mtf3W4",
        "hidden": 0
      },
      {
        "text": "Height map rendering is described on IQ website.\nRoot search is commonly known algorithm.\nBut how did you come up with sea_octave ?\nIs it some random functions that happened to look good, or is there some advanced math behind it ?",
        "date": "1443650134",
        "username": "lovelyH",
        "userpicture": "/media/users/lovelyH/profile.png",
        "id": "XtX3Wr",
        "hidden": 0
      },
      {
        "text": "This is Awesome. The AntiAliasing tip D Hoskins made. Would make this perfect!",
        "date": "1442187157",
        "username": "alfkuhl",
        "userpicture": "/media/users/alfkuhl/profile.jpeg",
        "id": "4lf3RN",
        "hidden": 0
      },
      {
        "text": "reeeeally amaaaaaazing",
        "date": "1440603978",
        "username": "jedi_cy",
        "userpicture": "/img/profile.jpg",
        "id": "XlXGzn",
        "hidden": 0
      },
      {
        "text": "I play Box of Rain when viewing.\nhttps://www.youtube.com/watch?v=b-z7uN9OjyI  ",
        "date": "1437587531",
        "username": "ArtScott",
        "userpicture": "/media/users/ArtScott/profile.jpeg",
        "id": "4djSzd",
        "hidden": 0
      },
      {
        "text": "I'm trying to use this as water plane in my game, or perhaps a sky box eventually.\nCould you help me with passing correctly the THREE js camera position as \"ori\" and angle as \"ang\" in this JSBin: http://jsbin.com/reqali/edit?html,js,output , so that the mouse camera controls work correctly? Currently I have just set a fixed top-down perspective on a plane in my game, but it would be cool to map the shader with correct perspective, perhaps even to a sky box.",
        "date": "1437161566",
        "username": "emh",
        "userpicture": "/img/profile.jpg",
        "id": "XdjXzc",
        "hidden": 0
      },
      {
        "text": "now you can try android version of it (as gpu benchmark):\nhttps://play.google.com/store/apps/details?id=com.nature.seascape",
        "date": "1431100534",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "XdBXzD",
        "hidden": 0
      },
      {
        "text": "This make me wonder if the entire universe is a shader program.",
        "date": "1430502012",
        "username": "Aj_",
        "userpicture": "/media/users/Aj_/profile.png",
        "id": "Xs2XRh",
        "hidden": 0
      },
      {
        "text": "wow this is really impressive !!!",
        "date": "1428656051",
        "username": "Emuljan",
        "userpicture": "/media/users/Emuljan/profile.jpeg",
        "id": "4dlXDs",
        "hidden": 0
      },
      {
        "text": "Insane work! Any chance of an article to explain the finer points of how it works? Cheers!",
        "date": "1425294269",
        "username": "valentingalea",
        "userpicture": "/img/profile.jpg",
        "id": "ldsXzl",
        "hidden": 0
      },
      {
        "text": "My GTX-680 runs this full-screen at 60fps, so I'm sure there are many many more cards that will:-\n[url]http://www.videocardbenchmark.net/high_end_gpus.html[/url]",
        "date": "1419966083",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XssXD8",
        "hidden": 0
      },
      {
        "text": "Is there any cards on the market that can run these demos in fullscreen at 60fps ?",
        "date": "1419964242",
        "username": "saphire280x",
        "userpicture": "/img/profile.jpg",
        "id": "XdsXD8",
        "hidden": 0
      },
      {
        "text": "I think you might have found the shader that god is running on the actual ocean.",
        "date": "1418752248",
        "username": "airtight",
        "userpicture": "/media/users/airtight/profile.png",
        "id": "MdsXDn",
        "hidden": 0
      },
      {
        "text": "registered account to say it's amazing work",
        "date": "1418732874",
        "username": "jiaolu",
        "userpicture": "/img/profile.jpg",
        "id": "MslXDn",
        "hidden": 0
      },
      {
        "text": "true",
        "date": "1413834643",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "MdXSzH",
        "hidden": 0
      },
      {
        "text": "I see, and it suffers from the same problem as other interval based methods, that is not being able to predict which root it will converge to. But for cases when you (mostly) have only one possible root, like here, this is great.",
        "date": "1413832586",
        "username": "nimitz",
        "userpicture": "/media/users/nimitz/profile.png",
        "id": "ldXSzH",
        "hidden": 0
      },
      {
        "text": "it's interpolation search, very fast on linear increasing values (such as distance field). code is mine, algorithm is common.",
        "date": "1413816545",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "ldfXRH",
        "hidden": 0
      },
      {
        "text": "Finally got around to reading the code. That technique for heightmap intersection is great, is it your own work?",
        "date": "1413776522",
        "username": "nimitz",
        "userpicture": "/media/users/nimitz/profile.png",
        "id": "MdXSRH",
        "hidden": 0
      },
      {
        "text": "This is ******* amazing! A masterpiece in 185 lines of code.",
        "date": "1413402173",
        "username": "McRam",
        "userpicture": "/img/profile.jpg",
        "id": "4dfXRH",
        "hidden": 0
      },
      {
        "text": "Looks amazing!",
        "date": "1413323045",
        "username": "Chameleon",
        "userpicture": "/img/profile.jpg",
        "id": "XsXXz8",
        "hidden": 0
      },
      {
        "text": "This is one of the best CGI things I have ever seen. Simply beautiful.",
        "date": "1413139851",
        "username": "ayberkozgur",
        "userpicture": "/img/profile.jpg",
        "id": "MdlSzr",
        "hidden": 0
      },
      {
        "text": "Killer.",
        "date": "1413034883",
        "username": "mrgnou",
        "userpicture": "/media/users/mrgnou/profile.jpeg",
        "id": "MssXzn",
        "hidden": 0
      },
      {
        "text": "Awesome !!",
        "date": "1413021206",
        "username": "abhi_bansal",
        "userpicture": "/media/users/abhi_bansal/profile.jpeg",
        "id": "MslXzn",
        "hidden": 0
      },
      {
        "text": "There is some strange white noise in the first few seconds on my computer, but obviously this is incredible water it looks fantastic!",
        "date": "1413018480",
        "username": "ac3t1ne",
        "userpicture": "/media/users/ac3t1ne/profile.jpeg",
        "id": "MssSzn",
        "hidden": 0
      },
      {
        "text": "This is absolutely amazing. Awesome work!",
        "date": "1412734751",
        "username": "garcia",
        "userpicture": "/media/users/garcia/profile.gif",
        "id": "4dsXzn",
        "hidden": 0
      },
      {
        "text": "a few days, but i've working on water rendering before.",
        "date": "1412701477",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "XdsXzn",
        "hidden": 0
      },
      {
        "text": "Amazing best water ever seen, how long did you take to program it ?",
        "date": "1412697775",
        "username": "epascal",
        "userpicture": "/img/profile.jpg",
        "id": "4slXzn",
        "hidden": 0
      },
      {
        "text": "Genius work! AWESOME!",
        "date": "1412630840",
        "username": "Flavio",
        "userpicture": "/media/users/Flavio/profile.jpeg",
        "id": "4slSzn",
        "hidden": 0
      },
      {
        "text": "Awesome! :D",
        "date": "1412619760",
        "username": "fizzer",
        "userpicture": "/media/users/fizzer/profile.jpeg",
        "id": "4ssSRn",
        "hidden": 0
      },
      {
        "text": "The colors and static looks are almost perfect. But after looking at it for a while.. the waves move kind of linear. I miss this bouncing feel they usually have.",
        "date": "1412164214",
        "username": "ewerybody",
        "userpicture": "/media/users/ewerybody/profile.jpeg",
        "id": "ldXXRn",
        "hidden": 0
      },
      {
        "text": "Whooooww!! *drool* No shit: This makes me wanna goto the sea!! I need vacation! :|",
        "date": "1412155672",
        "username": "ewerybody",
        "userpicture": "/media/users/ewerybody/profile.jpeg",
        "id": "lsfSRn",
        "hidden": 0
      },
      {
        "text": "awesome!",
        "date": "1411984748",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "4dfSzr",
        "hidden": 0
      },
      {
        "text": "Amazing! :)",
        "date": "1411939395",
        "username": "4rknova",
        "userpicture": "/media/users/4rknova/profile.png",
        "id": "4sfXRr",
        "hidden": 0
      },
      {
        "text": "Best water Ive seen",
        "date": "1411936352",
        "username": "gloinart",
        "userpicture": "/media/users/gloinart/profile.jpeg",
        "id": "XsfXRr",
        "hidden": 0
      },
      {
        "text": "Incredible I love it. This is so damn impressive.",
        "date": "1411786612",
        "username": "Passion",
        "userpicture": "/img/profile.jpg",
        "id": "XsXXzn",
        "hidden": 0
      },
      {
        "text": "So true! :)",
        "date": "1411763489",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4dXXzn",
        "hidden": 0
      },
      {
        "text": "yeah, good idea. also, we can get squared length by dot(dist,dist).",
        "date": "1411761098",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "XdXXzn",
        "hidden": 0
      },
      {
        "text": "Hello again! I have a tip for cheap anti-aliasing, if you want it.\nPass the distance to the surface to the getNormal function like:\n[code]\n    vec3 dist = p - ori;\n    float d = length(dist);\n    vec3 n = getNormal(p, d*d*.0003);// Or whatever value that suits.\n[/code]\n\nAnd use the second parameter passed as the epsilon in the normal function.\nThis smooths distant details and prevents the shimmering pixel effect.\n",
        "date": "1411759918",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4sfSzn",
        "hidden": 0
      },
      {
        "text": "poljere, thanks! you can uncomment line 172 to enable fog.",
        "date": "1411758748",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "XsfSzn",
        "hidden": 0
      },
      {
        "text": "Looks great TDM. Love the water color! You could also add a bit of fog towards the horizon to make the transition between the water and the sky smoother :)",
        "date": "1411758454",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "4dfSzn",
        "hidden": 0
      },
      {
        "text": "yep, thank you!",
        "date": "1411757469",
        "username": "TDM",
        "userpicture": "/media/users/TDM/profile.jpeg",
        "id": "XdfSzn",
        "hidden": 0
      },
      {
        "text": "The ITER variable needs to be a constant at compile time, so passing a variable gives an error (GTX 680) on line 98.\nIt looks great setting the loop to a straight 5 though.",
        "date": "1411756685",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4sXSzn",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "MscSzf",
      "date": "1460605927",
      "viewed": 55071,
      "name": "Noise Contour",
      "username": "candycat",
      "description": "Draw noise contour by multi passes. Full-screen shows more detail. Mouse dragging is available. Try use videos as texture :)",
      "likes": 225,
      "published": 1,
      "flags": 32,
      "tags": [
        "noise",
        "cartoon",
        "edgedetection",
        "pencil",
        "npr"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "XdXGzn",
            "filepath": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
            "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define EdgeColor vec4(0.2, 0.2, 0.15, 1.0)\n#define BackgroundColor vec4(1,0.95,0.85,1)\n#define NoiseAmount 0.01\n#define ErrorPeriod 30.0\n#define ErrorRange 0.003\n\n// Reference: https://www.shadertoy.com/view/MsSGD1\nfloat triangle(float x)\n{\n\treturn abs(1.0 - mod(abs(x), 2.0)) * 2.0 - 1.0;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = floor(iTime * 16.0) / 16.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv += vec2(triangle(uv.y * rand(time) * 1.0) * rand(time * 1.9) * 0.005,\n\t\t\ttriangle(uv.x * rand(time * 3.4) * 1.0) * rand(time * 2.1) * 0.005);\n    \n    float noise = (texture(iChannel1, uv * 0.5).r - 0.5) * NoiseAmount;\n    vec2 uvs[3];\n    uvs[0] = uv + vec2(ErrorRange * sin(ErrorPeriod * uv.y + 0.0) + noise, ErrorRange * sin(ErrorPeriod * uv.x + 0.0) + noise);\n    uvs[1] = uv + vec2(ErrorRange * sin(ErrorPeriod * uv.y + 1.047) + noise, ErrorRange * sin(ErrorPeriod * uv.x + 3.142) + noise);\n    uvs[2] = uv + vec2(ErrorRange * sin(ErrorPeriod * uv.y + 2.094) + noise, ErrorRange * sin(ErrorPeriod * uv.x + 1.571) + noise);\n    \n    float edge = texture(iChannel0, uvs[0]).r * texture(iChannel0, uvs[1]).r * texture(iChannel0, uvs[2]).r;\n  \tfloat diffuse = texture(iChannel0, uv).g;\n    \n\tfloat w = fwidth(diffuse) * 2.0;\n\tvec4 mCol = mix(BackgroundColor * 0.5, BackgroundColor, mix(0.0, 1.0, smoothstep(-w, w, diffuse - 0.3)));\n\tfragColor = mix(EdgeColor, mCol, edge);\n    //fragColor = vec4(diffuse);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Depth and normal Pass\n#define PRECIS 0.001\n#define DMAX 20.0\nmat3 camMat;\nvec3 lightDir = normalize(vec3(5.0, 5.0, -4.0));\n\n// Distance functions by www.iquilezles.org\nfloat fSubtraction(float a, float b) {return max(-a,b);}\nfloat fIntersection(float d1, float d2) {return max(d1,d2);}\nvoid fUnion(inout float d1, float d2) {d1 = min(d1,d2);}\nfloat pSphere(vec3 p, float s) {return length(p)-s;}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\nfloat pTorus(vec3 p, vec2 t) {vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat pTorus2(vec3 p, vec2 t) {vec2 q = vec2(length(p.xy)-t.x,p.z); return length(q)-t.y;}\nfloat pCapsule(vec3 p, vec3 a, vec3 b, float r) {vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r;}\n\nfloat map(vec3 p)\n{\n\tfloat d = 100000.0;\n\n    fUnion(d, pRoundBox(p - vec3(0,-2.0,0), vec3(4,0.1,4), 0.2));\n\tfUnion(d, pSphere(p - vec3(2,0,2), 1.5));\n    fUnion(d, pSphere(p - vec3(3.5,-1.0,0.0), 0.8));\n    fUnion(d, pTorus(p - vec3(-2,0,2), vec2(1,0.3)));\n\tfUnion(d, pTorus2(p - vec3(-3,0,2), vec2(1,0.3)));\n    fUnion(d, pRoundBox(p - vec3(2,0.6,-2), vec3(0.1,0.1,1), 0.3));\n\tfUnion(d, pRoundBox(p - vec3(2,0,-2), vec3(0.1,1.5,0.1), 0.3));\n\tfUnion(d, pRoundBox(p - vec3(2,-0.4,-2), vec3(1.2,0.1,0.1), 0.3));\n    fUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-2,-1,-1.0), 0.3));\n\tfUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-1.0,-1,-2.5), 0.3));\n\tfUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-3.0,-1,-2.5), 0.3));\n\t\n\treturn d;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n                    \t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n                         \tmap(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = PRECIS * 30.0;\n    for( int i=0; i < 30; i++ )\n    {\n\t\tfloat distToSurf = map( ro + rd*t );\n        res = min(res, 8.0 * distToSurf / t);\n        t += distToSurf;\n        if(distToSurf < PRECIS || t > DMAX) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 raymarching(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 50; i++) {\n       \tfloat distToSurf = map(ro + t * rd);\n        t += distToSurf;\n        if (distToSurf < PRECIS || t > DMAX) break; \n    }\n    \n    vec4 col = vec4(0.0);\n    if (t <= DMAX) {\n        vec3 nor = normal(ro + t * rd);\n        col.z = 1.0 - abs((t * rd) * camMat).z / DMAX; // Depth\n        col.xy = (nor * camMat * 0.5 + 0.5).xy;\t// Normal\n        col.w = dot(lightDir, nor) * 0.5 + 0.5; // Diff\n        col.w *= shadow(ro + t * rd, lightDir);\n    }\n    \n    return col;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n    // Mouse\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    \n    // Camera position\n    float dist = 6.5;\n    vec3 ro = vec3(dist * cos(iTime * 0.1 + 6.0 * mo.x), 2.0 + mo.y * 4.0, dist * sin(iTime * 0.1 + 6.0 * mo.x));\n    \n    // Rotate the camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    // Compute the ray\n    camMat = setCamera(ro, target, 0.0);\n    vec3 rd = camMat * normalize(vec3(p.xy, 1.5));\n    \n    // calculate color\n\tfragColor = raymarching(ro, rd);\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XsXGR8",
            "channel": 0
          }
        ],
        "code": "// Edge detection Pass\n#define Sensitivity (vec2(0.3, 1.5) * iResolution.y / 400.0)\n\nfloat checkSame(vec4 center, vec4 samplef)\n{\n    vec2 centerNormal = center.xy;\n    float centerDepth = center.z;\n    vec2 sampleNormal = samplef.xy;\n    float sampleDepth = samplef.z;\n    \n    vec2 diffNormal = abs(centerNormal - sampleNormal) * Sensitivity.x;\n    bool isSameNormal = (diffNormal.x + diffNormal.y) < 0.1;\n    float diffDepth = abs(centerDepth - sampleDepth) * Sensitivity.y;\n    bool isSameDepth = diffDepth < 0.1;\n    \n    return (isSameNormal && isSameDepth) ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 sample0 = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 sample1 = texture(iChannel0, (fragCoord + vec2(1.0, 1.0)) / iResolution.xy);\n    vec4 sample2 = texture(iChannel0, (fragCoord + vec2(-1.0, -1.0)) / iResolution.xy);\n    vec4 sample3 = texture(iChannel0, (fragCoord + vec2(-1.0, 1.0)) / iResolution.xy);\n    vec4 sample4 = texture(iChannel0, (fragCoord + vec2(1.0, -1.0)) / iResolution.xy);\n    \n    float edge = checkSame(sample1, sample2) * checkSame(sample3, sample4);\n    \n    fragColor = vec4(edge, sample0.w, 1.0, 1.0);\n}",
        "name": "Buf B",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "@joric, commenting out line 22 of the \"Image\" tab (uv += ...) will remove the wobbliness.  keep in mind this makes the movement of the edges more obvious ",
        "date": "1550154769",
        "username": "johnmarinelli",
        "userpicture": "/img/profile.jpg",
        "id": "XlscWr",
        "hidden": 0
      },
      {
        "text": "Why camera is so wobbly? How to disable it?",
        "date": "1536153286",
        "username": "joric",
        "userpicture": "/img/profile.jpg",
        "id": "MslfD8",
        "hidden": 0
      },
      {
        "text": "Looks good :octopus:",
        "date": "1498925974",
        "username": "Davislast19",
        "userpicture": "/media/users/Davislast19/profile.jpeg",
        "id": "Xld3Wr",
        "hidden": 0
      },
      {
        "text": "checkSame() to honor, and i found that calculating 2 raymarch distances with 2 different epsilon within the same raymarching loop gives a neat translucend volumetric \"cellshader\"\nhttps://www.shadertoy.com/view/lsSyRd\n\nvoid rm3(vec3 o,vec3 r,inout float t,inout float t2){for(int i=0;i<rmIterations;++i){\n  float d2=df(o+r*t2);\n  if(d2>eps)t2+=d2*.5;\n  float d=df(o+r*t);\n  t+=d*.5;\n  #ifdef dynamicEps\n  d=pow(d,pow(t,.5));\n  #endif\n  if(d<eps*.05)break; }}\n\n{\n  float t=0.,t2=0.;//2 distances to the distanceField, with different epsilon.\n  rm3(RayOrigin,RayDirection,t,t2);\n   p=o+r*t2;//p is surface.xyz for t1 measure, within a distance field that is modulo repeated on 3 dimensions by fract(x)\n   p=fract(p)*mod(p,3.)*t2*t2/(t*t*t);//t is color. making distance cubes darker.\n}",
        "date": "1494052774",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "XdVXzc",
        "hidden": 0
      },
      {
        "text": "Awesome!",
        "date": "1485563317",
        "username": "chaosink",
        "userpicture": "/img/profile.jpg",
        "id": "ld3XzB",
        "hidden": 0
      },
      {
        "text": "very cool!",
        "date": "1479311805",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "XsGGzc",
        "hidden": 0
      },
      {
        "text": "Love it!",
        "date": "1461814213",
        "username": "drone1",
        "userpicture": "/img/profile.jpg",
        "id": "Xl2XzW",
        "hidden": 0
      },
      {
        "text": "cool stencil",
        "date": "1460923962",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "ltlSWs",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret2 haha, you found it!",
        "date": "1460646451",
        "username": "candycat",
        "userpicture": "/media/users/candycat/profile.jpeg",
        "id": "MtfSDl",
        "hidden": 0
      },
      {
        "text": "NB: also works with Britney's video and music as texture :-D",
        "date": "1460644543",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MlXSDl",
        "hidden": 0
      },
      {
        "text": "Thanks all! Now add more descriptions.",
        "date": "1460643965",
        "username": "candycat",
        "userpicture": "/media/users/candycat/profile.jpeg",
        "id": "MtXSDl",
        "hidden": 0
      },
      {
        "text": "nice ! \n( you should tell in description that mouse is available.\nand you could add tags like NPR, cartoon. )",
        "date": "1460620923",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "llfSWl",
        "hidden": 0
      },
      {
        "text": "Super idea and very nice realisation   :)",
        "date": "1460618982",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "MtXSWl",
        "hidden": 0
      },
      {
        "text": "rad!",
        "date": "1460616283",
        "username": "musurca",
        "userpicture": "/media/users/musurca/profile.png",
        "id": "4lfXDs",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "MtByRD",
      "date": "1560235369",
      "viewed": 323,
      "name": "Floating Bubbles edit with Mouse",
      "username": "MacroMachines",
      "description": "Edit of bubbles shader",
      "likes": 11,
      "published": 3,
      "flags": 0,
      "tags": [
        "bubbles",
        "slow",
        "floating"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tuv.x *=  iResolution.x / iResolution.y;\n\tvec2 ms = (iMouse.xy / iResolution.xy);\n    \n    // background\t \n\tvec3 color = vec3(0.9 + 0.1*uv.y);\n\n    // bubbles\t\n\tfor( int i=0; i<40; i++ )\n\t{\n        // bubble seeds\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n\n        // buble size, position and color\n\t\tfloat rad = 0.2 + 0.5*siz;\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.1+0.1*siz),1.0));\n\t\tfloat distToMs = length(pos - ms);\n        pos *= length(pos - (ms * 1.5-0.5));\n        float dis = length( uv - pos );\n        \n        \n\t\tvec3  col = mix( vec3(0.34,0.6,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\n\t\t\n        // render\n\t\tfloat f = length(uv-pos)/rad;\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\n\t}\n\n    // vigneting\t\n\tcolor *= sqrt(1.5-0.5*length(uv));\n\n\tfragColor = vec4(color,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "MttGz7",
      "date": "1468522689",
      "viewed": 77217,
      "name": "Ray Marching: Part 4",
      "username": "jlfwong",
      "description": "Part 4 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/",
      "likes": 14,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/**\n * Part 4 Challenges:\n * - Show the union instead of the intersection\n * - Show cube - sphere\n * - Show sphere - cube\n * - Subtract a new sphere from the cube/sphere intersection to make the top face into a \"bowl\"\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;\n    float cubeDist = cubeSDF(samplePoint);\n    return intersectSDF(cubeDist, sphereDist);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "WdBXWV",
      "date": "1554914604",
      "viewed": 3709,
      "name": "first image of a black hole",
      "username": "FabriceNeyret2",
      "description": "I confess: I faked it all :-p\n\nref: [img]https://www.jpl.nasa.gov/images/universe/20190410/blackhole20190410-16.jpg[/img]",
      "likes": 32,
      "published": 3,
      "flags": 0,
      "tags": [
        "blackhole",
        "nasa",
        "reproduction",
        "m87",
        "eventhorizon"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define f(a) exp( -10.* pow( length( U -.52*cos(a+vec2(0,33)) ) , 2. ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    \n    O =   ( .5-.5*cos(min(6.*length(U),6.3)) ) \n        * (    .7* vec4(1,.25,0,0)\n            + ( f(.65)+f(1.6)+f(2.8) ) * vec4(.8,.8,.5,0) );\n // O *= O;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Komolgorov complexity measure:\n\"the size of an information is the size of the smallest program that can compute it\"\n\nhttps://en.wikipedia.org/wiki/Kolmogorov_complexity",
        "date": "1557661320",
        "username": "scholarius",
        "userpicture": "/media/users/scholarius/profile.jpeg",
        "id": "4tByzG",
        "hidden": 0
      },
      {
        "text": "@MelBrandle: \"considering how momentous\",  \"and who\",  \"bad taste\" : what the hell are you meaning ? are you confusing applied science and religion ? \nBeside, considering all the various popular misunderstandings about this \"photography\" and the mythology around, there is a lot that could be said about it. Illustrating the low number of freedom it really contains is a start. Then, one could discuss the complexity of the reconstruction used considering the physically expected complexity in the result (but I'm not mastering enough all the aspects of the data and reconstruction to be sure, despite not so far to my domains of expertise.)",
        "date": "1557649225",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XtSyzG",
        "hidden": 0
      },
      {
        "text": "@mackycheese21: not exactly: CS / applied math teacher will tell \"what is the highest frequency in the image ? then you can safely sample it at twice this, after Shannon-Nyquist theorem\". Here, the brute data might be huge, but at the end of the day you still have the wave physics telling the size of the circle of confusion related to the size of the (virtual) telescope. Concretely speaking; you cannot expect more than the equivalent of a 16x16 pixels image interpolated for magnification (numbers estimated from the image, I did not calculated). So, the final \"image\" (that is not at all a \"photography of the black hole\") really carries very few octets of information. Still, this small image is not white noise, and thus it is further compressible. My shader is smaller than a 16x16 uncompressed image, but a compressed image would probably be even smaller ;-)",
        "date": "1557648891",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4lBcRG",
        "hidden": 0
      },
      {
        "text": "Every CS professor: Its impossible to compress arbitrary information!!  FabriceNeyret: Oh yeah?? huge amounts of data that formed the image => 231 chars",
        "date": "1557611216",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "XtByRG",
        "hidden": 0
      },
      {
        "text": "I don't see anything in bad taste about making a rendering to celebrate the momentous first such image of a black hole, as long you don't pretend your rendering is the original. \"Imitation is the sincerest form of flattery.\" This sketch is a fine and light-hearted homage.",
        "date": "1557165349",
        "username": "huttarl",
        "userpicture": "/media/users/huttarl/profile.jpeg",
        "id": "Ml2cDW",
        "hidden": 0
      },
      {
        "text": "Considering how momentous the first image of a black hole is and who actually came up with it, I think it's in really bad taste to try and copy it. But in any case, it's good to bring attention to such  things happening in the universe if only you could say you did so on your own effort.",
        "date": "1557124615",
        "username": "MelBrandle",
        "userpicture": "/media/users/MelBrandle/profile.jpeg",
        "id": "XtjcDD",
        "hidden": 0
      },
      {
        "text": "Considering how momentous the first image of a black hole is and who actually came up with it, I think it's in really bad taste to try and copy it. But in any case, it's good to bring attention to such  things happening in the universe if only you could say you did so on your own effort.",
        "date": "1557124460",
        "username": "MelBrandle",
        "userpicture": "/media/users/MelBrandle/profile.jpeg",
        "id": "4l2yDD",
        "hidden": 0
      },
      {
        "text": "Thanks @huttarl",
        "date": "1555079951",
        "username": "scholarius",
        "userpicture": "/media/users/scholarius/profile.jpeg",
        "id": "XtByzh",
        "hidden": 0
      },
      {
        "text": "WOW. Very nice.\nI fork this for the first video of a black hole :D \nhttps://www.shadertoy.com/view/td2XWK",
        "date": "1555077509",
        "username": "semmais",
        "userpicture": "/media/users/semmais/profile.jpeg",
        "id": "4lSyzh",
        "hidden": 0
      },
      {
        "text": "Haha Shadertoy is making us all look like idiots!\nYesterday I got \"could not post your comment\", but when I wrote again, it was already posted",
        "date": "1555075030",
        "username": "scholarius",
        "userpicture": "/media/users/scholarius/profile.jpeg",
        "id": "XtSyzh",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret2: \"like, dozens?\" There are dozens under the \"black hole\" keyword, but you have to do a fair bit of sifting to find some that have specific features. I guess what @scholarius means by \"like this\" is those that have some kind of gravitational lensing. And yes, there are some, e.g. https://www.shadertoy.com/view/XlBXzd, https://www.shadertoy.com/view/XdX3DN, https://www.shadertoy.com/view/Mds3DM, https://www.shadertoy.com/view/Xt3GWj",
        "date": "1555074613",
        "username": "huttarl",
        "userpicture": "/media/users/huttarl/profile.jpeg",
        "id": "4lBcRh",
        "hidden": 0
      },
      {
        "text": "(oops: shadertoy was emitting \"couldn't post\" error messages, while it did stack them :-/ )",
        "date": "1555074582",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XlBcRh",
        "hidden": 0
      },
      {
        "text": "well, the Nasa \"image\" is far to be a direct true image as well...",
        "date": "1555074520",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4tBcRh",
        "hidden": 0
      },
      {
        "text": "well, the Nasa \"image\" is far to be a direct true image as well...",
        "date": "1555074437",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XtBcRh",
        "hidden": 0
      },
      {
        "text": "well, the Nasa \"image\" is far to be a direct true image as well...",
        "date": "1555074364",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4lScRh",
        "hidden": 0
      },
      {
        "text": "well, the Nasa \"image\" is far to be a direct true image as well...",
        "date": "1555073650",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XlScRh",
        "hidden": 0
      },
      {
        "text": "@fabrice\nyes, but are they real? ;)",
        "date": "1555073595",
        "username": "scholarius",
        "userpicture": "/media/users/scholarius/profile.jpeg",
        "id": "4tScRh",
        "hidden": 0
      },
      {
        "text": "@scholarius: like, dozens ? [url]https://www.shadertoy.com/results?query=black+hole[/url]\nTrick; type your favorite keywork in shadertoy search box ;-)",
        "date": "1555054524",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ltjcRz",
        "hidden": 0
      },
      {
        "text": "I'll be impressed when someone makes a shadertoy that looks like 1960s footage of the moon landing.",
        "date": "1555020264",
        "username": "mds2",
        "userpicture": "/media/users/mds2/profile.png",
        "id": "lt2czR",
        "hidden": 0
      },
      {
        "text": "is there some shader like this on shadertoy already?\nhttp://spiro.fisica.unipd.it/~antonell/schwarzschild/live/",
        "date": "1555017072",
        "username": "scholarius",
        "userpicture": "/media/users/scholarius/profile.jpeg",
        "id": "lljczR",
        "hidden": 0
      },
      {
        "text": "is there some shader like this on shadertoy already?\n\nhttp://spiro.fisica.unipd.it/~antonell/schwarzschild/live/",
        "date": "1555014628",
        "username": "scholarius",
        "userpicture": "/media/users/scholarius/profile.jpeg",
        "id": "Ml2yzR",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret2 yes I know yours has nothing to do with what I asked, c refers to the different simulated images they produce in the paper, I am asking just because you are a physicist. But you are right this would be better in a Stack Exchange site. I am curious because the simulated image had the same dark spot on a side that the real one, so the math model must be close and I wanted to understand what it meant.\n@ollj every implicit surface if you are high enough.",
        "date": "1555007262",
        "username": "felipunkerito",
        "userpicture": "/img/profile.jpg",
        "id": "ll2cRR",
        "hidden": 0
      },
      {
        "text": "Hey Fabrice, good job! I thought I had a good idea for a shader today only to find out everybody thought of this yesterday hehehe.",
        "date": "1554989997",
        "username": "cbrpnk",
        "userpicture": "/media/users/cbrpnk/profile.jpeg",
        "id": "MljyRR",
        "hidden": 0
      },
      {
        "text": "Awesome stuff",
        "date": "1554985134",
        "username": "BlackStar",
        "userpicture": "/img/profile.jpg",
        "id": "lljyRR",
        "hidden": 0
      },
      {
        "text": "every blurry metaball looks like quantum physics, while you are drunk enough, or close enough to planck.",
        "date": "1554971394",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4ljczz",
        "hidden": 0
      },
      {
        "text": "@felipunkerito: well, this very forum is really not the place to discuss another science paper: this shader is related to none of these features (while others are), your questions seems really focused about a (specialized) physics paper, and there are no physicists around (plus the shadertoy narrow threadless forums are not convenient for long discussions). -> better to ask on a (astro)physics forum/usenet/stackexchange/quora/facebook. ;-)\n\nOr possibly the question is really narrowly related to the shader and I didn't understand it (sorry, then). E.g., the \"c\" you ask about (no c in my code). Maybe you ask what are the feature shown in the (real) image ? Still a bit far from the raw joke this shader is,\nbut, just 3 reminders: the (real) image is ultra-low resolution, something like equivalent of 16x16 or 32x32 then blurinterpolated, so you can't compare it to high resolution images. Which are simulations, BTW, meaning they generally omit many important visual components. And we are by no way close to this BH. ;-)",
        "date": "1554965863",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Xt2cRz",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret2 Nice! By the way can you explain what does c means: (a) The moderately realistic accretion disk of figure 14 but with the black hole's spin slowed from \ufffc to \ufffc for reasons discussed in the text. (b) This same disk with its colours (light frequencies \u03bd) Doppler shifted and gravitationally shifted. (c) The same disk with its specific intensity (brightness) also shifted in accord with Liouville's theorem, \ufffc. This image is what the disk would truly look like to an observer near the black hole.\nfrom [url=https://iopscience.iop.org/article/10.1088/0264-9381/32/6/065001]here[/url]\n",
        "date": "1554952361",
        "username": "felipunkerito",
        "userpicture": "/img/profile.jpg",
        "id": "4tjyRz",
        "hidden": 0
      },
      {
        "text": "I meant 213 chars ...",
        "date": "1554941130",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "4ljczR",
        "hidden": 0
      },
      {
        "text": "214 chars: vec4(,.0) > vec4(,0)\n[code]#define f(a) exp(-pow(length(U-.52*cos(a+vec2(0,33)) ),2.)/.1)//\n#define mainImage(O,u)                                        \\\n    vec2  R = iResolution.xy,                                 \\\n          U = ( u+u - R ) / R.y;                              \\\n    O = ( .5-.5*cos(min(6.*length(U),6.3)) )                  \\\n        * (    vec4(.7,.17,0,0)                              \\\n            + ( f(.65)+f(1.6)+f(2.8) ) * vec4(.8,.8,.5,0) )[/code]",
        "date": "1554941112",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "XljczR",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret2\nwhat about adding \"size of solar system\" like this [url]https://i.imgur.com/hjsmIC4.png[/url] :D",
        "date": "1554940446",
        "username": "morimea",
        "userpicture": "/media/users/morimea/profile.jpeg",
        "id": "XtjczR",
        "hidden": 0
      },
      {
        "text": "@Del: could be a lot smaller ;-)\n\n214 chars:\n[code]#define f(a) exp(-pow(length(U-.52*cos(a+vec2(0,33)) ),2.)/.1)//\n#define mainImage(O,u)                                        \\\n    vec2  R = iResolution.xy,                                 \\\n          U = ( u+u - R ) / R.y;                              \\\n    O = ( .5-.5*cos(min(6.*length(U),6.3)) )                  \\\n        * (    vec4(.7,.17,.0,0)                              \\\n            + ( f(.65)+f(1.6)+f(2.8) ) * vec4(.8,.8,.5,0) )\n[/code]\n\nor even -7 with this, but does it work on windows ?\n#define f(a) exp(-dot(R = U-.52*cos(a+vec2(0,33)),R)/.1)",
        "date": "1554927821",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4ljyzR",
        "hidden": 0
      },
      {
        "text": "Where's the gravitational lensing?? :-)",
        "date": "1554919641",
        "username": "huttarl",
        "userpicture": "/media/users/huttarl/profile.jpeg",
        "id": "XljcRR",
        "hidden": 0
      },
      {
        "text": "looks really good, especially with O = pow(O,vec4(2)); at the end",
        "date": "1554918082",
        "username": "DJDoomz",
        "userpicture": "/media/users/DJDoomz/profile.png",
        "id": "XtjcRR",
        "hidden": 0
      },
      {
        "text": "Spot on!",
        "date": "1554917319",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "4t2yRR",
        "hidden": 0
      },
      {
        "text": "how did you compress all that data down to 268 chars? omg",
        "date": "1554914976",
        "username": "Del",
        "userpicture": "/media/users/Del/profile.jpeg",
        "id": "4ljyRR",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wl23Dy",
      "date": "1560983361",
      "viewed": 5,
      "name": "A 2d line",
      "username": "vchizhov",
      "description": "A simple example of drawing a 2d line.",
      "likes": 0,
      "published": 1,
      "flags": 0,
      "tags": [
        "line",
        "distance",
        "hessenormalform",
        "hyperplane"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates in [-1,1]^2\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = 2.0*uv-vec2(1.0);\n    \n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 res = vec2(aspectRatio,1.0); // don't stretch out the screen\n    \n    ndc *= res; // rescale ndc to account for the aspect ratio\n\n    // first line point (note that coordinates are originally given in [-1,1]^2 and then\n    // remapped to account for stretching)\n    vec2 v0 = res * vec2(-cos(iTime),-sin(iTime));\n    //vec2 v0 = res*vec2(-1,-1);\n    \n    // second line point - reflected around (0,0)\n    vec2 v1 = -v0;\n    // normalized direction from v0 to v1\n    vec2 dir = normalize(v1-v0);\n    \n    \n    // pixel normalized coordinates (aspect ratio preserved)\n    vec2 p = ndc;\n    // some point on the line\n    vec2 c = v0;\n    // unit length normal of the line\n    vec2 n = vec2(-dir.y,dir.x);\n    // signed distance from p to the line\n    float dist = dot(p-v0, n);\n    \n    // thickness of the line\n    float thickness = 0.01 + 0.04*abs(sin(2.0*iTime));\n    //vec3 col = vec3(abs(dist)<thickness);\n    vec3 col = vec3(1.0-smoothstep(abs(dist), 0.0, thickness));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wl23WG",
      "date": "1560943957",
      "viewed": 28,
      "name": "\u5927\u9f99\u732b - Quicky#003",
      "username": "totetmatt",
      "description": "Thanks IQ's resources for square formula",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "2d"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define time iTime\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x+uv.y;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\nvec3 sq(vec2 uv){\n vec2 ra =  vec2(0.1,0.1);\n float b = sdBox(uv,ra);\n float bump = abs(sin(iTime/3.)/50.);\n return  mix( vec3(0.) , vec3(1.0), 1.0-smoothstep(0.019+bump/2.,0.020+bump,abs(b)) );\n}\nvec3 scene(vec2 uv) {\nuv = sin(uv*10.)/(10.+sin(time)*.10);;\nreturn max(sq(uv * rotate2d(time)),sq(((uv* -rotate2d(time*3.))+vec2(0.1,0.1))* rotate2d(-time+log(time)))) ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n    float off = sin(time)*0.5+.5;\n    vec3 color = mix(vec3(0.3,0.,0.32)+off,vec3(.5,.9,.9)-off,scene(uv));\n    \n    fragColor = vec4(\n        color,\n        1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wl2GWy",
      "date": "1560963003",
      "viewed": 88,
      "name": "f(z) = i^z + c",
      "username": "JJJK",
      "description": "https://www.reddit.com/r/math/comments/c2fiql/a_very_interesting_fractal/\n\nQuick&dirty shadertoy \"port\".",
      "likes": 1,
      "published": 3,
      "flags": 0,
      "tags": [
        "fractalsmandelbrot"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\nMade by reddit user /u/jpayne36\n*/\n\nfloat scale = 1.0 / 128.0;\nvec2 pos = vec2(0.0, 0.0);\n\nfloat e = 2.718281828459045;\nfloat pi = 3.14159265;\n\nstruct cmplx { float r; float i; };\ncmplx c() { return cmplx(0.0, 0.0); }\ncmplx c(float r) { return cmplx(r, 0.0); }\ncmplx c(float r, float i) { return cmplx(r, i); }\n\ncmplx add(cmplx c1, cmplx c2) { return cmplx(c1.r + c2.r, c1.i + c2.i); }\ncmplx sub(cmplx c1, cmplx c2) { return cmplx(c1.r - c2.r, c1.i - c2.i); }\ncmplx mul(cmplx c1, cmplx c2) { return cmplx(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r); }\ncmplx div(cmplx c1, cmplx c2)\n{\n\tif (c2.r == 0.0 && c2.i == 0.0) { return c(); }\n\treturn cmplx( (c1.r*c2.r + c1.i*c2.i)/(c2.r*c2.r + c2.i*c2.i), (c1.i*c2.r - c1.r*c2.i)/(c2.r*c2.r + c2.i*c2.i) );\n}\n\nfloat c_abs(cmplx c) { return sqrt(c.r*c.r + c.i*c.i); }\ncmplx c_pow(cmplx c1, cmplx c2)\n{\n\tif (c1.r == 0.0 && c1.i == 0.0) { return c(); }\n\tfloat r, a, c, d;\n\tr = c_abs(c1);\n\tif (c1.r == 0.0) { a = pi / 2.0; } else { a = atan(c1.i/c1.r); }\n\tc = ( pow(r, c2.r) )/( pow(e, c2.i*a) );\n\td = c2.i*log(r) + c2.r*a;\n\treturn cmplx(c*cos(d), c*sin(d));\n}\n\nint mandelbrot(cmplx a, cmplx z, int iters)\n{\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tif (c_abs(z) > 100.0) { return i; }\n\t\tz = add( c_pow(c(0.0,1.0), z), a );\n\t}\n\treturn iters;\n}\n\nvec4 effect(vec2 screen_coords)\n{\n\tvec2 uv = screen_coords/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\tvec2 xy = vec2( (uv.x - iResolution.x/iResolution.y/2.0)/scale + pos.x, (uv.y - 0.5)/scale + pos.y );\n\tint a = mandelbrot( c(xy.x, xy.y), c(), 100 );\n\tfloat col = float(a)/100.0;\n\treturn vec4(vec3(col), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = sin(iTime*0.2)*0.5 + 0.5;\n    pos = vec2(0.0, -0.2);\n    float maxZoom = exp(9.5);\n    scale = mix(1.0/128.0, maxZoom/128.0, f);\n    \n    fragColor = effect(fragCoord);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wl2Gzc",
      "date": "1560550686",
      "viewed": 166,
      "name": "Flat water effects 2",
      "username": "mrange",
      "description": "Continuation of my work on flat water effects here: https://www.shadertoy.com/view/ttSGRc\nWanted analytical normals for improved precision\n",
      "likes": 7,
      "published": 3,
      "flags": 0,
      "tags": [
        "raytracing",
        "fbm"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n\n// Color computation inspired by: https://www.shadertoy.com/view/Ms2SD1\n\n// Computes normal analytical for improved precision\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst float gravity = 1.0;\nconst float waterTension = 0.01;\n\nconst vec3 skyCol1 = vec3(0.6, 0.35, 0.3);\nconst vec3 skyCol2 = vec3(1.0, 0.3, 0.3);\nconst vec3 sunCol1 =  vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 =  vec3(1.0,0.8,0.7);\nconst vec3 seaCol1 = vec3(0.1,0.2,0.2);\nconst vec3 seaCol2 = vec3(0.8,0.9,0.6);\n\nvec2 wave(in float t, in float a, in float w, in float p) {\n  float x = t;\n  float y = a*sin(t*w + p);\n  return vec2(x, y);\n}\n\nvec2 dwave(in float t, in float a, in float w, in float p) {\n  float dx = 1.0;\n  float dy = a*w*cos(t*w + p);\n  return vec2(dx, dy);\n}\n\nvec2 gravityWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return wave(t, a ,k, w*iTime);\n}\n\nvec2 capillaryWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return wave(t, a, k, w*iTime);\n}\n\nvec2 gravityWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvec2 capillaryWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nmat2 mrot(in float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\nmat2 mtrans(in mat2 m) {\n  return mat2(m[0][0], m[1][0], m[0][1], m[1][1]);\n}\n\nvec4 sea(in vec2 p, in float ia) {\n  float y = 0.0;\n  vec3 d = vec3(0.0);\n\n  float k = 1.0;\n  float kk = 1.3;\n  float a = ia*0.19;\n  float aa = 1.0/(kk*kk);\n\n  float h = 10.0;\n  p *= 0.5;\n  \n  float angle = 0.0;\n\n  for (int i = 0; i < 3; ++i) {\n    mat2 fr = mrot(angle);\n    mat2 rr = mtrans(fr);\n    vec2 pp = fr*p;\n    y += gravityWave(pp.y + float(i), a, k, h).y;\n    vec2 dw = gravityWaveD(pp.y + float(i), a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    vec2 rd2 = rr*d2;\n    \n    d += vec3(rd2.x, dw.y, rd2.y);\n\n    angle += float(i);\n    k *= kk;\n    a *= aa;\n  }\n\n  for (int i = 3; i < 7; ++i) {\n    mat2 fr = mrot(angle);\n    mat2 rr = mtrans(fr);\n    vec2 pp = fr*p;\n    y += capillaryWave(pp.y + float(i), a, k, h).y;\n    vec2 dw = capillaryWaveD(pp.y + float(i), a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    vec2 rd2 = rr*d2;\n    \n    d += vec3(rd2.x, dw.y, rd2.y);\n\n    angle += float(i);\n    k *= kk;\n    a *= aa;\n  }\n  \n  vec3 t = normalize(d);\n  vec3 nxz = normalize(vec3(t.z, 0.0, -t.x));\n  vec3 nor = cross(t, nxz);\n\n  return vec4(y, nor);\n}\n\nvec3 sunDirection() {\n  vec3 dir = normalize(vec3(0, 0.13, 1));\n  return dir;\n}\n\nvec3 skyColor(vec3 rd) {\n  vec3 sunDir = sunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  \n  vec3 final = vec3(0.0);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n\n  final += 0.5*sunCol1*pow(sunDot, 30.0);\n\n  final += 4.0*sunCol2*pow(sunDot, 300.0);\n    \n  return final;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.1, 1.0));\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = vec3(0.0);\n\n  float dsea = (0.0 - ro.y)/rd.y;\n  \n  vec3 sunDir = sunDirection();\n  \n  vec3 sky = skyColor(rd);\n  \n  if (dsea > 0.0) {\n    vec3 p = ro + dsea*rd;\n    vec4 s = sea(p.xz, 1.0);\n    float h = s.x;    \n    vec3 nor = s.yzw;\n    nor = mix(nor, vec3(0.0, 1.0, 0.0), smoothstep(0.0, 200.0, dsea));\n\n    float fre = clamp(1.0 - dot(-nor,rd), 0.0, 1.0);\n    fre = pow(fre, 3.0);\n    float dif = mix(0.25, 1.0, max(dot(nor,sunDir), 0.0));\n    \n    vec3 refl = skyColor(reflect(rd, nor));\n    vec3 refr = seaCol1 + dif*sunCol1*seaCol2*0.1; \n    \n    col = mix(refr, 0.9*refl, fre);\n    \n    float atten = max(1.0 - dot(dsea,dsea) * 0.001, 0.0);\n    col += seaCol2*(p.y - h) * 2.0 * atten;\n    \n    col = mix(col, sky, 1.0 - exp(-0.01*dsea));\n    \n  } else {\n    col = sky;\n  }\n\n  fragColor = vec4(col,1.0);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "looks great and stays at a high framerate even in fullscreen on my potato laptop, good shit",
        "date": "1560763258",
        "username": "eiglow_",
        "userpicture": "/img/profile.jpg",
        "id": "MlScW3",
        "hidden": 0
      },
      {
        "text": "Nice water and light.",
        "date": "1560565856",
        "username": "lovelyH",
        "userpicture": "/media/users/lovelyH/profile.png",
        "id": "lljcDV",
        "hidden": 0
      },
      {
        "text": "nice",
        "date": "1560551939",
        "username": "elenzil",
        "userpicture": "/media/users/elenzil/profile.jpeg",
        "id": "ll2yDV",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "WlSGDG",
      "date": "1560850748",
      "viewed": 50,
      "name": "Rectangle clip by floor function",
      "username": "FrozenL",
      "description": "This is a shader for the Explanation of floor function()",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "rectangle",
        "floor"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n     vec3 color = vec3(0.0);\n\tvec2 lb=(st)* 1.0/0.1;\n    lb=floor(lb);\n    vec2 lt=floor((1.0-st)*10.0);\n    vec2 inv_lb=1.0-lb;\n    vec2 inv_lt=1.0-lt;\n    color=vec3(lb.x*lt.x*lt.y*lb.y)+ //white\n        (lt.y)*(lb.y)*vec3(1.0,0.0,0.0)+ //red\n        (lt.x*lb.x)*vec3(0.0,1.0,0.0)+ //green\n        (inv_lb.x*inv_lb.y*inv_lt.x*inv_lt.y)*vec3(0.0,0.0,1.0);//blue\n    \n    fragColor = vec4(color,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wlj3Rc",
      "date": "1560545162",
      "viewed": 208,
      "name": "Land of Water",
      "username": "wyatt",
      "description": "hold mouse to make mountains\n\n\n[url]javascript:  (function(){if(Effect.prototype.Paint.toString().length>1000){_Paint=Effect.prototype.Paint;} Effect.prototype.Paint = function(...args){for(var i=0; i<4;i++){_Paint.apply(this,args);}}})()[/url]",
      "likes": 8,
      "published": 3,
      "flags": 32,
      "tags": [
        "fluid",
        "automata",
        "physics",
        "erosion"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Controls in Common\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 \n        n = (C(U+vec2(0,1))),\n        e = (C(U+vec2(1,0))),\n        s = (C(U-vec2(0,1))),\n        w = (C(U-vec2(1,0)));\n    vec4 c = C(U);\n    vec3 no = normalize(vec3(e.x-w.x+e.y-w.y,n.x-s.x+n.y-s.y,.5));\n    Q = abs(sin(1.+3.*c.z+sqrt(c.y)*(1.+.5*vec4(1,2,3,4))));\n    float a = .5;\n    no.zy *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    no.zx *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    Q*=max(0.,.2+.8*no.z);\n\t\n    \n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Calculate forces and pressure\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = A(U);\n    vec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0)),\n        c = C(U),\n        nc = C(U+vec2(0,1)),\n        ec = C(U+vec2(1,0)),\n        sc = C(U-vec2(0,1)),\n        wc = C(U-vec2(1,0));\n    Q.xy -= 1./(1.+2.*sqrt(c.y))*(\n        // slope force\n        0.25*(.5*vec2(ec.x-wc.x,nc.x-sc.x)+vec2(ec.y-wc.y,nc.y-sc.y))+\n        // pressure force\n        0.25*vec2(e.z-w.z,n.z-s.z)+\n        // magnus force\n        0.25*Q.w*vec2(n.w-s.w,e.w-w.w));\n    Q.xy *= min(1.,c.y);\n    // divergence\n    Q.z  = 0.25*(s.y-n.y+w.x-e.x+n.z+e.z+s.z+w.z);\n    // curl\n    Q.w = 0.25*(s.x-n.x+w.y-e.y);\n    if (length(Q.xy) > .8) Q.xy = .8*normalize(Q.xy);\n    \n    //Boundary conditions\n    if (iFrame<1) Q = vec4(0);\n    \n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "#define R iResolution.xy\n#define A(U) texture(iChannel0, (U)/R)\n#define B(U) texture(iChannel1, (U)/R)\n#define C(U) texture(iChannel2, (U)/R)\n#define D(U) texture(iChannel3, (U)/R)\n\n#define N 3.\n\n#define PRECIPITATION 1.\n#define EVAPORATION .0001",
        "name": "Common",
        "description": "",
        "type": "common"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XsXGR8",
            "channel": 0
          }
        ],
        "code": "// Advect along velocity and curl feild\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    for (float i = 0.; i< N;i++) {\n        Q = A(U);\n        float co = cos(Q.w/N), si = sin(Q.w/N);\n        U -= Q.xy*mat2(co,-si,si,co)/N;\n    }\n    Q = A(U);\n}",
        "name": "Buffer B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4sXGR8",
            "channel": 0
          }
        ],
        "code": "// Advect along velocity and curl feild\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    for (float i = 0.; i< N;i++) {\n        Q = A(U);\n        float co = cos(Q.w/N), si = sin(Q.w/N);\n        U -= Q.xy*mat2(co,-si,si,co)/N;\n    }\n    Q = C(U);\n}",
        "name": "Buffer C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "XdX3Rn",
            "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
            "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XdfGR8",
            "channel": 0
          }
        ],
        "code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    Q = C(U);\n    // neighborhood\n    vec4 \n        a = A(U),\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0)),\n    \tnc = C(U+vec2(0,1)),\n        ec = C(U+vec2(1,0)),\n        sc = C(U-vec2(0,1)),\n        wc = C(U-vec2(1,0));\n    Q = mix(Q,0.25*(nc+ec+sc+wc),vec4(0.,.1,0,0));\n    // divergence \n    Q += 0.25*(s.y*sc-n.y*nc+w.x*wc-e.x*ec);\n    \n    // x : height y : water, z : sediment \n    float m = 0.25*(D(U+vec2(0,1)).x+D(U+vec2(1,0)).x+D(U-vec2(1,0)).x+D(U-vec2(0,1)).x);\n    float me = D(U).x;\n    float l = m-me;\n   \tQ.x = me + 0.01*l*l*l;\n    if (iMouse.z>0.) Q.x += .5/(1.+.01*dot(U-iMouse.xy,U-iMouse.xy));\n    float x = .05*(Q.y*length(a.xy)*(1.-Q.z)-.1*Q.z);\n    Q.z += x;\n    Q.x -= x;\n    Q.y = Q.y*(1.-EVAPORATION) + PRECIPITATION/R.x;\n    Q = max(Q,0.);\n    // boundary conditions\n    if (iFrame<5)Q = vec4(10.+1.-U.y/R.y+.1*B(U).x+2.*exp(-length(U-0.5*R)/R.y),.3,0,0);\n    if (U.x<2.||U.y<2.||R.y-U.y<2.||R.x-U.x<2.) Q*=0.;\n\n}",
        "name": "Buffer D",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "Very useful JS function!",
        "date": "1560863237",
        "username": "Gaktan",
        "userpicture": "/img/profile.jpg",
        "id": "MtScDc",
        "hidden": 0
      },
      {
        "text": "Excellent! ",
        "date": "1560716886",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "4lByDc",
        "hidden": 0
      },
      {
        "text": "cool! I could see this being used as a terrain bumpmap.",
        "date": "1560682396",
        "username": "Yusef28",
        "userpicture": "/img/profile.jpg",
        "id": "XtBcD3",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wlj3Wy",
      "date": "1560965947",
      "viewed": 20,
      "name": "slider",
      "username": "eclypse",
      "description": "slider",
      "likes": 0,
      "published": 1,
      "flags": 0,
      "tags": [
        "slider"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dfGRn",
            "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
            "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "Xsf3Rn",
            "filepath": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png",
            "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    float t = pow(fract(iTime * 0.5), 5.);\n    float progress = t;\n    float slide = smoothstep(uv.x, uv.x + .01, progress);\n    \n   \tvec4 img = texture(iChannel0, uv);\n    vec4 img1 = texture(iChannel1, uv);\n    // Output to screen\n    fragColor = mix(img, img1, slide);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wlj3z3",
      "date": "1560529280",
      "viewed": 325,
      "name": "Stackless Quadtree Search",
      "username": "paniq",
      "description": "Enumerating the leaves of a quadtree intersecting an isosurface. No stack required. Solution is also applicable to binary search and octree recursion.",
      "likes": 12,
      "published": 3,
      "flags": 0,
      "tags": [
        "binary",
        "quadtree",
        "search",
        "stackless"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// source channel for texture font\n#define font_texture_source iChannel1\n// draw a letter with the given texture coordinate\nvoid letter(ivec2 l);\nvoid letter(int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces );\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nuint part1by1 (uint x) {\n    x = (x & 0x0000ffffu);\n    x = ((x ^ (x << 8u)) & 0x00ff00ffu);\n    x = ((x ^ (x << 4u)) & 0x0f0f0f0fu);\n    x = ((x ^ (x << 2u)) & 0x33333333u);\n    x = ((x ^ (x << 1u)) & 0x55555555u);\n    return x;\n}\n    \nuint compact1by1(uint x) {\n    x = (x & 0x55555555u);\n    x = ((x ^ (x >> 1)) & 0x33333333u);\n    x = ((x ^ (x >> 2)) & 0x0f0f0f0fu);\n    x = ((x ^ (x >> 4)) & 0x00ff00ffu);\n    x = ((x ^ (x >> 8)) & 0x0000ffffu);\n    return x;\n}\n\nuvec2 unpack_morton2x16(uint p) {\n    return uvec2(\n        compact1by1(p),\n        compact1by1(p >> 1));\n}\n    \nuint pack_morton2x16(uvec2 v) {\n\treturn part1by1(v.x) | (part1by1(v.y) << 1);\n}\n\nfloat map(vec2 p) {\n    float d0 = length(p) - 0.5;\n    float d1 = length(p + vec2(-0.25,0.0)) - 0.3;\n    float d2 = length(p + vec2(0.0, 0.5)) - 0.2;\n    return max(min(d0,d2), -d1);\n}\n\n#define MAX_LEVEL 7u\n\nvec3 get_rect(uint c, uint level) {\n    uvec2 v = unpack_morton2x16(c);\n    float r = 1.0 / float(1u << level);\n    vec2 center = (vec2(v) / float(1u << MAX_LEVEL)) * 2.0 - 1.0 + r;\n    return vec3(center, r);\n}\n\nvoid draw_rect(uint c, uint level) {\n    vec3 rc = get_rect(c, level);\n    //rc.z -= 0.002;// * float(level);\n    rectangle(rc.xy - rc.z, vec2(rc.z) * 2.0);\n}\n\nuint find_lsb(uint value) {\n    // with GL4, this loop can be replaced with\n    // a single use of findLSB()\n    uint count = 0u;\n    for (uint i = 0u; i < MAX_LEVEL; ++i) {\n        if ((value & 3u) != 0u)\n            break;\n        count += 2u;\n        value >>= 2u;\n    }\n    return count;\n}\n\nuint lowest_level(uint p) {\n    uint used_levels = min(MAX_LEVEL, find_lsb(p) / 2u);\n    return MAX_LEVEL - used_levels; \n}\n\nvoid draw_point(uint p, uint level) {\n    float l = float(1u << MAX_LEVEL);\n\tfloat x = float(p) / (l * l);\n    x = x*2.0 - 1.0;\n    circle(x, -0.9 + float(level)*0.01, 0.003);\n}\n\nuint surface_cells_found = 0u;\nuint surface_cell_misses = 0u;\nuint total_steps = 0u;\n\nbool walk(inout uint p, inout uint level, bool is_active) {\n    const uint topstep = 1u << (MAX_LEVEL * 2u);\n    if (p >= topstep)\n        return false;\n    vec3 rc = get_rect(p, level);\n    float d = map(rc.xy);\n    uint stepsz = topstep >> (level * 2u);\n    bool hit = abs(d) < (rc.z * sqrt(2.0));\n    if (hit) {\n        set_source_rgb(0.0,1.0,0.0);\n        draw_point(p, level);\n        fill();\n        if ((level == MAX_LEVEL)||is_active) {\n            draw_rect(p, level);\n            stroke();\n            if (level == MAX_LEVEL) {\n            \tsurface_cells_found++;\n            }\n        }\n    } else {\n        surface_cell_misses++;\n        set_source_rgb(1.0,0.0,0.0);\n        draw_point(p, level);\n        fill();\n        if (is_active) {\n            draw_rect(p, level);\n            stroke();\n        }\n    }\n    if (hit && (level < MAX_LEVEL)) {\n        level += 1u;\n    } else {\n        p += stepsz;\n        level = lowest_level(p);\n    }\n    if (is_active)\n        return false;\n    return true;\n}\n\nvoid paint() {\n    surface_cells_found = 0u;\n    \n    set_source_rgb(vec3(0.0));\n    clear();\n    \n    set_line_width_px(1.0);\n    set_source_rgb(vec3(1.0));\n    add_field(map(get_origin()));\n    stroke();\n    \n    set_line_width_px(1.0);\n    \n    set_source_rgb(vec3(0.0));\n    \n    uint p = 0u;\n    uint level = 0u;\n    int maxi = iFrame % 1600;\n    for (int i = 0; i < 1600; ++i) {\n        total_steps++;\n        if (!walk(p, level, (i == maxi)))\n            break;\n    }\n  \n    \n    \n}\n\nvoid paint_post(inout vec4 fragColor, vec2 fragCoord) {\n\n    vec3 c = PrintValue((fragCoord - vec2(0.0, 10.0)) / vec2(8.0, 15.0), \n\t\tfloat(surface_cells_found), 10.0, 0.0) * vec3(0.0,1.0,0.0);\n\n    c += PrintValue((fragCoord - vec2(0.0, 30.0)) / vec2(8.0, 15.0), \n\t\tfloat(surface_cell_misses), 10.0, 0.0) * vec3(1.0,0.0,0.0);\n\n    c += PrintValue((fragCoord - vec2(0.0, 50.0)) / vec2(8.0, 15.0), \n\t\tfloat(total_steps), 10.0, 0.0);\n\n    \n    fragColor += vec4(c, 1.0);\n   \n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(int lx, int ly) {\n    letter(ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n    paint_post(fragColor, fragCoord);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Thank you for the detailed explanation :)",
        "date": "1560771621",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "MlBcW3",
        "hidden": 0
      },
      {
        "text": "The numbers on the left display the total steps performed, the number of misses, and the number of surface elements found at the deepest level.",
        "date": "1560720472",
        "username": "paniq",
        "userpicture": "/media/users/paniq/profile.jpeg",
        "id": "4tScDc",
        "hidden": 0
      },
      {
        "text": "The graph shows the cells visited as the algorithm walks the z-order curve. The deeper the cell visited, the higher the dot is. A green dot was reported to contain surface. A red dot was a miss.",
        "date": "1560720412",
        "username": "paniq",
        "userpicture": "/media/users/paniq/profile.jpeg",
        "id": "XtScDc",
        "hidden": 0
      },
      {
        "text": "It's working again now + new graphics! Could you explain how to interpret the graph? ",
        "date": "1560716689",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "XlByDc",
        "hidden": 0
      },
      {
        "text": "applied the fixes you suggested",
        "date": "1560712409",
        "username": "paniq",
        "userpicture": "/media/users/paniq/profile.jpeg",
        "id": "4lSyDc",
        "hidden": 0
      },
      {
        "text": "The shader doesn't compile in Chrome and Firefox, for some reason. But if I chance surface_cells_found, surface_cells_misses and total_steps to be uint (and make the initializations \"0u\"), then it compiles in both browsers.\n\nNice shader!",
        "date": "1560685209",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4lSyWc",
        "hidden": 0
      },
      {
        "text": "This is awesome :)",
        "date": "1560535267",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "MtjcWV",
        "hidden": 0
      },
      {
        "text": "More technical notes: parallelization is a bit weird here... you'd use a fixed number of threads that cover a portion of the curve. e.g. 64 threads would split up a 4x4x4 octree region. occupancy is then not so good... if a thread doesn't find any results, it's wasted. on the upside, it all completes in a single pass.\n\nanother approach could be to do a smaller fixed number of steps and then check how much ground a thread has covered. threads that have completed can then take over the remaining work of threads which have only covered 25% or less of their area (because there's a lot of stuff in it).",
        "date": "1560531257",
        "username": "paniq",
        "userpicture": "/media/users/paniq/profile.jpeg",
        "id": "ltjcWV",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wt23WG",
      "date": "1560940392",
      "viewed": 26,
      "name": "Simplex Gradient",
      "username": "BlackCat",
      "description": "Simplex Gradient",
      "likes": 0,
      "published": 1,
      "flags": 0,
      "tags": [
        "gradient"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define SPEED 1.0\n\n#define TOP_COLOR vec3(.082,.09,.11)\n#define BOTTOM_COLOR vec3(.796,.204,.122)\n//#define TOP_COLOR vec3(.0,.0,.0)\n//#define BOTTOM_COLOR vec3(1.,1.,1.)\n\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n// snoise function author @patriciogv ( patriciogonzalezvivo.com ) - 2015\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}\n\nfloat grad(vec2 uv)\n{\n\treturn uv.y + sin(.66 * uv.x * uv.x * cos(2. * uv.x) * 30.6) / 40. + snoise(vec3((uv * 20.).xy, SPEED * iTime)) / 20.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\tvec3 col = mix(BOTTOM_COLOR, TOP_COLOR, grad(uv));\n\n\tfragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wt2GRG",
      "date": "1560002081",
      "viewed": 458,
      "name": "Cubic Dance",
      "username": "MadEqua",
      "description": "Entry for the June 2019 ShaderToy compo from Graphics Programming Discord. ",
      "likes": 8,
      "published": 3,
      "flags": 0,
      "tags": [
        "cubes",
        "repetition",
        "rainbow"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define PRIMARY_STEPS 32\n#define SECONDARY_STEPS 16\n\n#define RM_EPSILON 0.01\n#define BIAS_EPSILON 0.02\n\n#define MAX_DIST 30.\n\n#define REFLECTIONS 1\n#define SHADOWS 1\n\nstruct Light {\n    vec3 dir;\n    vec3 diffColor;\n    vec3 specColor;\n};\n\nstruct ScenePoint {\n    vec3 p;\n    vec3 color; //Color of material\n    float d; //Distance to closest object\n    float t; //Distance on ray that generated this point\n};\n\nLight lights[4];\n\nfloat rand(float v) {\n    return fract(sin(v) * 5454.7367);\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 4451.5453);\n}\n\nvec3 cam2world(vec3 v, vec3 pos, vec3 lookAt) {\n    vec3 z = normalize(lookAt - pos);\n    vec3 y = vec3(0., 1., 0.);\n    vec3 x = normalize(cross(z, y));\n    y = normalize(cross(x, z));\n    return normalize(mat3(x, y, z) * v);\n}\n\nvec2 repeat(inout vec2 p, vec2 size) {\n\tvec2 h = size * .5;\n\tvec2 cell = floor((p + h) / size);\n\tp = mod(p + h, size) - h;\n\treturn cell;\n}\n\nfloat roundBox(vec3 p, vec3 c, vec3 b, float r) {\n    vec3 d = abs(p - c) - b;\n    return length(max(d, 0.)) - r + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\n// All components are in the range [0\u20261], including hue.\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n\nfloat stoppingCurve(float t, float stopFactor) {\n  return mix(rand(floor(t)), rand(floor(t) + 1.), pow(smoothstep(0., 1., fract(t)), stopFactor));\n}\n\nScenePoint scene(vec3 p, int neighboursToCheck) {\n    ScenePoint result;\n\n    float dist = MAX_DIST;\n    vec2 cellId;\n    vec3 repP;\n\n    for(int x = -neighboursToCheck; x <= neighboursToCheck; ++x) {\n        for(int y = -neighboursToCheck; y <= neighboursToCheck; ++y) {\n            vec3 currentRepP = p;\n            vec2 currentCellId = repeat(currentRepP.xy, vec2(1.));\n\n            vec2 offset = vec2(float(x), float(y));\n            currentCellId += offset;\n\n            currentRepP.xy -= offset; // * cellSize = 1.0\n\n            float timeOffset1 = mod(currentCellId.x * currentCellId.y, 2.0);\n            float timeOffset2 = mod(currentCellId.x + currentCellId.y, 2.0);\n            float timeOffset3 = mod(currentCellId.x, 2.0);\n            float timeOffset4 = mod(currentCellId.y, 2.0);\n            float timeOffsetFinal = mix(mix(timeOffset1, timeOffset2, sin(iTime * .4 + 56.2) * .5 + .5),\n                                        mix(timeOffset3, timeOffset4, sin(iTime * .5 + 12.5) * .5 + .5),\n                                        sin(iTime * .6 + 23.4) * .5 + .5);\n\n            currentRepP.z += stoppingCurve(1.7 * iTime + timeOffsetFinal, 5.) * 2.5;\n\n            const float minSize = .31;\n            const float maxSize = .43;\n            float sizeAnim = stoppingCurve(0.9 * iTime + timeOffsetFinal, 5.) * (maxSize - minSize) + minSize;\n            float currentCubeDist = roundBox(currentRepP, vec3(0.), vec3(sizeAnim), .07);\n            if(currentCubeDist < dist) {\n                dist = currentCubeDist;\n                cellId = currentCellId;\n                repP = currentRepP;\n            }\n        }\n    }\n\n    float wallX = (-cellId.x + 6.) / 13.;\n    float cubeDiagonal = (repP.x + .5) * (repP.y + .5);\n\n    vec3 cubeBaseHsv = vec3(wallX, 1., 1.);\n    cubeBaseHsv.r += .1 * rand(cellId.y);\n\n    vec3 cubeColor1 = hsv2rgb(cubeBaseHsv);\n    vec3 cubeColor2 = hsv2rgb(vec3(cubeBaseHsv.r + .2 * rand(cellId.x), cubeBaseHsv.g, cubeBaseHsv.b));\n\n    result.color = mix(cubeColor1, cubeColor2, cubeDiagonal);\n    result.d = dist;\n    return result;\n}\n\nbool rm(vec3 ro, vec3 rd, out ScenePoint sp, int steps, int neighboursToCheck) {\n    float t = 0.;\n    vec3 p;\n\n    for(int i = 0; i < steps && t < MAX_DIST; ++i) {\n        p = ro + rd * t;\n        sp = scene(p, neighboursToCheck);\n        if(sp.d < RM_EPSILON) {\n            sp.p = p;\n            sp.t = t;\n            return true;\n        }\n        t += sp.d;\n    }\n    return false;\n}\n\nvec3 normal(ScenePoint sp) {\n    vec2 e = vec2(RM_EPSILON, 0.);\n    float x = scene(sp.p - e.xyy, 1).d;\n    float y = scene(sp.p - e.yxy, 1).d;\n    float z = scene(sp.p - e.yyx, 1).d;\n    return normalize(vec3(sp.d) - vec3(x, y, z));\n}\n\nfloat cheapAo(vec3 p, vec3 n, float dist) {\n    float d = scene(p + n * dist, 1).d / dist;\n    return clamp(d, 0., 1.);\n}\n\n/*float ao(vec3 p, vec3 n, float strength) {\n    const int AO_SAMPLES = 2;\n    float k = 1.;\n    float d = 0.;\n    float occ = 0.;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        d = scene(p + .1 * k * n, 0).d;\n        occ += 1. / pow(2., k) * (k * .1 - d);\n        k += 1.;\n    }\n    return 1. - clamp(strength * occ, 0., 1.);\n}*/\n\nvec3 lighting(vec3 cameraPos, vec3 normal, ScenePoint sp) {\n    vec3 albedo = sp.color;\n    vec3 specular = vec3(1.);\n    float shininess = 100.;\n\n    vec3 V = normalize(cameraPos - sp.p);\n\n    vec3 sum = vec3(0.);\n    for(int i = 0; i < 4; ++i) {\n        vec3 L = -lights[i].dir;\n        vec3 H = normalize(V + L);\n\n        float difFactor = max(0., dot(L, normal));\n        float specFactor = pow(max(0., dot(H, normal)), shininess);\n        sum += lights[i].diffColor * albedo * difFactor +\n               lights[i].specColor * specular * specFactor;\n    }\n    return sum;\n}\n\nvec3 shadeAndReflection(vec3 cameraPos, vec3 rd, ScenePoint sp) {\n    vec3 result;\n\n    vec3 normal = normal(sp);\n    vec3 light = lighting(cameraPos, normal, sp);\n    float ao = cheapAo(sp.p, normal, .15);\n\n    bool hit;\n    result = light * ao;\n    \n#if REFLECTIONS\n    ScenePoint reflectionSp;\n    vec3 reflected = reflect(rd, normal);\n    hit = rm(sp.p + reflected * BIAS_EPSILON, reflected, reflectionSp, SECONDARY_STEPS, 1);\n    if(hit) {\n        result = mix(light, lighting(cameraPos, reflected, reflectionSp), .5) * ao;\n    }\n#endif\n    \n#if SHADOWS\n    ScenePoint shadowSp;\n    hit = rm(sp.p + normal * BIAS_EPSILON, -lights[0].dir, shadowSp, SECONDARY_STEPS, 1);\n    if(hit) {\n        result *= vec3(.2);\n    }\n#endif\n    \n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lights[0].dir = normalize(vec3(0., -.3, -1.));\n    lights[0].diffColor = vec3(1.);\n    lights[0].specColor = vec3(1.);\n\n    lights[1].dir = normalize(vec3(1., 0., 0.));\n    lights[1].diffColor = vec3(.3);\n    lights[1].specColor = vec3(.05);\n\n    lights[2].dir = normalize(vec3(0., 1., 0.));\n    lights[2].diffColor = vec3(.3);\n    lights[2].specColor = vec3(.05);\n\n    lights[3].dir = normalize(vec3(-1., 0., 0.));\n    lights[3].diffColor = vec3(.3);\n    lights[3].specColor = vec3(.05);\n\n    vec2 uv = (gl_FragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    float curve = stoppingCurve(iTime * .5 + 12., 5.);\n    float curve2 = stoppingCurve(iTime * .8 + 195., 50.);\n\n    vec3 cameraPos = vec3(6. * (curve - .5) + iTime, 1.9 * (curve2 + .5), 10.);\n    vec3 lookAt = vec3(iTime, 0., 0.);\n    vec3 rd = cam2world(vec3(uv, 1.), cameraPos, lookAt); \n\n    ScenePoint sp;\n    vec3 col = vec3(.05);\n\n    bool hit = rm(cameraPos, rd, sp, PRIMARY_STEPS, 1);\n    if(hit) {\n        col = shadeAndReflection(cameraPos, rd, sp);\n    }\n\n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col, 1.);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Wt2GWG",
      "date": "1560936419",
      "viewed": 39,
      "name": "Molecular Waltz",
      "username": "dr2",
      "description": "  Waltzing with molecules (mouseable).\n  Rigid-body molecular dynamics; depending on view, the ridden molecule \n  is either transparent or shown in grey.\n",
      "likes": 3,
      "published": 3,
      "flags": 32,
      "tags": [
        "collision",
        "physics",
        "md",
        "rigidbody",
        "moleculardynamics"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// \"Molecular Waltz\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nmat3 QtToRMat (vec4 q);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\n#define S_BIG  1  // big/small system - must also change in buffer shader\n#if S_BIG\nconst int nMolE = 6;\n#else\nconst int nMolE = 5;\n#endif\n\nvec3 rSph[4], ltDir, qnHit, rdSign, vnBlk;\nfloat dstFar, hbLen;\nint idObj, idMol, rideMol;\nbool riding;\nconst int nMol = nMolE * nMolE * nMolE;\nconst int nsMol = 4;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen, rsLen;\n  vec3 eWid;\n  float dMin, d;\n  dMin = dstFar;\n  sLen = vec4 (vec3 (hbLen - 0.4), 0.);\n  if (riding) {\n    d = - PrBoxDf (p, vec3 (sLen));\n    if (d < dMin) { dMin = d;  idObj = 1; }\n  } else {\n    rsLen = vec4 (sLen.xyz * rdSign, 0.);\n    eWid = vec3 (0.04);\n    d = min (min (\n       PrBoxDf (p - rsLen.xww, eWid + sLen.wyz),\n       PrBoxDf (p - rsLen.wyw, eWid + sLen.xwz)),\n       PrBoxDf (p - rsLen.wwz, eWid + sLen.xyw));\n    if (d < dMin) { dMin = d;  idObj = 1; }\n    p = abs (p);\n    d = min (min (\n       PrBoxDf (p - sLen.wyz, eWid + sLen.xww),\n       PrBoxDf (p - sLen.xwz, eWid + sLen.wyw)),\n       PrBoxDf (p - sLen.xyw, eWid + sLen.wwz));\n    if (d < dMin) { dMin = d;  idObj = 2; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SphHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec3 rm, v, vn;\n  float dMin, b, d, w, sz;\n  dMin = dstFar;\n  sz = 0.5;\n  for (int n = 0; n < nMol; n ++) {\n    if (n == rideMol && riding) continue;\n    rm = Loadv4 (4 * n).xyz;\n    mRot = QtToRMat (Loadv4 (4 * n + 2));\n    for (int j = 0; j < nsMol; j ++) {\n      v = ro - (rm + mRot * rSph[j]);\n      b = dot (rd, v);\n      w = b * b + sz * sz - dot (v, v);\n      if (w >= 0.) {\n        d = - b - sqrt (w);\n        if (d > 0. && d < dMin) {\n          dMin = d;\n          idMol = n;\n          vn = v + d * rd;\n        }\n      }\n    }\n  }\n  qnHit = vn / sz;\n  return dMin;\n}\n\nfloat SphHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec3 rm, v;\n  float dMin, b, d, w, sz;\n  dMin = dstFar;\n  sz = 0.5;\n  for (int n = 0; n < nMol; n ++) {\n    rm = Loadv4 (4 * n).xyz;\n    mRot = QtToRMat (Loadv4 (4 * n + 2));\n    for (int j = 0; j < nsMol; j ++) {\n      v = ro - (rm + mRot * rSph[j]);\n      b = dot (rd, v);\n      w = b * b + sz * sz - dot (v, v);\n      if (w >= 0.) {\n        d = - b - sqrt (w);\n        if (d > 0. && d < dMin) dMin = d;\n      }\n    }\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbLen - 0.4) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat BlkHitSil (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = (hbLen - 0.4) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, w;\n  float dstSph, dstObj, sh, t;\n  rdSign = sign (rd);\n  dstObj = ObjRay (ro, rd);\n  t = -1. / (2. * sqrt (2.));\n  rSph[0] = vec3 (-0.5, 0., - t);\n  rSph[1] = vec3 (0.5, 0., - t);\n  rSph[2] = vec3 (0., -0.5, t);\n  rSph[3] = vec3 (0., 0.5, t);\n  dstSph = SphHit (ro, rd);\n  if (min (dstSph, dstObj) < dstFar) {\n    if (dstObj < dstSph) {\n      ro += rd * dstObj;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        w = smoothstep (0., 0.04, abs (fract (5. * ro / hbLen + 0.5) - 0.5));\n        col = vec3 (mix (vec3 (0.5), vec3 (0.5, 0.6, 0.5),\n           dot (abs (vn) * w.yzx * w.zxy, vec3 (1.))));\n      } else if (idObj == 2) col = vec3 (0.45, 0.55, 0.45);\n    } else {\n      ro += rd * dstSph;\n      vn = qnHit;\n      if (idMol == rideMol) col = vec3 (0.8, 0.8, 0.9);\n      else col = HsvToRgb (vec3 (float (idMol) / float (nMol), 1., 1.));\n    }\n    sh = 0.6 + 0.4 * SphHitSh (ro + 0.01 * ltDir, ltDir, 2. * hbLen);\n    col = col * (0.2 +  0.1 * max (- dot (vn, ltDir), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.2 * step (0.95, sh) * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (! riding && BlkHit (ro, rd) < dstFar) col = mix (col,\n       vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vnBlk, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vnBlk))), 64.),\n       pow (1. - abs (dot (rd, vnBlk)), 4.));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 col, rd, ro;\n  vec2 canvas, uv, ori, ca, sa, mMid, ut, mSize, msw;\n  float az, el, asp, vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid = vec2 (asp, 1.) * (1. - mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  regId = -1.;\n  if (mPtr.z > 0.) {\n    regId = 0.;\n    msw = mPtr.xy;\n    if (min (msw.x, msw.y) > 0.5 - mSize.y) {\n      regId = 1.;\n      msw = (msw - 1.) / mSize.y + 1.;\n    }\n  }\n  vuId = 0.;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1.;\n  }\n  if (regId == 1.) vuId = 1. - vuId;\n  riding = (vuId == 0.);\n  stDat = Loadv4 (4 * nMol);\n  hbLen = stDat.y;\n  dstFar = 100.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && regId == vuId) {\n    az += 2. * pi * msw.x;\n    el += 2. * pi * msw.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, (riding ? 1.5 : 4.5)));\n  ltDir = normalize (vec3 (0.7, 2., -1.));\n  rideMol = (nMolE / 2) * (nMolE * (nMolE + 1) + 1);\n  if (riding) {\n    ro = Loadv4 (4 * rideMol).xyz;\n    rd = QtToRMat (Loadv4 (4 * rideMol + 2)) * rd;\n  } else {\n    ro = vuMat * vec3 (0., 0., -6. * hbLen);\n  }\n  if (riding || BlkHitSil (ro, rd) < dstFar) col = ShowScene (ro, rd);\n  else col = vec3 (0.8, 1., 0.8) * (0.3 + 0.2 * uv.y);\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.)\n     col = vec3 (0., 0., 0.4);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// \"Molecular Waltz\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Minv3 (vec3 p);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define S_BIG  1\n#if S_BIG\nconst int nMolE = 6;\n#else\nconst int nMolE = 5;\n#endif\n\nvec3 rSph[4];\nfloat todCur, hbLen, fOvlap, nStep;\nconst int nMol = nMolE * nMolE * nMolE;\nconst int nsMol = 4;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\nvec3 WallForce (vec3 r)\n{\n  vec3 dr;\n  dr = hbLen - abs (r);\n  return - step (dr, vec3 (1.)) * fOvlap * sign (r) * (1. / abs (dr) - 1.) * dr;\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot, mRotN;\n  vec3 rmN, dr, rts, rtsN, rms, fc, am, wam, rMom;\n  float farSite, rSep, dt;\n  dt = 0.01;\n  rm = Loadv4 (4 * mId).xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  mRot = QtToRMat (qm);\n  farSite = 0.5 + sqrt (3./8.);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = 0; n < nMol; n ++) {\n    rmN = Loadv4 (4 * n).xyz;\n    if (n != mId && length (rm - rmN) < 2. * farSite) {\n      mRotN = QtToRMat (Loadv4 (4 * n + 2));\n      for (int j1 = 0; j1 < nsMol; j1 ++) {\n        rts = mRot * rSph[j1];\n        rms = rm + rts;\n        fc = vec3 (0.);\n        for (int j2 = 0; j2 < nsMol; j2 ++) {\n          rtsN = mRotN * rSph[j2];\n          dr = rms - (rmN + rtsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += fOvlap * (1. / rSep - 1.) * dr;\n        }\n        am += fc;\n        wam += cross (rts, fc);\n      }\n    }\n  }\n  dr = hbLen - abs (rm);\n  if (Minv3 (dr) < farSite + 0.5) {\n    for (int j = 0; j < nsMol; j ++) {\n      rts = mRot * rSph[j];\n      fc = WallForce (rm + rts);\n      am += fc;\n      wam += cross (rts, fc);\n    }\n  }\n  rMom = vec3 (0.);\n  for (int j = 0; j < nsMol; j ++) {\n    rts = rSph[j];\n    rMom += dot (rts, rts) - rts * rts + 1./6.;\n  }\n  rMom /= float (nsMol);\n  wam = mRot * (wam * mRot / rMom);\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float nme, mIdf, b, t;\n  nme = float (nMolE);\n  mIdf = float (mId);\n  rm = 2.2 * (floor (vec3 (mod (mIdf, nme), mod (mIdf, nme * nme) / nme,\n      mIdf / (nme * nme))) - 0.5 * (nme - 1.));\n  t = todCur + mIdf;\n  b = 2. * Hashff (t) - 1.;\n  qm = EulToQt (vec3 (0.1 * b, 0., 0.));\n  vm = 1.5 * (2. * vec3 (Hashff (t + 11.), Hashff (t + 21.), Hashff (t + 31.)) - 1.);\n  wm = vec3 (0.2, 0.2, 3.) * b;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag;\n  float tCur, mxStep, t;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nMol + 1) discard;\n  tCur = iTime;\n  todCur = iDate.w;\n  t = -1. / (2. * sqrt (2.));\n  rSph[0] = vec3 (-0.5, 0., - t);\n  rSph[1] = vec3 (0.5, 0., - t);\n  rSph[2] = vec3 (0., -0.5, t);\n  rSph[3] = vec3 (0., 0.5, t);\n  fOvlap = 1000.;\n  mId = (pxId < 4 * nMol) ? mId = pxId / 4 : -1;\n  doInit = false;\n  mxStep = 30000.;\n  if (iFrame == 0) {\n    doInit = true;\n    hbLen = 1.5 * float (nMolE);\n  } else {\n    stDat = Loadv4 (4 * nMol);\n    nStep = stDat.x;\n    hbLen = stDat.y;\n    ++ nStep;\n    if (nStep > mxStep) doInit = true;\n  }\n  if (doInit) {\n    nStep = 0.;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else stDat = vec4 (nStep, hbLen, 0., 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "Very cool",
        "date": "1560943012",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4tjcWc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Xds3zN",
      "date": "1364255835",
      "viewed": 281652,
      "name": "Raymarching - Primitives",
      "username": "iq",
      "description": "A set of raw primitives. All except the ellipsoid are exact euclidean distances. More info here: [url=http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm]http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm[/url]",
      "likes": 768,
      "published": 3,
      "flags": 0,
      "tags": [
        "procedural",
        "3d",
        "raymarching",
        "distancefields",
        "primitives"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 2   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdCappedTorus((pos-vec3( 1.0,0.20, 1.0)).xzy, vec2(0.866025,-0.5), 0.2, 0.05), 8.5) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(  pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    res = opU( res, vec2( sdRoundCone( pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n    res = opU( res, vec2( sdRoundCone( pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.2 + 0.18*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        //col = vec3(0.2);\n        col = 0.2 + 0.18*sin( m*2.0 + vec3(0.0,0.5,1.0) );\n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 5.0*pos.xz, 5.0*dpdx.xz, 5.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.80*dif*vec3(1.40,0.95,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n        lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 7.00*spe*vec3(1.10,0.90,0.70);\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.0) );\n\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.0) );\n        vec3 rdy = ca * normalize( vec3(py,2.0) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Yeah, something seems off in the coloring to me, too.",
        "date": "1560966643",
        "username": "ShadowFlare",
        "userpicture": "/img/profile.jpg",
        "id": "XljcDc",
        "hidden": 0
      },
      {
        "text": "Did the lighting change? it looks more pink than I remember.",
        "date": "1560502777",
        "username": "tdhooper",
        "userpicture": "/media/users/tdhooper/profile.png",
        "id": "MljcDK",
        "hidden": 0
      },
      {
        "text": "Added truncated torus",
        "date": "1560307546",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XljcWK",
        "hidden": 0
      },
      {
        "text": "Something's gone wrong with anti-aliasing since I last looked at this shader, the last 3 shapes in map() have a very visible black border on Mac 10.14.3 (Chrome 74).",
        "date": "1559641051",
        "username": "ReubenScratton",
        "userpicture": "/img/profile.jpg",
        "id": "lt2czd",
        "hidden": 0
      },
      {
        "text": "Added arbitrarily oriented capped cone.",
        "date": "1554375689",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4lXcWl",
        "hidden": 0
      },
      {
        "text": "@iq In your article about distance functions the opCheapBend is the same as the opTwist function (only some swizzling is done), if I remember correctly the bending wasn't using any matrices but only sin/cos to achieve the bending.",
        "date": "1550745805",
        "username": "nexor",
        "userpicture": "/img/profile.jpg",
        "id": "lllcDH",
        "hidden": 0
      },
      {
        "text": "Take also a look to the forked Animated 3d Primitives,  \nwhich now can also rendered antialiased!\n[url]https://www.shadertoy.com/view/4lSGRV[/url]\n;-)",
        "date": "1542985657",
        "username": "tholzer",
        "userpicture": "/media/users/tholzer/profile.png",
        "id": "Md2Bzm",
        "hidden": 0
      },
      {
        "text": "Arthas_me, please make a fork of this page using a procedural texture. It would be so cool",
        "date": "1540669023",
        "username": "pix",
        "userpicture": "/img/profile.jpg",
        "id": "4dXfWs",
        "hidden": 0
      },
      {
        "text": "textures are just either uv-mapped 2d to cover a 3d surface, or textures can be 3d gradiends, but with 3-4 channels, like wood\nhttps://www.shadertoy.com/view/XtyyDh\nhttps://www.shadertoy.com/view/4tK3DV\n\ntextures are either addressed per primitive-shape, and with a minx() function where only one of 2 calues is sorted, and links a textureid with it.\n\nOR\n\ntextures are accumulated on each reflection or volume-cloud iteration, which comes down to mixing or alpha-compositing accumulated light with surfaces/dust that is hit (absorbtion).\n\nmore realistic models are too excessive for realtime, even  bigHero6 almost never did more than accumulative 16 sub-surface bounces.",
        "date": "1540646294",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4sXfWl",
        "hidden": 0
      },
      {
        "text": "One way of texturing is already demonstrated: use the world position for surface uv values. Alternatively, apply textures based on a dot product of the texture direction and world normal. Not sure about concave geometry though.",
        "date": "1540418194",
        "username": "CLPB",
        "userpicture": "/img/profile.jpg",
        "id": "ldXBWf",
        "hidden": 0
      },
      {
        "text": "wander how to apply textures to  them.",
        "date": "1540267005",
        "username": "Arthas_me",
        "userpicture": "/media/users/Arthas_me/profile.jpeg",
        "id": "XdsBD2",
        "hidden": 0
      },
      {
        "text": "Added sdRoundCone()",
        "date": "1539157823",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MdfBzs",
        "hidden": 0
      },
      {
        "text": "is there a 'textured' version? :)",
        "date": "1539010555",
        "username": "Del",
        "userpicture": "/media/users/Del/profile.jpeg",
        "id": "MsXBRl",
        "hidden": 0
      },
      {
        "text": "Just improved the distance estimation for ellipsoids. It works much better now",
        "date": "1538985894",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XdfBzl",
        "hidden": 0
      },
      {
        "text": "I just found this website! Great shader! Quick tweak: replacing the last line of calcSoftShadows with the following makes the soft shadows look less fake:\n\nres = clamp( res, 0.0, 1.0 );\nreturn 3.*(res*res)-2.*(res*res*res);\n\nIt's a sigmoidal mapping that tries to simulate the shadow from a sperical light source and doesn't trigger the human eye's detection of 2nd derivative peaks (which leads to the optical illusion of lines at the shadow edges)",
        "date": "1538755162",
        "username": "csz",
        "userpicture": "/img/profile.jpg",
        "id": "ldffRf",
        "hidden": 0
      },
      {
        "text": "I just modified sdCappedCone() to return the [b]exact[/b] distance, not a bound any more.\n",
        "date": "1537952727",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ldlfRB",
        "hidden": 0
      },
      {
        "text": "I create a function like this:\nfloat myCone1(vec3 p){\n    \n    vec2 b=vec2(0.15,0.25);\n    vec2 q=vec2(length(p.xz),p.y);\n    float radio=clamp( (b.y-q.y)/b.y, 0.0, 1.0 );\n    float d2=max(q.y-b.y,-q.y);\n    float d1=q.x-radio*b.x;\n      return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);;\n\n}\nbut it doesn't work well can you help me",
        "date": "1537070794",
        "username": "LYF",
        "userpicture": "/img/profile.jpg",
        "id": "ldfBW7",
        "hidden": 0
      },
      {
        "text": "I AM YOUR BBBBBBBBBBIIIIIIIIG FFFFFFFFFFFFFFFFFFFFFFFFAN!!!",
        "date": "1522750551",
        "username": "jcyuan",
        "userpicture": "/img/profile.jpg",
        "id": "XslcRj",
        "hidden": 0
      },
      {
        "text": "Line number 68\n\nconst float k = sqrt(3.0); // Not working in IE (Initializer for const variable must initialize to a constant value)\n\nconst float k = 1.73205; // <--- would be good",
        "date": "1521386564",
        "username": "songinnight",
        "userpicture": "/img/profile.jpg",
        "id": "4sfyW4",
        "hidden": 0
      },
      {
        "text": "Hello. Can anyone help me rotate things right? I see strange things if I do it like this:\nvec3 rotateVector(vec3 v, vec4 q)\n{\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    p = rotateVector(p, vec4(0, 1, 0, 3.14 * 10.0 / 180.0));\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}",
        "date": "1520596836",
        "username": "PeterBzz",
        "userpicture": "/img/profile.jpg",
        "id": "lsXcWn",
        "hidden": 0
      },
      {
        "text": "Thanks a lot Dave!",
        "date": "1516474508",
        "username": "pjdevpl",
        "userpicture": "/img/profile.jpg",
        "id": "4tySRt",
        "hidden": 0
      },
      {
        "text": "Looking the code 'bac' is simulating a backlight from the side, and 'dom' is the light from the general sky dome.",
        "date": "1516462754",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XtGSRt",
        "hidden": 0
      },
      {
        "text": "Hi iq, could you explain what do bac and dom stand for?",
        "date": "1516449057",
        "username": "pjdevpl",
        "userpicture": "/img/profile.jpg",
        "id": "ltVSzc",
        "hidden": 0
      },
      {
        "text": "@pix+@benhardy, that's right, AO is the standard acronym for Ambient Occlusion in the game and film industry. Calc is for \"calculate\". Usually I tend to keep function and variable names short to make the code more readable and easy to follow, although I understand that makes it more difficult for the first timers).\n\n@liuliang: the first method is taking differences but instead of using 6 grid aligned points, it computes differentials at only 4 points (in the shape of a tetrahedron). \n\n@MichaelPohoreski: yes, we have to add a stronger forum capabilities (edit, modify, report). It'll come!",
        "date": "1514182317",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XtGXWW",
        "hidden": 0
      },
      {
        "text": "At a guess, it means Calculate Ambient Occlusion - which is darkening places where ambient light is harder to reach",
        "date": "1512929108",
        "username": "pix",
        "userpicture": "/img/profile.jpg",
        "id": "llGXRD",
        "hidden": 0
      },
      {
        "text": "Man I love this demo but I sure do wish some of the functions and variables had more descriptive names. e.g. I've got no idea what \"calcA0\" is doing.  Makes it a bit unnecessarily impenetrable.",
        "date": "1512919738",
        "username": "benhardy",
        "userpicture": "/img/profile.jpg",
        "id": "ltySRD",
        "hidden": 0
      },
      {
        "text": "Hello, @iq. In the function of calcNormal, you use two methods to calculate normal vectors.\n The first is: \n vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n, and the second is:\n /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n, I have understood the second methods, but the first method does not understand, can you tell the reason of this calculation? Or give me some hints , reference information?  Thanks in advance.",
        "date": "1508224547",
        "username": "liuliang",
        "userpicture": "/img/profile.jpg",
        "id": "lttXR7",
        "hidden": 0
      },
      {
        "text": "Seeing the comments on a forum, I decided to create a Discord Server for shaders.\nFeel free to join here: https://discord.gg/MapMXyy\nI still need a few people to help set it up, seeing as I literally created it 2 minutes ago, seeing all the posts about wanting a forum.",
        "date": "1505550276",
        "username": "Lucky4Luuk",
        "userpicture": "/img/profile.jpg",
        "id": "4ly3Rt",
        "hidden": 0
      },
      {
        "text": "Yes, I'd also welcome a forum, some place to talk more relaxed than below shader masterpieces and no way to edit.",
        "date": "1505514590",
        "username": "movAX13h",
        "userpicture": "/media/users/movAX13h/profile.png",
        "id": "ltV3zc",
        "hidden": 0
      },
      {
        "text": "...Or perhaps a forum somewhere?",
        "date": "1505513556",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MtK3zc",
        "hidden": 0
      },
      {
        "text": "@huttari Well said !!\n@Vox Please don't spam. It is people like you that no respect for others that cause comments threads to get locked / deleted / disabled.\n@iq Are there any plans in the future to allow comment moderation? Such as removing obvious spam comments, or community policing such as the ability to downvote obvious spam content?",
        "date": "1505511838",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "MlVGzc",
        "hidden": 0
      },
      {
        "text": "@vox Shadertoy in general isn't a platform to promote your app and web site. It would be more appropriate to post a comment on your own shadertoy shaders, especially those that are relevant to your new shaders.",
        "date": "1505510718",
        "username": "huttarl",
        "userpicture": "/media/users/huttarl/profile.jpeg",
        "id": "llVGzc",
        "hidden": 0
      },
      {
        "text": "the abs() in the marching loops break condition is most useful for the cases when the camera is too close to a surface (or below it). there are other solutions for that case, including proper camera control that avoids that case.\n\ngenerally the abs() is neglible. Because a distaceFunction returns an UPPER bound of the distance to a surface, therefore it returns >=0. for any point on the ray, approaching a surface, but inlikely ever exactly hitting it, and never getting below it.\nIif it returns less than its distance to its INTENDED surface (by including a twist function), a high lipschitz-constant will be visible as \"APPARENT overstepping\", \"warping trough an INTENDED solid\", and for these cases, it will still only return >=0;\n\n\"intended != apparent\" because spatial warps deform gradient domains to a point where the intended distance field is very different from the actual warped distance field.\n\nThe abs() is useful in contexts for extensions to sphere tracking, that also include fractal orbitals, [url=https://www.shadertoy.com/results?query=volume]volume[/url] tracking, [url=https://www.shadertoy.com/results?query=glass]glass[/url], [url=https://www.shadertoy.com/results?query=sss]sub-surface-Scattering[/url] , [url=https://www.shadertoy.com/results?query=scatter]scattering in general[/url], [url=https://www.shadertoy.com/results?query=transparen]transparency[/url] or [url=https://www.shadertoy.com/results?query=dynamiceps]dynamic epsilon[/url] implementations.",
        "date": "1505059761",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "lly3zK",
        "hidden": 0
      },
      {
        "text": "@iq, in the castRay function, shouldn't \"res.x < precis\" be \"abs(res.x) < precis\"? If it's a signed distance function, and you're somehow inside the surface, res.x will be negative, and iteration will stop prematurely. I think I ran into some artifacts from this when transforming shapes in a certain way.",
        "date": "1499890721",
        "username": "hodapp",
        "userpicture": "/img/profile.jpg",
        "id": "Mtt3W4",
        "hidden": 0
      },
      {
        "text": "@huttarl Thanks! Like you, I work on this sporadically. I had only documented the low level primitives -- great to see you documented the high level ray marching as well. I'll leave comments on your page their if I have any requests / questions.\n\nNow if we could only [b]get i.q. to fix all the typos[/b] on his distfunctions.html page :-)",
        "date": "1498667655",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "4t3GDn",
        "hidden": 0
      },
      {
        "text": "@MichaelP - by all means. I've added some new comments there in the last few days so I hope you get those. I'm going to keep working on it sporadically, but if there's a particular part that you think would especially benefit from comments, please let me know and I'll get to it quicker.",
        "date": "1498660980",
        "username": "huttarl",
        "userpicture": "/media/users/huttarl/profile.jpeg",
        "id": "4lcGWn",
        "hidden": 0
      },
      {
        "text": "@huttari -- Mind if I add some of your comments to my [url=\"https://www.shadertoy.com/view/XllGW4\"]XllGW4 tutorial[/url] ? ",
        "date": "1498656656",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "4l3GWn",
        "hidden": 0
      },
      {
        "text": "No, ternary operator is way faster than mix+step. Compare (CMP) and conditional moves (CMOV) are naturally faster than trying to emulate the same thing with multiplications and additions (mix). You can try it yourself!",
        "date": "1498642279",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "Mld3z7",
        "hidden": 0
      },
      {
        "text": "Isn't the ternary operator slower than using the mix-step combination?\nSo won't be this union operator be faster than the one in the shader?\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    //old: return (d1.x<d2.x) ? d1 : d2;\n    return mix(d2,d1,step(d1.x,d2.x));\n}",
        "date": "1492466141",
        "username": "nexor",
        "userpicture": "/img/profile.jpg",
        "id": "4sGXDw",
        "hidden": 0
      },
      {
        "text": "For more detailed comments, see [url=https://www.shadertoy.com/view/ltyXD3]ltyXD3[/url]\nFor a mini tutorial, see [url=https://www.shadertoy.com/view/XllGW4]XllGW4[/url]",
        "date": "1486176812",
        "username": "huttarl",
        "userpicture": "/media/users/huttarl/profile.jpeg",
        "id": "Ms3SR2",
        "hidden": 0
      },
      {
        "text": "@pengliu, the signed functions help with getting nice normals. when sampling around the hit-point to get the normal by central differences, you will often sample points inside the shape, you get better normals if these return negative values rather than zero. you also need it if you are gong to do the subtraction trick, like the cube with a sphere cut out here",
        "date": "1485878631",
        "username": "russ",
        "userpicture": "/img/profile.jpg",
        "id": "MsdXzS",
        "hidden": 0
      },
      {
        "text": "hum... I see what does the s/u means in the function name. But I still don't understand what the advantages we get for using signed functions over the unsigned ones if our ray march will never sample inside those objs...",
        "date": "1485321886",
        "username": "pengliu916",
        "userpicture": "/img/profile.jpg",
        "id": "MsdSWM",
        "hidden": 0
      },
      {
        "text": "In order to return correct distance when inside a box I think sdBox need to return the abs of the original distance like this:\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return abs(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));\n}\n\nor if inside box is never considered a valid case then we should get rid of the min max stuff like the following:\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\nPlease correct me if I get it wrong. Thanks",
        "date": "1485320835",
        "username": "pengliu916",
        "userpicture": "/img/profile.jpg",
        "id": "lsdSWM",
        "hidden": 0
      },
      {
        "text": "You don't need to do the whole signed box for the pyramid, just a cutting plane :\nfloat plane = dot( p , vec3(0,-1,0) );\n.....\nreturn max(plane, octa);",
        "date": "1485241682",
        "username": "russ",
        "userpicture": "/img/profile.jpg",
        "id": "4sdXDM",
        "hidden": 0
      },
      {
        "text": "Added!",
        "date": "1482549593",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4scSz8",
        "hidden": 0
      },
      {
        "text": "New primitive:\n\n#define PI 3.14159265\n#define DEG2RAD(deg) (deg*PI/180.)\n\nfloat sdPryamid4(vec3 p, vec2 h )\n{\n    float slopeRadians = DEG2RAD(45.0);\n    float s = sin( slopeRadians );\n    float c = cos( slopeRadians );\n    \n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.x,0), vec3(2.0*h.x) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -s, c, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  s, c, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, c, s )) ));\n    d = max( d, abs( dot(p, vec3(  0, c,-s )) ));\n    float octa = d - h.x;\n    return max(-box,octa); // Subtraction\n }\n",
        "date": "1481313230",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "XsK3W3",
        "hidden": 0
      },
      {
        "text": "Missing 2 useful defines:\n\n#define PI 3.14159265\n#define DEG2RAD(deg) (deg*PI/180.)\n",
        "date": "1481311887",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "XdK3W3",
        "hidden": 0
      },
      {
        "text": "Replace hard-coded magic-number on line #66 with slope:\n    float s = sqrt( 3./4. ); // slope, i.e. 0.5 = 45 degrees\n    float d2 = max(q.x*s+p.y*0.5,-p.y)-h.x*0.5;\n",
        "date": "1481304031",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "lsy3Dc",
        "hidden": 0
      },
      {
        "text": "sdTriPrism is unoptimized. :-/ Replace Line #67 with simply:\n    return max(d1,d2);",
        "date": "1481303898",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "ldy3Dc",
        "hidden": 0
      },
      {
        "text": "Maybe a way to make the ray march faster is make a plane distance field function where:\n\n[code]\n\nfloat plane (vec3 p, vec3 d) {\n     if (d.y>=0.) return -1.; //Then in the raymarch code, -1 is no hit.\n     return (o.y/(-d.y));\n}\n\n\n[/code] \nIt gave me slight improvement on FPS. But this shader is still really fast.",
        "date": "1478904844",
        "username": "VoidChicken",
        "userpicture": "/media/users/VoidChicken/profile.jpeg",
        "id": "Msy3RK",
        "hidden": 0
      },
      {
        "text": "AAAH my bad, the URL explains everything!\nsorry, and nice work btw.!",
        "date": "1477383453",
        "username": "VoidDroid",
        "userpicture": "/img/profile.jpg",
        "id": "XdV3W1",
        "hidden": 0
      },
      {
        "text": "could you pls comment your code?\ni dont understand those shortcut names/functions...\nopU? opS? or? to??? whooot????????",
        "date": "1477383066",
        "username": "VoidDroid",
        "userpicture": "/img/profile.jpg",
        "id": "4sK3W1",
        "hidden": 0
      },
      {
        "text": "@iq When are you going to fix the typos in your distance functions HTML? :-)\nYou can see the errors here:\nhttps://www.shadertoy.com/view/XllGW4",
        "date": "1475017573",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "lsVGzR",
        "hidden": 0
      },
      {
        "text": "You are pushing the envelope on graphics forward just as Ken Perlin once did...schools should be teaching Quilez voronoise and Quilez raymarching just as they do Perlin noise and Worley noise and so on...",
        "date": "1472542426",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "Msc3Rs",
        "hidden": 0
      },
      {
        "text": "this example is amazeballs.",
        "date": "1465699288",
        "username": "pickledchickenfoot",
        "userpicture": "/img/profile.jpg",
        "id": "4tSXRc",
        "hidden": 0
      },
      {
        "text": "I added a couple more primitives here if anyone is interested.\nhttps://www.shadertoy.com/view/Ms3Sz2",
        "date": "1460322300",
        "username": "akohdr",
        "userpicture": "/img/profile.jpg",
        "id": "XllXDX",
        "hidden": 0
      },
      {
        "text": "Awesome reference IQ--learning a lot! Quick question though. What are the bac and dom variables in your lighting calculations?\n\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );",
        "date": "1456069515",
        "username": "hackthechad",
        "userpicture": "/img/profile.jpg",
        "id": "ltsSR7",
        "hidden": 0
      },
      {
        "text": "What does the 'c' parameter in sdCone do?",
        "date": "1455400480",
        "username": "Doublefresh",
        "userpicture": "/media/users/Doublefresh/profile.jpeg",
        "id": "XtlXR8",
        "hidden": 0
      },
      {
        "text": "It's not randomly chose. 0.4545 is 1/2.2, which is the standard gamma value for most monitors.",
        "date": "1450579972",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "llj3zW",
        "hidden": 0
      },
      {
        "text": "I think I found it out, it must be Gamma Correction and the formula is randomly chosen to approximate the ideal curve.\n\nReference:\nhttp://en.wikipedia.org/wiki/Gamma_correction",
        "date": "1433215849",
        "username": "tyleeer",
        "userpicture": "/media/users/tyleeer/profile.jpeg",
        "id": "XsBXWz",
        "hidden": 0
      },
      {
        "text": "Dear IQ,\n\nYou did on line 335:\n \ncol = pow( col, vec3(0.4545) );\n\nIt makes the color of the scene more natural, how do you find out this formula and why.\n\nTyler",
        "date": "1433215223",
        "username": "tyleeer",
        "userpicture": "/media/users/tyleeer/profile.jpeg",
        "id": "XdBXWz",
        "hidden": 0
      },
      {
        "text": "You can do reflections without recursion. See [url=https://www.shadertoy.com/view/ldl3zN]ldl3zN[/url] for one example.",
        "date": "1431816333",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ls2SzD",
        "hidden": 0
      },
      {
        "text": "I just tried porting this shader to iOS/Metal.   \nI was surprised how well it works (with just a few objects) on the iPad Air (1024x768)\nThe full complement of items is a bit too much.   \n\nAlso tried to add a true reflection, but the shader language does not like recursion.\n",
        "date": "1427128328",
        "username": "Carniphage",
        "userpicture": "/img/profile.jpg",
        "id": "4ssXW2",
        "hidden": 0
      },
      {
        "text": "this sample show a solution ... or better identify where the problem is https://www.shadertoy.com/view/Md2SDV",
        "date": "1416225949",
        "username": "denis",
        "userpicture": "/media/users/denis/profile.jpeg",
        "id": "MdsSzN",
        "hidden": 0
      },
      {
        "text": "I am glad to see the improvements on this sample .\nPlaying with the operators I found a side effect in the twist operator. I made a sample to show the effect of twist on the cube-sphere . \nThis is the link https://www.shadertoy.com/view/Xs2SDG .\nIt is possible to see a wave on the sphere edge using the operator opTwist2 and worst using the operator opTwist the edges sometimes disappears . Is this a problem due to a not enough precision in the cos and sin function ? ",
        "date": "1415551069",
        "username": "denis",
        "userpicture": "/media/users/denis/profile.jpeg",
        "id": "XssSRN",
        "hidden": 0
      },
      {
        "text": "Fixed sdHexPrism()",
        "date": "1414384777",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "lssSz8",
        "hidden": 0
      },
      {
        "text": "I have managed to discover it is used to affect colour. ",
        "date": "1412069368",
        "username": "pix",
        "userpicture": "/img/profile.jpg",
        "id": "4sXXzr",
        "hidden": 0
      },
      {
        "text": "Or more generally, what does the vec2.y value represent in all the vec2s in the map function (lines 134-146)\n\nThanks",
        "date": "1412000211",
        "username": "pix",
        "userpicture": "/img/profile.jpg",
        "id": "4sfSzr",
        "hidden": 0
      },
      {
        "text": "\nWhat does the 46.9 mean?\n vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n",
        "date": "1411999903",
        "username": "pix",
        "userpicture": "/img/profile.jpg",
        "id": "XsfSzr",
        "hidden": 0
      },
      {
        "text": "This is a more compact/elegant exact distance computator: [code]float sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\t\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}[/code]",
        "date": "1397673289",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4dBGDw",
        "hidden": 0
      },
      {
        "text": "Nice!, thanks for doing the comparative plots. I didn't expand qvx in order to make the symmetry  between vvb/qvb and vvx/qvx more apparent (in fact I artificially expanded the equations and rearranged expression until I got d1 and d2 to look \"the same\").\n\nI think your version is beautifully compact and give a good enough approximation, so it's probably better for small-code demos such as 1k and 4k demos. It's true too that the exact one could undergo some compactation. ",
        "date": "1397670835",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XdBGDw",
        "hidden": 0
      },
      {
        "text": "Should have done before posting - corrected (yet still imperfect) version:\n[code]\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    return bmax( dot(q,c.xy), (-p.y-c.z) / c.x  );\n}\n[/code]\n\nYour code looks nice! Mostly regular arithmetic - so wouldn't be too sure that it's more expensive. I like that square domain trick. And it takes radius and height, after all.\n\nSquare root argument may flip to a small negative and cause noise - 'abs' underneath solves it. Expanding the expression for 'qvx' may give additional stability.\n\nDistance plots: [url]https://www.shadertoy.com/view/4slSzN[/url] (not listed)",
        "date": "1397669765",
        "username": "tosh",
        "userpicture": "/img/profile.jpg",
        "id": "4sSGDw",
        "hidden": 0
      },
      {
        "text": "I've drawn some isolines for your sdCone, but it doesn't seem to be correct. This one is (more expensive I think) but produces equidistant isolines with rounded corners and all: [code]float sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\t\n    float vvb = dot( v, v );\n    float qvb = dot( v, v-q );\n    float vvx = v.x*v.x;\n    float qvx = v.x*(v.x-q.x);\n\t\n    float hb = clamp( qvb, 0.0, vvb );\n    float hx = clamp( qvx, 0.0, vvx );\n\n    vec2 d1 = vec2( hb*(hb-2.0*qvb)/vvb, q.x*v.y-q.y*v.x );\n    vec2 d2 = vec2( hx*(hx-2.0*qvx)/vvx,     q.y-v.y );\n\n    vec2 d = min( d1, d2 );\n\n    return -sqrt( dot(v-q,v-q) + d.x )*sign(d.y);\n}[/code]",
        "date": "1397645039",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XsSGDw",
        "hidden": 0
      },
      {
        "text": "Good point. I've fixed the cylinder for now",
        "date": "1397637505",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XdSGDw",
        "hidden": 0
      },
      {
        "text": "'sdCylinder' and 'sdCone' need the \"box maximum thing\" to return accurate Euclidean distances (which cause primitives to be hit or missed within fewer iterations as with an underestimation).\n\nFor the cylinder it is simple:\n[code]\nfloat bmax( float x, float y )\n{\n\treturn length(max(vec2(x, y),0.0)) + min(max(x, y), 0.);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n\treturn bmax( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n[/code]\n\nThe cone is trickier: We have one component in normal direction and another one along the cylindrical height, but to use 'length' we need orthonormal axes. \n\nHere is what I came up with:\n[code]\nfloat sdCone( in vec3 p, in vec3 c )\n{\n\tvec2 q = vec2( length(p.xz), clamp(p.y, -c.z, 0.) );\n\tvec2 n = dot(q,c.xy) * c.xy;\n\treturn bmax( n.x, max( n.y, max(p.y, -p.y-c.z) ) );\n}\n[/code]\n\nClamping restricts the radius to the bounds, then the normal distance from the dot product is multiplied with the normal to get back individual components along 'r' and 'h' axes. The latter gets restricted and the components are box-maxed.\n\nVisible difference in this shader: The shadow of the cone gets nicer.",
        "date": "1397612484",
        "username": "tosh",
        "userpicture": "/img/profile.jpg",
        "id": "Ms23DD",
        "hidden": 0
      },
      {
        "text": "You can also add\nfloat sdWobbleCube( vec3 p, float s )\n{\n   // Modified cube\n   return max (max(abs(p.x)-s +sin(p.y*10.0)*0.05 , abs(p.y)-s) , abs(p.z)-s  ) ;\n}\nAdding more sins can give more complex and fun results",
        "date": "1382781954",
        "username": "mrqzzz",
        "userpicture": "/img/profile.jpg",
        "id": "MslGDj",
        "hidden": 0
      },
      {
        "text": "Astonishing! Loved to fiddle with it challenging myself to create a few surfaces. Thanks!",
        "date": "1382777436",
        "username": "mrqzzz",
        "userpicture": "/img/profile.jpg",
        "id": "lslGDj",
        "hidden": 0
      },
      {
        "text": "The shadow function should be updated to one that uses the distance field to step along the ray instead of fixed steps. Looks much better and requires less samples. There's one in my Loxodrome shader, and I believe you did the same thing in Fruxis.",
        "date": "1379725062",
        "username": "fb39ca4",
        "userpicture": "/media/users/fb39ca4/profile.png",
        "id": "MdsGzl",
        "hidden": 0
      },
      {
        "text": "4 emails about this today, i'm thinking, could we have a \"unfollow post\" button at some point please iq? Or maybe just an option to get emails only on \"owned\" shaders? ;)",
        "date": "1378247794",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "MdfGzf",
        "hidden": 0
      },
      {
        "text": "You are  right! Thank you :)\n",
        "date": "1378247671",
        "username": "denis",
        "userpicture": "/media/users/denis/profile.jpeg",
        "id": "ldfGzf",
        "hidden": 0
      },
      {
        "text": "You need to increase the number of iterations from 60 to something bigger",
        "date": "1378247568",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MsXGzf",
        "hidden": 0
      },
      {
        "text": "I am playing with this sample , I made a copy and I am trying to figure out the reason of the problem around the cone . \nThis is the link https://www.shadertoy.com/view/XdfGWS  \nit seem the cone fold the rays around ... \nDo you know why?",
        "date": "1378246950",
        "username": "denis",
        "userpicture": "/media/users/denis/profile.jpeg",
        "id": "MdXGzf",
        "hidden": 0
      },
      {
        "text": "Fixed",
        "date": "1378242232",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ldXGzf",
        "hidden": 0
      },
      {
        "text": "One question. Why in the softshadow you get the max from 0.02 and dt where dt is always equal to 0.02 ?",
        "date": "1378241830",
        "username": "denis",
        "userpicture": "/media/users/denis/profile.jpeg",
        "id": "Msf3Rf",
        "hidden": 0
      },
      {
        "text": "Congratulation iq it is a really useful sample!",
        "date": "1375002724",
        "username": "denis",
        "userpicture": "/media/users/denis/profile.jpeg",
        "id": "lsXGRB",
        "hidden": 0
      },
      {
        "text": "I absolutely love this site! Tremendous amount of information and techniques!\n\nCould the frame rate be increased if in getNorm (by that time we know what object the ray intersects), the distance is only calculated for the intersected object? This would require keeping track of what object returns the minimum distance in map().",
        "date": "1370639201",
        "username": "dominics",
        "userpicture": "/media/users/dominics/profile.jpeg",
        "id": "lslGW8",
        "hidden": 0
      },
      {
        "text": "This sample was the perfect introduction for me to get started with distance fields. Thanks so much!",
        "date": "1365107962",
        "username": "Roeltje",
        "userpicture": "/img/profile.jpg",
        "id": "4sfGRN",
        "hidden": 0
      },
      {
        "text": "Really nice scene.",
        "date": "1364616431",
        "username": "gtoledo3",
        "userpicture": "/img/profile.jpg",
        "id": "Mdl3zH",
        "hidden": 0
      },
      {
        "text": "That's very handy. I hope you're attracting new users by this!",
        "date": "1364477815",
        "username": "ssdsa",
        "userpicture": "/media/users/ssdsa/profile.jpeg",
        "id": "lslGzH",
        "hidden": 0
      },
      {
        "text": "Nice reference :)",
        "date": "1364334071",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "Mdl3RH",
        "hidden": 0
      },
      {
        "text": "I know. Another one: in order to fix the ambient occlusion and actually see it, I had to change the object IDs randomly. Like, the constant literals, from 13.1 to 22.6 and stuff like that, until magically the occlusion was back (which of course has nothing to do with object IDs). This whole WebGL shader compiling thing is really scary, for it's not deterministic and depends on the machine, browsers, temperature in the room, weather, and month of the year...",
        "date": "1364324002",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ldl3RH",
        "hidden": 0
      },
      {
        "text": "Nice! On Chrome/Win7 it appears that moving the call to sdHexPrism to be the last in the function fixes the lighting on the cog. Changing it to another shape does not. These compile problems are so illogical, are they optimization problems caused by code ordering? ",
        "date": "1364304901",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MssGRH",
        "hidden": 0
      },
      {
        "text": "Just read that (your) article yesterday and wanted to start playing with it for learning reasons :)",
        "date": "1364293330",
        "username": "movAX13h",
        "userpicture": "/media/users/movAX13h/profile.png",
        "id": "MdsGRH",
        "hidden": 0
      },
      {
        "text": "Ah i see! Windows again! Yes, i'm also seeing flat colour on the \"gear\". Windows/WebGL is clearly misbehaving! :(\n",
        "date": "1364291885",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "ldsGRH",
        "hidden": 0
      },
      {
        "text": "Shadows are soft already. But occlusion, normals and other stuff seem to be broken under Windows :(",
        "date": "1364270780",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MslGRH",
        "hidden": 0
      },
      {
        "text": "Sweet! a very compact reference. Love that twisted torus :)\nGreat stuff! \nWould the (cheap) \"noise trick\" help soften out the shadows?",
        "date": "1364259882",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "MdlGRH",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "XsX3RB",
      "date": "1372830991",
      "viewed": 123344,
      "name": "Volcanic",
      "username": "iq",
      "description": "An alien volcanic landscape. It started as an experiment on 2d-texture based 3d noise. But then I played with the noise shape, the added some shading, put lighting in it, etc..., until I got this.  I can't wait for Shadertoy to have multipass rendering...",
      "likes": 503,
      "published": 3,
      "flags": 32,
      "tags": [
        "procedural",
        "3d",
        "raymarching",
        "noise",
        "distancefield"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n\n    vec3 col = vec3(0.0);\n    if( data.w < 0.0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n    }\n    else\n    {\n        // decompress velocity vector\n        float ss = mod(data.w,256.0)/255.0;\n        float st = floor(data.w/256.0)/255.0;\n\n        // motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col = vec3(0.0);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)/31.0;\n            vec2 pos = uv + dir*h;\n            col += texture( iChannel0, pos ).xyz;\n        }\n        col /= 32.0;\n    }\n\n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4sfGRn",
            "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
            "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsX3Rn",
            "filepath": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
            "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
            "type": "texture",
            "channel": 2,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "Xsf3zn",
            "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0. ).x;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//=====================================================================\n\nfloat lava( vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p )\n{\n\tp += vec3(1.0,0.0,0.8);\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n\t\n\tfloat n = noise( p*3.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 30.0;\n    float t = 0.1;\n    for( int i=0; i<256; i++ )\n    {\n\t    float h = mapTerrain( ro+rd*t );\n        if( h<(0.001*t) || t>maxd ) break;\n        t += h*0.8;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\t\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iTime,0.0);\n\t\n\tfloat d;\n    d  = 0.5000*noise( q ); q = q*2.02;\n    d += 0.2500*noise( q ); q = q*2.03;\n    d += 0.1250*noise( q ); q = q*2.01;\n    d += 0.0625*noise( q );\n\t\t\n\td = d - 0.55;\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), res.x );\n\tres.xyz *= 0.25;\n\tres.xyz *= 0.5 + 0.5*smoothstep( -2.0, 1.0, pos.y );\n\t\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )\n{\n\tvec4 sum = vec4( 0.0 );\n\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ),6.0 );\n\tfloat t = 0.0;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tif( t>tmax || sum.w>0.95 ) break;//continue;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t}\n\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.5 );\n\t\tif( res<0.001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.5*.1*time*1.5), 1.5, 16.0*sin(0.1+0.5*0.11*time*1.5) );\n\t\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\tta.y *= 0.35 + 0.25*sin(0.09*time);\n\tfloat cr = 0.3*sin(1.0+0.07*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 2.1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n    // camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x/iResolution.x;\n    float time = 3.4 + iTime + off;\n\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n\t// camera2world transform\n    mat3 cam = setCamera( ro, ta, cr );\n\n    // ray    \n    vec3 rd = cam * normalize(vec3(p.xy,fl));\n\n    // sky\t \n\tvec3 col = vec3(0.32,0.36,0.4) - rd.y*0.4;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.2*pow( sun, 6.0 );\n    col *= 0.9;\n\n\tvec3 bcol = col;\n    \n    // terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    float st = t;\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\tvec3 bn = -1.0 + 2.0*texcube( iChannel0, 3.0*pos/4.0, nor ).xyz;\n\t\tnor = normalize( nor + 0.6*bn );\n\t\t\n\t\tfloat hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n\n        // lighting\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.01,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\n\t\tfloat amb = 1.0;\n\n\t\tcol = vec3(0.8);\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.4*sun*vec3(1.80,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 0.9*sky*vec3(0.16,0.20,0.40)*occ;\n\t\tlin += 0.9*bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += 0.9*amb*vec3(0.15,0.17,0.20)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n        // surface shading/material\t\t\n\t\tcol = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\t\tvec3 verde = vec3(1.0,0.9,0.2);\n\t\tverde *= texture( iChannel2, pos.xz ).xyz;\n\t\tcol = mix( col, 0.8*verde, hh );\n\t\t\n\t\tfloat vv = smoothstep( 0.0, 0.8, nor.y )*smoothstep(0.0, 0.1, pos.y-0.8 );\n\t\tverde = vec3(0.2,0.45,0.1);\n\t\tverde *= texture( iChannel2, 30.0*pos.xz ).xyz;\n\t\tverde += 0.2*texture( iChannel2, 1.0*pos.xz ).xyz;\n\t\tvv *= smoothstep( 0.0, 0.5, texture( iChannel2, 0.1*pos.xz + 0.01*nor.x ).x );\n\t\tcol = mix( col, verde*1.1, vv );\n\t\t\n\t\tcol = lin * col;\n\t\t\n        // sun spec\n        vec3 hal = normalize(lig-rd);\n        col += 1.0*\n               vec3(1.80,1.27,0.99)*\n               pow( clamp(dot(nor,hal),0.0,1.0), 16.0 ) * \n               sun*sha*\n               (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n            \n\t\t// atmospheric\n\t\tcol = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.00006*t*t*t) );\n    }\n\n    // sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*pow( sun, 2.0 )*clamp( (rd.y+0.4)/(0.0+0.4),0.0,1.0);\n\t\n    // smoke\t\n\t{\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t );\n\tcol = mix( col, res.xyz, res.w );\n\t}\n\n    // gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    // contrast, desat, tint and vignetting\t\n\tcol = col*0.3 + 0.7*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n    col *= 1.25*vec3(1.02,1.05,1.0);\n      \n    //-------------------------------------\n\t// velocity vectors (through depth reprojection)\n    //-------------------------------------\n    float vel = -1.0;\n    if( st>0.0 )\n    {\n        // old camera position\n        float oldTime = time - 1.0/30.0; // 1/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        // world spcae\n        vec3 wpos = ro + rd*st;\n        // camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        // ndc space\n        vec2 npos = oldFl * cpos.xy / cpos.z;\n        // screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n\n\n        // compress velocity vector in a single float\n        vec2 uv = fragCoord/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*255.0) + floor(spos.y*255.0)*256.0;\n    }\n\n    fragColor = vec4( col, vel );\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "i also like it withhout blur! btw, your code is very readable and informative, thank you ! ",
        "date": "1556719739",
        "username": "jeyko",
        "userpicture": "/media/users/jeyko/profile.jpeg",
        "id": "Xt2yDh",
        "hidden": 0
      },
      {
        "text": "Newbie question ! At line 323 (Buffer A), why don't you use :\nvec3 cpos = (wpos - oldRo) * oldCam ;\n\n",
        "date": "1542920933",
        "username": "denosya",
        "userpicture": "/media/users/denosya/profile.jpeg",
        "id": "MsjBzw",
        "hidden": 0
      },
      {
        "text": "I prefer it without motion blur.",
        "date": "1535122141",
        "username": "Redline",
        "userpicture": "/img/profile.jpg",
        "id": "lsXBWn",
        "hidden": 0
      },
      {
        "text": "Featured in this video :) ! [video]http://youtu.be/7BB8TkY4Aeg[/video]",
        "date": "1532120586",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "ldjcDV",
        "hidden": 0
      },
      {
        "text": "It's awesome graphics!!!\n\nif you want to run in Inter Explorer\nfix texutreLod to texure function (textureLod is not supported in IE)\n",
        "date": "1521386788",
        "username": "songinnight",
        "userpicture": "/img/profile.jpg",
        "id": "XdXcW4",
        "hidden": 0
      },
      {
        "text": "tylerbata, currently your best be to work around [lipschitz constants >1](due to (twist) transformations of the distance field/gradient, or due to fractals with insufficiently precise orbit traps) is [url=https://www.shadertoy.com/results?query=dynamiceps]dynamiceps[/url]. It adjusts epsilon for the \"close to surface\" break condition, based on last step distance and distance to camera, for more precision closer to the camera, and more distortion further away from the camera, for more convergence and longer render distance (and as many reflections as steps).",
        "date": "1510100155",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4ltSR2",
        "hidden": 0
      },
      {
        "text": "Beautiful, in full screen it looks perfect.",
        "date": "1504262882",
        "username": "Osgrot",
        "userpicture": "/media/users/Osgrot/profile.jpeg",
        "id": "Mty3Ww",
        "hidden": 0
      },
      {
        "text": "Thanks! Yeah I kind of figured it would be a precision error.  I tested it by marching only 0.75 of the estimated distance and it fixed the problem...only thing is that adds a lot of cost.  So I think I will likely have some sort of dynamic precision based off the distance.  I also think I might try some sort of newton like method over shooting then fixing back...This could cause issues with thin objects like grass.",
        "date": "1494089182",
        "username": "tylerbata",
        "userpicture": "/media/users/tylerbata/profile.png",
        "id": "lsVXRc",
        "hidden": 0
      },
      {
        "text": "raymarching being iterative raytracing, you easily end up accumulating more precision errors than in an analytical approach.\n\nevery iteration it estimates the closest distance o a defined surface.\nsometimes it is easier to define an upper bound for a distance.\nsome transformations make it very hard to estimate even an upper bound.\noften a faster lower-bound is \"close enough\" but lads to overestimation of distances, and you march into or trough a \"solid\"",
        "date": "1494047802",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "XsKXzc",
        "hidden": 0
      },
      {
        "text": "Let's be sure we're on the same page:\n\nAre you referring to the \"shimmering\" effect that's pretty much everywhere, at the pixel-level?\n\nOr are you referring to the flip-flop from black to light here and there along the edges of shadows?",
        "date": "1491277916",
        "username": "jpryne",
        "userpicture": "/img/profile.jpg",
        "id": "ldyXWz",
        "hidden": 0
      },
      {
        "text": "Thanks, I'm trying to figure out why fractal terrain will always flicker in some places.  Is the distance field not correct?  I have tested the noise function by itself and several variants but it still flickers.  I've seen it occur on other distance fields as well.",
        "date": "1491270794",
        "username": "tylerbata",
        "userpicture": "/media/users/tylerbata/profile.png",
        "id": "MdGXWz",
        "hidden": 0
      },
      {
        "text": "Ok, my guess is this relates to volumetric surfaces with normals ~perpendicular to the light source. Tricky. My thought is applying a CLAMP function to the shadow color would solve the issue, rather than a binary function going straight from opaque black to transparent. Thoughts, anyone?",
        "date": "1491232540",
        "username": "jpryne",
        "userpicture": "/img/profile.jpg",
        "id": "ldySDR",
        "hidden": 0
      },
      {
        "text": "Ah, wait, sorry, at first I didn't notice the issue you speak of. You're talking about the splotches of black among the rocks? That's different than the issue I described below. This is definitely a question for Inigo.",
        "date": "1491232322",
        "username": "jpryne",
        "userpicture": "/img/profile.jpg",
        "id": "MsGSDR",
        "hidden": 0
      },
      {
        "text": "Tylerbata, my guess is this would disappear with oversampling. Without oversampling, fractal terrain will most always flicker, I should think. Feel free to correct me, anyone.",
        "date": "1491232199",
        "username": "jpryne",
        "userpicture": "/img/profile.jpg",
        "id": "lsGSDR",
        "hidden": 0
      },
      {
        "text": "Why does the flickering occur?  Is there anyway to create it without it?",
        "date": "1491155638",
        "username": "tylerbata",
        "userpicture": "/media/users/tylerbata/profile.png",
        "id": "XsyXDR",
        "hidden": 0
      },
      {
        "text": "The texture is used for surface shading, and needs mipmapping, hence I cannot make it linear and need the -100. The true solution is to remove the -100 and use texture2DLodEXT() instead, with 0 as mip level.",
        "date": "1483849538",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "lstSRM",
        "hidden": 0
      },
      {
        "text": "Figured this out ---- values in G channel are assumed to be (37,17) shifted values in R channel. Nice idea. This saves one texture read as I understand. BTW, I set texture filtering mode to GL_LINEAR and then LOD = -100 is not necessary. \n\nNow the shader completely works and shows me amazing picture.\n\nBTW, awesome math happening here (in this demo and on this site). \nI love it, sir. Good work.",
        "date": "1472147934",
        "username": "afoksha",
        "userpicture": "/img/profile.jpg",
        "id": "XdtGRX",
        "hidden": 0
      },
      {
        "text": "Should the noise function be just smooth gradient- or simplex- like ? If so I think can implement it on my own.\nAlso what is the point of 3rd argument (-100) in texture2D call ?\n\ntexture2D( iChannel0, (uv+ vec2(0.5,0.5))/256.0, -100.0)\n\nThanks.",
        "date": "1472134518",
        "username": "afoksha",
        "userpicture": "/img/profile.jpg",
        "id": "ld33zf",
        "hidden": 0
      },
      {
        "text": "Tried your shader in a simple glfw-based application. It works. Three textures are needed -- the last two (iChannel1 and iChannel2)  can be more or less arbitrary as I understand. But the first (noise texture) should satisfy some properties which I cannot guess looking at the code. With random (uniformly) generated rgb components the geometry is visually torn. How can I generate suitable texture image for it? \n\nThanks.\n",
        "date": "1472133928",
        "username": "afoksha",
        "userpicture": "/img/profile.jpg",
        "id": "MscGzf",
        "hidden": 0
      },
      {
        "text": "i kinda want o steer a hot air baloon through it, being affected by its surrounding and my mouse position.",
        "date": "1460985211",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "MlSSRR",
        "hidden": 0
      },
      {
        "text": "added a constant factor to line 226, resulted in pseudorandom refraction, as if everything was made of glass\n\nvec3 pos = ro + t*rd*0.5;",
        "date": "1460984770",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "llSSRR",
        "hidden": 0
      },
      {
        "text": "[This comment has been hidden by the shader author]",
        "date": "1460930291",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "lllXWs",
        "hidden": 1
      },
      {
        "text": "show this to every 10 year old manchild who gets easily excited by the minecraft terrain generator.",
        "date": "1460930017",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "MtlXWs",
        "hidden": 0
      },
      {
        "text": "Inigo, again mindblowing work.... Also, thank you for all the tutorials, example code etc. You're freaking awesome  bro!!",
        "date": "1453795294",
        "username": "nenovrak",
        "userpicture": "/media/users/nenovrak/profile.jpeg",
        "id": "Xlj3Rd",
        "hidden": 0
      },
      {
        "text": "... very impressiv, great work and thanks!",
        "date": "1435949046",
        "username": "fred41",
        "userpicture": "/img/profile.jpg",
        "id": "MdSXRy",
        "hidden": 0
      },
      {
        "text": "this shader alone is inspiration enough to use this site... awesome! great work :)",
        "date": "1414706705",
        "username": "peet",
        "userpicture": "/img/profile.jpg",
        "id": "XsXXR4",
        "hidden": 0
      },
      {
        "text": "Wow, if you swap the iChannel0 source for a different texture and it becomes a completely different landscape!  I must investigate to understand this mapping...",
        "date": "1408906622",
        "username": "dantronic",
        "userpicture": "/media/users/dantronic/profile.jpeg",
        "id": "XdS3D3",
        "hidden": 0
      },
      {
        "text": "I can feel the heat...hehe...nice details, massive effect.",
        "date": "1374173508",
        "username": "frankwer",
        "userpicture": "/img/profile.jpg",
        "id": "lsl3W7",
        "hidden": 0
      },
      {
        "text": "Just wow!",
        "date": "1373314147",
        "username": "bekre",
        "userpicture": "/img/profile.jpg",
        "id": "4dfGW7",
        "hidden": 0
      },
      {
        "text": "Awesome!",
        "date": "1373180188",
        "username": "gyabo",
        "userpicture": "/media/users/gyabo/profile.png",
        "id": "XdfGDM",
        "hidden": 0
      },
      {
        "text": "Simply outstanding! An inspiration to those of us who are just getting started with programmable pipelines.\n",
        "date": "1373175825",
        "username": "jpryne",
        "userpicture": "/img/profile.jpg",
        "id": "XsXGDM",
        "hidden": 0
      },
      {
        "text": "I rendered it with motion blur and depth of field (at about 3 seconds a frame in my laptop at 1920x1080 HD): [url=http://www.youtube.com/watch?v=QfvzfWgW6H4&hd=1]http://www.youtube.com/watch?v=QfvzfWgW6H4&hd=1[/url]\r\n\r\n[video]http://www.youtube.com/watch?v=QfvzfWgW6H4[/video]",
        "date": "1373135522",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4sf3WM",
        "hidden": 0
      },
      {
        "text": "Not really. I have made the epsilon in the gradient/normal computations bigger than the quantification error of the textured noise, but small enough to capture the actual geometry. Basically, making your deltas a bit bigger in calcNormal() should fix it. Hopefully! (unless you get really close to the surface of the model, that is). If not, maybe I should add textures in float16 format as an option...",
        "date": "1372876460",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ldl3WN",
        "hidden": 0
      },
      {
        "text": "Yeah I've tried it for height maps before, but it showed the stepping problems on the texel gradients, which I found quite interesting. I guess you've hidden the errors in the squiggles. :)",
        "date": "1372873204",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "lssGWN",
        "hidden": 0
      },
      {
        "text": "Yep. It suffers from precision problems though, but it can be a good alternative in some cases. Not only is faster, but WebGLSL seems to be less sensitive to fail compilation with this one that with the procedural/hash based one.",
        "date": "1372870579",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MdsGWN",
        "hidden": 0
      },
      {
        "text": "I've just this 3D noise idea in one of my old shaders, and it's speed enabled much finer steps. Thank-you iq!",
        "date": "1372870476",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "ldsGWN",
        "hidden": 0
      },
      {
        "text": "Really cool :)",
        "date": "1372867312",
        "username": "vanburgler",
        "userpicture": "/img/profile.jpg",
        "id": "MslGWN",
        "hidden": 0
      },
      {
        "text": "Brilliant! And that smoke really makes it 2X so! :)",
        "date": "1372860147",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MdlGWN",
        "hidden": 0
      },
      {
        "text": "OMG! WOW! Incredible! I love it! :)",
        "date": "1372846348",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "MssGD4",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "XsXXDn",
      "date": "1398755270",
      "viewed": 178274,
      "name": "Creation by Silexars",
      "username": "Danguafer",
      "description": "My first demoscene release. Achieved second place @ DemoJS 2011. It has been said to be the first 1k WebGL intro ever released.",
      "likes": 464,
      "published": 1,
      "flags": 0,
      "tags": [
        "intro",
        "silexars",
        "1k",
        "demojs"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [],
        "code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "argh, right ! \n",
        "date": "1552496504",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ltfczf",
        "hidden": 0
      },
      {
        "text": "@Fabrice, you don't need abs if you are taking the length of it. (-5 chars)",
        "date": "1552494017",
        "username": "coyote",
        "userpicture": "/img/profile.jpg",
        "id": "llXczf",
        "hidden": 0
      },
      {
        "text": "@AnnaEverson, whatever you can imagine. :)",
        "date": "1551437277",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "lllcWM",
        "hidden": 0
      },
      {
        "text": "hey, what is it?",
        "date": "1551437013",
        "username": "AnnaEverson",
        "userpicture": "/media/users/AnnaEverson/profile.jpeg",
        "id": "MtlcWM",
        "hidden": 0
      },
      {
        "text": "nice !\n\nsome remarks:\n\nuv , p , l should better be initialized before the loop.\nBeside, the aspect-ratio correction trick is kind of ugly compare to just not distorting at first.\n\nwhy using #defines rather than variables ?\n\nmod(uv,1.) = fract(uv)\n\nc[i]: c useless, fragColor could be modified directly\n\n-> cleaned-up version ( 210 chars rather than 302 )\n[code]void mainImage( out vec4 O, vec2 u ){\n\n    vec2 r = iResolution.xy,\n         U, p = ( u - .5*r ) / r.y;\n    float z = iTime, l = length(p);\n\n    for( int i=0; i<3; i++ ) {\n        z +=.07;\n        U = u/r + p/l * ( sin(z)+1.) * abs(sin(l*9.-z*2.));\n        O[i] = .01 / length( abs(fract(U)-.5) );\n\t}\n\tO /= l;\n}\n[/code]\n\nwith more extreme golfing, this can goes down to 196 chars:\n[code]void mainImage( out vec4 O, vec2 u ){\n\n    vec2 r = iResolution.xy,\n         p = u - .5*r;\n    float z = iTime, l = length(p /= r.y);\n\n    for( int i=-1; i++ < 3; z +=.07 )\n        O[i] = .01 / length( abs(fract(u/r + p/l * ( sin(z)+1.) * abs(sin(l*9.-z-z)))-.5) ) / l;\n}\n[/code]\n\n( and with new webGL2 extended line using \\ , we can even go down to 182 chars:  :-)\n[code]#define mainImage( O, u )                    \\\n    vec2 r = iResolution.xy,                 \\\n         p = u - .5*r;                       \\\n    float z = iTime, l = length(p /= r.y);   \\\n    for( int i=-1; i++ < 3; z +=.07 )        \\\n        O[i] = .01 / length( abs(fract(u/r + p/l * (sin(z)+1.) * abs(sin(l*9.-z-z)))-.5) ) / l\n[/code]\n)",
        "date": "1547473526",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XsjfWy",
        "hidden": 0
      },
      {
        "text": "How do I get permission to use this in my Virtual DJ display? I don't do clubs... special events.",
        "date": "1539562742",
        "username": "AudioMaverick",
        "userpicture": "/img/profile.jpg",
        "id": "lsfBWB",
        "hidden": 0
      },
      {
        "text": "Sabooo, yes, but please use the credits (it's in the code now)",
        "date": "1534722688",
        "username": "Danguafer",
        "userpicture": "/img/profile.jpg",
        "id": "MslBRM",
        "hidden": 0
      },
      {
        "text": "AAAAAAAAAAAmazing!",
        "date": "1529585018",
        "username": "bluedrop",
        "userpicture": "/img/profile.jpg",
        "id": "4sByzV",
        "hidden": 0
      },
      {
        "text": "Divine!!",
        "date": "1527251404",
        "username": "soulscape",
        "userpicture": "/img/profile.jpg",
        "id": "4sSyDz",
        "hidden": 0
      },
      {
        "text": "Love the colors!",
        "date": "1526730881",
        "username": "CLPB",
        "userpicture": "/img/profile.jpg",
        "id": "Md2yzD",
        "hidden": 0
      },
      {
        "text": "Hi I like your shader may I adapt it and use it for my game?",
        "date": "1524577632",
        "username": "Sabooo",
        "userpicture": "/img/profile.jpg",
        "id": "4dfyDf",
        "hidden": 0
      },
      {
        "text": "Anyone analysing this may find useful this simplified version https://www.shadertoy.com/view/MtlBDf .",
        "date": "1513824499",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "XlGXD1",
        "hidden": 0
      },
      {
        "text": "sambaridli, z+=.07 ensures R G and B differ.",
        "date": "1513738341",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "llVSDz",
        "hidden": 0
      },
      {
        "text": "What's the purpose of t on line 19?",
        "date": "1513735197",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "MtVXWz",
        "hidden": 0
      },
      {
        "text": "oh gosh",
        "date": "1505462329",
        "username": "jniac",
        "userpicture": "/img/profile.jpg",
        "id": "4lV3zc",
        "hidden": 0
      },
      {
        "text": "In my DSP CPU software I use the standard 'sqrt' because it's been implemented in hardware since then, and don't forget the  SIMD instructions. We don't even how a particular compiler rearranges this code for optimisation purposes.",
        "date": "1504532886",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4tG3RG",
        "hidden": 0
      },
      {
        "text": "The article said it was off by only .175% at most, right? I would be suprised if invsersesqrt was anything else because it said that calculating sqrt the same way then performing a division is 4 times slower.",
        "date": "1504482085",
        "username": "Ebanflo",
        "userpicture": "/media/users/Ebanflo/profile.png",
        "id": "MtVGWm",
        "hidden": 0
      },
      {
        "text": "We don't know they use that estimation. I thought 'inversesqrt' was at least accurate.",
        "date": "1504472670",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "ltKGWm",
        "hidden": 0
      },
      {
        "text": "don't think so https://en.wikipedia.org/wiki/Fast_inverse_square_root",
        "date": "1504455520",
        "username": "Ebanflo",
        "userpicture": "/media/users/Ebanflo/profile.png",
        "id": "MlV3Ww",
        "hidden": 0
      },
      {
        "text": "I'd like to know if 'inversesqrt' is just a helper function that has a divide inside it?",
        "date": "1504189463",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XtyGWm",
        "hidden": 0
      },
      {
        "text": "actually that's 7 divisions",
        "date": "1504161082",
        "username": "Ebanflo",
        "userpicture": "/media/users/Ebanflo/profile.png",
        "id": "Xty3Ww",
        "hidden": 0
      },
      {
        "text": "This might be optimized by the compiler, but you can save yourself 2 divisions by letting \nl=inversesqrt(dot(p, p)); and then multiplying by l instead.",
        "date": "1504161005",
        "username": "Ebanflo",
        "userpicture": "/media/users/Ebanflo/profile.png",
        "id": "4lG3Ww",
        "hidden": 0
      },
      {
        "text": "Amazing !!!Your code is so short!",
        "date": "1503996208",
        "username": "chenwanwan13",
        "userpicture": "/media/users/chenwanwan13/profile.jpeg",
        "id": "Mty3DW",
        "hidden": 0
      },
      {
        "text": "c is a vec3 and l is just a float, so c/l is a vec3 as well",
        "date": "1493103837",
        "username": "Ebanflo",
        "userpicture": "/media/users/Ebanflo/profile.png",
        "id": "4sySzy",
        "hidden": 0
      },
      {
        "text": "Hey Danguafer, it seems like the R, G and B components are getting the same value, but how is it that we see the colours separate out? I observed that when all the loop code except line 17 was moved out, the effect is similar but completely white. And also while incrementally moving the previous lines out of the loop, some different effects seem to be coming. Could you explain why all this is happening? \n\nPS: I'm new to shaders, just starting to pick them up. ",
        "date": "1492451002",
        "username": "sambaridli",
        "userpicture": "/img/profile.jpg",
        "id": "4syXWw",
        "hidden": 0
      },
      {
        "text": "I combined your code with some music analysis I'm working on. Your shader is a very good fit for fast rhythmic tracks http://wizgrav.github.io/aframe/music/index.html",
        "date": "1472683495",
        "username": "wizgrav",
        "userpicture": "/img/profile.jpg",
        "id": "lddGRl",
        "hidden": 0
      },
      {
        "text": "This is awesome.",
        "date": "1432803391",
        "username": "denzen",
        "userpicture": "/media/users/denzen/profile.png",
        "id": "Ms2Szw",
        "hidden": 0
      },
      {
        "text": "Very pretty",
        "date": "1428484742",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4slXWl",
        "hidden": 0
      },
      {
        "text": "It might help if this site acknowledges the 'Post' button when it's pressed because people are re-hitting it thinking the button didn't work.",
        "date": "1401878981",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4dBGRV",
        "hidden": 0
      },
      {
        "text": "my net speed is low ,sorry..",
        "date": "1401873532",
        "username": "designcity",
        "userpicture": "/img/profile.jpg",
        "id": "XdBGRV",
        "hidden": 0
      },
      {
        "text": "\u00e5\u00be\u02c6\u00e5\u00a5\u00bd \u00ef\u00bc\u0161\u00ef\u00bc\u2030",
        "date": "1401873019",
        "username": "designcity",
        "userpicture": "/img/profile.jpg",
        "id": "XdB3zK",
        "hidden": 0
      },
      {
        "text": "beautiful, the RGB diffraction effect totally makes this.",
        "date": "1399541044",
        "username": "simesgreen",
        "userpicture": "/media/users/simesgreen/profile.gif",
        "id": "lsjGDm",
        "hidden": 0
      },
      {
        "text": "Thanks, guys! :D",
        "date": "1399143230",
        "username": "Danguafer",
        "userpicture": "/img/profile.jpg",
        "id": "XdjGWm",
        "hidden": 0
      },
      {
        "text": "Amazing! So short and it looks so awesome!",
        "date": "1398798994",
        "username": "mu6k",
        "userpicture": "/media/users/mu6k/profile.png",
        "id": "XdjGWw",
        "hidden": 0
      },
      {
        "text": "I like the way you access the vec3 as an array. It's quite shocking how small the code is, nice one.",
        "date": "1398769394",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MdS3Dm",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "XslGRr",
      "date": "1361810389",
      "viewed": 160868,
      "name": "Clouds",
      "username": "iq",
      "description": "Raymarching some fbm (you can move the mouse around). This is my first shader in the \"one shader a week for a year\" challenge that I have committed to.",
      "likes": 1068,
      "published": 3,
      "flags": 1,
      "tags": [
        "procedural",
        "3d",
        "raymarching",
        "volumetric",
        "lod",
        "vr"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "Xsf3zn",
            "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Volumetric clouds. It performs level of detail (LOD) for faster rendering\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,17)*q.z;\n\n\tvec2 rg = mix( mix( texelFetch( iChannel0, (uv           )&255, 0 ),\n\t\t\t\t        texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ), f.x ),\n\t\t\t\t   mix( texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ),\n\t\t\t\t        texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ), f.x ), f.y ).yx;\n#endif    \n    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0, 0.6, 0.3)*dif;        \n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.05,0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;//0.05*texelFetch( iChannel0, px&255, 0 ).x;\n\n    MARCH(30,map5);\n    MARCH(30,map4);\n    MARCH(30,map3);\n    MARCH(30,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir, ivec2(fragCoord-0.5) );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "UnityEnginge can do raymarching-spheretracking, but\n- To mix polygon meshes with the z-buffer that you get from raymarching, you use the (deferred shading) pipeline of unityEngine. to a point where most people call ANY spheretracking within Unityengine just broadly \"deferred shading\" (as it often tends to also include particle systems that are not necessarily fluidSimulation or density-fields)\n- This is done verywell in at least 3 different UnityEngine plugins, most of them are only documented in japanese, as their main purpose is to make composites of rigged-polygon-mesh models for MMD dancing, with more complex spheretracked sceneryand special effects. the result is that you can post-processing screenspace-CSG with rigged-mesh-models.\n- all others are less sophisticated, mostly only do spheretracking of fractals within unityEngine.\n- they use a lot of FrameBufferObjects, many parameters per pixel, and call the z-buffer a \"g-buffer\".\n- these plugins most likely do not work with older unityEngine versions. newer versions come with more opengl/directx support, that is mandatory for them.",
        "date": "1557375849",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "MlBcWm",
        "hidden": 0
      },
      {
        "text": "Does anybody already adopted this code to use it in Unity? I would appreciate any help.\n@pp did you achieve it?",
        "date": "1556626419",
        "username": "Frogger",
        "userpicture": "/img/profile.jpg",
        "id": "llByWh",
        "hidden": 0
      },
      {
        "text": "@henry: several peoples have done something cousin to that here: browse the best off, read and ask there ;-) .\nOr how do you expect that someone can answer here on such an ultra large and ultra technical question, which correspond to several different scientific papers or blogs ?",
        "date": "1552673230",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Mtsyzf",
        "hidden": 0
      },
      {
        "text": "How would i make a sunset emulator with dozens of different shaped clouds lit orange and red on one side and dark on the other, at different altitudes?",
        "date": "1552671094",
        "username": "henry",
        "userpicture": "/media/users/henry/profile.jpeg",
        "id": "ltsyzf",
        "hidden": 0
      },
      {
        "text": "How would I make this more fog-like?",
        "date": "1552663336",
        "username": "ShadowFlare",
        "userpicture": "/img/profile.jpg",
        "id": "ltlyzf",
        "hidden": 0
      },
      {
        "text": "Is there a way to run this in Natron shadertoy plugin? Thanks",
        "date": "1551962672",
        "username": "rthriller",
        "userpicture": "/img/profile.jpg",
        "id": "llsyzS",
        "hidden": 0
      },
      {
        "text": "Yes but seems way easier to get into it ;) ",
        "date": "1541712225",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "MsjfRh",
        "hidden": 0
      },
      {
        "text": "... ... Is this the new demo scene?",
        "date": "1541685826",
        "username": "Lanlost",
        "userpicture": "/img/profile.jpg",
        "id": "Xd2fz1",
        "hidden": 0
      },
      {
        "text": "amazing purfect effect, thanks for share. Have any test on a model not a postprocess?",
        "date": "1534819960",
        "username": "bigmi",
        "userpicture": "/img/profile.jpg",
        "id": "MssfR7",
        "hidden": 0
      },
      {
        "text": "@Dave_Hoskins it's the texture. but it's not flipped. I was relying on android framework PNG decoding and upload and looks like it is messing the channels (I guess it might be flipped ;) ).\n\nThanks for the hint ",
        "date": "1534492947",
        "username": "spacetug",
        "userpicture": "/media/users/spacetug/profile.jpeg",
        "id": "ldfBR7",
        "hidden": 0
      },
      {
        "text": "@spacetug, It looks to me like your texture is flipped vertically. The alignment of the texture is important to retrieve the correct 3D data.",
        "date": "1534406999",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "ldffzM",
        "hidden": 0
      },
      {
        "text": "spacetug, maybe you should ask on the facebook group : https://www.facebook.com/groups/147749602472741/ ",
        "date": "1534404938",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "MsXfzM",
        "hidden": 0
      },
      {
        "text": "Hello there,\nI'm building a shadertoy client for Android and I'm getting strange artifacts on several shaders.\nThey look like precision issue but as I'm new to this, don't know how to solve (I'm quite sure I've set precision do highp).\nI've uploaded captures on a Pixel 2 XL here:\n[url]https://photos.app.goo.gl/5TAwa23tk4mXPZ7b7[/url]\nNotice the \"rings\" on `Clouds` and the camera going straight in `Volcanic`\n\nAny ideas?\nthanks!",
        "date": "1534404535",
        "username": "spacetug",
        "userpicture": "/media/users/spacetug/profile.jpeg",
        "id": "lsXfzM",
        "hidden": 0
      },
      {
        "text": "Featured in this video :) ! [video]http://youtu.be/7BB8TkY4Aeg[/video]",
        "date": "1532120574",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "ls2yDV",
        "hidden": 0
      },
      {
        "text": "simply means the R(x,y) = G(x+37,y+17).\nIt' a hack to fake 3D volumes (that where not available at that time).\nJust manually interpolating between the R and G slices (obtained in one single fetch) is like interpolating in a volume slice.  then when floor(z) pass to the net slice you just offset xy index by (37,17) for continuity.",
        "date": "1524672453",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MdXcWf",
        "hidden": 0
      },
      {
        "text": "Thanks a lot. This texture works. But still I am not sure what \"G and A channels are R and B translated by (37.,17.) \" means, and why we can obtain faker 3D cloud volume from it. Still a lot to learn~",
        "date": "1524576653",
        "username": "starforce08",
        "userpicture": "/img/profile.jpg",
        "id": "4sXyDf",
        "hidden": 0
      },
      {
        "text": "explanation about these noise textures: [url]https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/[/url]",
        "date": "1524511928",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XsXcDX",
        "hidden": 0
      },
      {
        "text": "starforce08, download here https://i.imgur.com/Wpq1UDJ.png . Next time you could download Synthclipse -- it contains all the ST textures.",
        "date": "1524510614",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "4dXcDX",
        "hidden": 0
      },
      {
        "text": "Hi,Dear IQ,I tried to realize this demo in local OpenGL context. However, I found the texture iChannel0 have become an important issue. I generate a RGBA noise texture by myself to replace it, but some serious aliasing occured. Then I tried to enable the VFlip option online, the same aliasing occured too. So I assume this is not a random noise texture, but a kind of LUT with certain order. I'm wondering where can I download this texture, or how can I generate it by myself. Best regard!",
        "date": "1524509950",
        "username": "starforce08",
        "userpicture": "/img/profile.jpg",
        "id": "XdXcDX",
        "hidden": 0
      },
      {
        "text": "I just tried Firefox 56 - the failure is gone.",
        "date": "1514326237",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "MlyXWD",
        "hidden": 0
      },
      {
        "text": "Yeah, textureLod is part of the WebGL 2 standard, a browser cannot claim to be doing WebGL 2 without implementing textureLod(). It works great here in Firefox.",
        "date": "1514318200",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ltGXWD",
        "hidden": 0
      },
      {
        "text": "F, yes.\n\nThis browser supports WebGL 2\nPlatform: \tWin32\nBrowser User Agent: \tMozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0\nContext Name: \twebgl2\nGL Version: \tWebGL 2.0\nShading Language Version: \tWebGL GLSL ES 3.00\nVendor: \tMozilla\nRenderer: \tMozilla\nAntialiasing: \tAvailable\nANGLE: \tYes, D3D11\nMajor Performance Caveat: \tNo",
        "date": "1514030869",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "4tKSD1",
        "hidden": 0
      },
      {
        "text": "is your overall system webGl2 compatible ? test [url]http://webglreport.com/?v=2[/url]",
        "date": "1514030518",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4lVXW1",
        "hidden": 0
      },
      {
        "text": "\"I wonder if you are using textureLod (gsamplerCubeArray)\"\n\nScratch that. I get the same failure even without gsamplerCubeArray https://www.shadertoy.com/view/ltlfWl :(\n\nSo, I'm wondering textureLod EVER works on 3.30.",
        "date": "1514029214",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "XtVXW1",
        "hidden": 0
      },
      {
        "text": "IQ, you might like to know most of your shaders fail for me https://www.shadertoy.com/view/XslGRr on latest Firefox with WebGL GLSL ES 3.00 . \n\nThis one's failure is with an error \"textureLod no matching overload found\". I wonder if you are using textureLod (gsamplerCubeArray) (unsupported on 3.30) but the ST UI gives me no way I can see to determine the iChannel0 argument type.",
        "date": "1514027796",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "4lKXW1",
        "hidden": 0
      },
      {
        "text": "NB: costmap:\n- costlier pixels ( = far clouds ) are only 40% costlier than the average.\n- free sky pixels cost the same than mid-cloud pixels.",
        "date": "1512313259",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4lVSzz",
        "hidden": 0
      },
      {
        "text": "This is hands down the best shader on this site to learn cloud tracing from. Iq, your code is so clean and organized. Very much\nappriciate.",
        "date": "1510827600",
        "username": "ingagard",
        "userpicture": "/img/profile.jpg",
        "id": "MttSRl",
        "hidden": 0
      },
      {
        "text": "[url=https://www.shadertoy.com/view/XtBcWK]I tried 2 small things with this shader[/url], but only small sucesses.\n\nmostly because its whole fbm noise differential volume marching function is nice and fast, but also coarse and overly specific.\nhard to change,reshape, generalize,optimize.\n",
        "date": "1510094988",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4ldXzj",
        "hidden": 0
      },
      {
        "text": "i once made a [url=https://mega.nz/#!Fw0DXTyB!BxHo-NREiNII8NsxlQmW5LQIPBqHM1jBNdj_Fc1a68g]VERY SMALL fragment shader boilerplate[/url]==envelope==wrapper. only 20k, has mouse input, can print text to show fps and other values. has a (manual) bridge to shadertoy and glslsandbox (it bridges namespaces over to shadertoy),  does not support any buffers (too simple)\ni still use it to quickly backup and watch a lot of shadertoy stuff.\nits utility is its simplicity, small size, being very minimalist (except for its benchmarking code ability to print bitmap text, that one is slightly more involved 7k of header code)\n\nits one messy library now:\n\niit is a bit sorted, sort by the .html files size, start with the 2d ones, and just dive into them.",
        "date": "1507666191",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "Mt3XzN",
        "hidden": 0
      },
      {
        "text": "@CaliCoastReplay\nIf TarrDashie is using OpenGL or DirectX then the vertex portion of the pipeline is needed. Otherwise the fragment portion of the shader has nothing to work with.\nUnder the hood shadertoy is also using a vertex shader.",
        "date": "1507652207",
        "username": "Donoph",
        "userpicture": "/img/profile.jpg",
        "id": "ll3SRN",
        "hidden": 0
      },
      {
        "text": "TarrDashie:  Throw vertices out of your head when dealing with raymarching.  There is no traditional geometry, there are no triangles.  Everything is a \"fragment\", so to speak.  Specifically, each pixel is calculated via algorithms that more closely resemble old-school raycasting/raytracing - except that, instead of seeking precise calculations and calculating ray bounces (which still can't really be done in realtime), the raymarcher takes a certain number of steps through the scene and stops when it hits something.\n\nHere is a very, very good introduction to raymarching:\n\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching",
        "date": "1507651288",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "lt3SRN",
        "hidden": 0
      },
      {
        "text": "When I converted this example to pure OpenGL. I applied it to a 2D plane that was stretched across the screen. The vertex shader was kept very simple handling only the texture coordinates and vertex position.\nUsing legacy OpenGL it could look something like this.\n\nvarying vec2 fragCoord;\nvoid main()\n{\n\tfragCoord = gl_MultiTexCoord0.xy;\n\tgl_Position = vec4(gl_Vertex.xyz, 1.0);\n}",
        "date": "1507649058",
        "username": "Donoph",
        "userpicture": "/img/profile.jpg",
        "id": "llcXz4",
        "hidden": 0
      },
      {
        "text": "Hi, I'm a bit new here. I am trying to visualize how this would work in the context of a vertex and fragment shader program. I understand that we are sampling values from a texture and using that and the ray marching algorithm to compute the color of the fragments. But how is that being applied? We are setting the fragment color but is that being applied to the positions in the scene?",
        "date": "1507613647",
        "username": "TarrDashie",
        "userpicture": "/media/users/TarrDashie/profile.jpeg",
        "id": "lt3XR4",
        "hidden": 0
      },
      {
        "text": "@ollj\nI'll give those noise algorithms a try. Thank you for the help.",
        "date": "1505925266",
        "username": "Donoph",
        "userpicture": "/img/profile.jpg",
        "id": "XtVGDG",
        "hidden": 0
      },
      {
        "text": "noise is a subjective fickle beast. This shader can show you the hyper-planes of a Linear Congruental Hash/Generator:\n\n#define HASHSCALE1 .1031\nfloat noise(vec3 p3){p3 =fract(p3*.001* HASHSCALE1); p3+=dot(p3, p3.yzx + 19.19);return fract((p3.x + p3.y) * p3.z);\n}//https://www.shadertoy.com/view/4djSRW\n\nyou might want to use some blurry [url=https://www.shadertoy.com/results?query=simplex]simplex noise[/url] or blurry [url=https://www.shadertoy.com/view/Xd23Dh] voronoi-noise[/url] instead. the blur hides he tessellation by interpolation, creating smoother pseudo-normal-distributions. but under that veil, they all boil down to fractal LCGs.",
        "date": "1505061072",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "ltGGRV",
        "hidden": 0
      },
      {
        "text": "@Donoph\nthank you !you are right , i have achieve it , just need to convert ivecn to intn .Next, i need to do is make sure how the algorithm is implemented.",
        "date": "1502244604",
        "username": "pp",
        "userpicture": "/img/profile.jpg",
        "id": "XlGGRW",
        "hidden": 0
      },
      {
        "text": "@pp\nivec is just a vector of signed integers.\nI've never used Unity before, but if it runs glsl shaders then ivec shouldn't be giving you any trouble.",
        "date": "1502215476",
        "username": "Donoph",
        "userpicture": "/img/profile.jpg",
        "id": "llVGR1",
        "hidden": 0
      },
      {
        "text": "beautiful! i want to use it in unity ,but i don't know how to deal 'ivec'...",
        "date": "1502159462",
        "username": "pp",
        "userpicture": "/img/profile.jpg",
        "id": "4tVGz1",
        "hidden": 0
      },
      {
        "text": "Very nice shader! I was hoping you could share how you created your noise texture. When I use my randomly generated noise textures I get a lot of artifacts in the clouds.",
        "date": "1499453409",
        "username": "Donoph",
        "userpicture": "/img/profile.jpg",
        "id": "llt3D8",
        "hidden": 0
      },
      {
        "text": "It's really Nice.  ",
        "date": "1483191484",
        "username": "CHIMAIRA",
        "userpicture": "/img/profile.jpg",
        "id": "Xs3SzN",
        "hidden": 0
      },
      {
        "text": "so cool!",
        "date": "1473235604",
        "username": "jcyuan",
        "userpicture": "/img/profile.jpg",
        "id": "MstGWB",
        "hidden": 0
      },
      {
        "text": "Dear Mr. Quilez;\n\nWill there ever be a ShaderToy marketplace allowing creations to be sold/used/remixed for commercial purposes?  A lot of the creations here really ought to be seen by the world...",
        "date": "1472373348",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "ldt3Rf",
        "hidden": 0
      },
      {
        "text": "No texture version -- pitch the camera up/down & replace lines 6-14 with with iqnoise() from:\n\n//  https://www.shadertoy.com/view/4sfGzS\nfloat iqhash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( iqhash(n+0.0  ), iqhash(n+1.0  ),f.x),\n                   mix( iqhash(n+57.0 ), iqhash(n+58.0 ),f.x),f.y),\n               mix(mix( iqhash(n+113.0), iqhash(n+114.0),f.x),\n                   mix( iqhash(n+170.0), iqhash(n+171.0),f.x),f.y),f.z);\n}\n",
        "date": "1456523482",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "XlsSDH",
        "hidden": 0
      },
      {
        "text": "Grrr, line 12",
        "date": "1456521250",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "4llSDH",
        "hidden": 0
      },
      {
        "text": "@Dave_Hoskins Yup, meant line 1 -- I forgot I had a noise function inserted. Thanks for the texture filter fix!",
        "date": "1456521228",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "XllSDH",
        "hidden": 0
      },
      {
        "text": "I guess you mean Line 12? -100.0 just really means the highest detailed bitmap available. You can now remove the bias altogether and just set the texture channel to 'Linear.'",
        "date": "1456509452",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XlsXWH",
        "hidden": 0
      },
      {
        "text": "Does anyone have a better bias for line 16?  I've found you don't need -100; and  -4 is too low:\n\nvec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, -8. ).yx;",
        "date": "1456509049",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "4tsXWH",
        "hidden": 0
      },
      {
        "text": "some of the techniques used are found here: http://http.developer.nvidia.com/GPUGems/gpugems_ch39.html",
        "date": "1443735652",
        "username": "valentingalea",
        "userpicture": "/img/profile.jpg",
        "id": "4lf3Dr",
        "hidden": 0
      },
      {
        "text": "I'd give you a dollar to comment it... I get what the individual functions like the noise and map do, but an overall \"Here's where I was going before I got here\" explanation would be great.\n",
        "date": "1442696138",
        "username": "davepl",
        "userpicture": "/media/users/davepl/profile.jpeg",
        "id": "lls3zN",
        "hidden": 0
      },
      {
        "text": "Awesome shader iq, been following your website too for quite some time! \n\nwindoze, thanks for the much much needed explanation. Now I can modify the code the way I want it.",
        "date": "1440322286",
        "username": "EvilTak",
        "userpicture": "/img/profile.jpg",
        "id": "XsjXWd",
        "hidden": 0
      },
      {
        "text": "notes about this code:\nnoise() samples from a noise texture, I think the texture has been generated such that by linearly interpolating by fract(x), you can get a continuous smooth noise function.\n\nthe map() functions sample the noise at increasing detail. this technique is called the fractional brownian motion. what it means is you sample several noise functions and add them together, the lower frequency noise functions have heavier weight (0.5) vs the higher frequency noise function (0.25 etc). Not using *2 to avoid aliasing and artifacts.\n\nRaymarch steps from ro (ray origin) along rd (ray direction) and adds a light computation along the way. The lighting is pretty simple the brightness is linear with cloud density, and there is some extra glow added if dif is large. Dif is an approximate occlusion test - the density in the sun direction is calculated, and if it is clear then assume the sun can reach the cloud and make it glow.",
        "date": "1438514771",
        "username": "windoze",
        "userpicture": "/img/profile.jpg",
        "id": "Xs2SWK",
        "hidden": 0
      },
      {
        "text": "iq, did you come up with those map functions or are they some standard noise functions? Are the values 2.01, 2.02, etc. any better than just using 2.0? And is the equation in the clamp line arbitrary as well?",
        "date": "1435154861",
        "username": "gsingh93",
        "userpicture": "/img/profile.jpg",
        "id": "4sBXWw",
        "hidden": 0
      },
      {
        "text": "This would be even more fantastic if the camera went a around randomly as if you were flying around, however as is indeed fantastic enough. Love it.",
        "date": "1433031494",
        "username": "uNiversal",
        "userpicture": "/media/users/uNiversal/profile.png",
        "id": "XdSXWR",
        "hidden": 0
      },
      {
        "text": "iq could you tell me how to add this cloud to UNIGINE(some sort of game engine) to replace its existing cloud.",
        "date": "1430424100",
        "username": "tommywuhaojie",
        "userpicture": "/img/profile.jpg",
        "id": "lsBXz1",
        "hidden": 0
      },
      {
        "text": "iq could you tell me how to add this cloud to UNIGINE(some sort of game engine).",
        "date": "1430424052",
        "username": "tommywuhaojie",
        "userpicture": "/img/profile.jpg",
        "id": "MdBXz1",
        "hidden": 0
      },
      {
        "text": "this is unbelievable amazing!!! and less than 3k chars ",
        "date": "1428656953",
        "username": "Emuljan",
        "userpicture": "/media/users/Emuljan/profile.jpeg",
        "id": "XdsXDs",
        "hidden": 0
      },
      {
        "text": "iq should write a book. I would buy it :)",
        "date": "1423522431",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "ldXSRf",
        "hidden": 0
      },
      {
        "text": "better mouse controls:\n\nvec2 mo = vec2(0.0,0.0);\n\nvoid main( void )\n{\n    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/ iResolution.y;\n\n    if(iMouse != vec4(0,0,0,0))\n        mo = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    // camera\n    vec3 ro = vec3(cos(mo.x*3.14), mo.y*1.5+2.5, sin(mo.x*3.14));\n    vec3 ta = vec3(0.0, 2.0, 0.0);",
        "date": "1423511479",
        "username": "rgbk",
        "userpicture": "/img/profile.jpg",
        "id": "lsfXzX",
        "hidden": 0
      },
      {
        "text": "hey possible copy code for shader minecraft seus v10.1 or 10.2 ?? ",
        "date": "1422185243",
        "username": "huss93",
        "userpicture": "/img/profile.jpg",
        "id": "XslXDM",
        "hidden": 0
      },
      {
        "text": "Back when I wrote this shader WebGL was still using DirectX9, and \"break\" wasn't implemented really or was too slow, and \"continue\" was a much faster alternative. These days WebGL uses DirectX11 with proper and real flow control (most of the time) and \"break\" is implemented, so yes, it can (should) be used.",
        "date": "1414738012",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XdfSz4",
        "hidden": 0
      },
      {
        "text": "Pardon my ignorance, but is there a reason why in the raymarch code there's an if(sum.a > 0.99 ) continue;?  Shouldn't it be a break, seeing as how the code doesn't modify sum.a before that point?",
        "date": "1414737855",
        "username": "eddieparker",
        "userpicture": "/img/profile.jpg",
        "id": "4sXSz4",
        "hidden": 0
      },
      {
        "text": "how have you done this?",
        "date": "1412394076",
        "username": "zarpar7755",
        "userpicture": "/media/users/zarpar7755/profile.png",
        "id": "ldfSzr",
        "hidden": 0
      },
      {
        "text": "It's so much faster now, still awesome",
        "date": "1407716630",
        "username": "weyland",
        "userpicture": "/media/users/weyland/profile.jpeg",
        "id": "MdSGDV",
        "hidden": 0
      },
      {
        "text": "i feel i should post a link to this \"making of\" video for someone that did raymarching of clouds obsessively: http://vimeo.com/6357535",
        "date": "1407518992",
        "username": "iterationsteppa",
        "userpicture": "/img/profile.jpg",
        "id": "MsB3DK",
        "hidden": 0
      },
      {
        "text": "This is beautiful",
        "date": "1402430186",
        "username": "jctwood",
        "userpicture": "/media/users/jctwood/profile.jpeg",
        "id": "Xs23zK",
        "hidden": 0
      },
      {
        "text": "this may work as the iteration line [b] f=(1.0-cos(x * 3.1415927))* 0.5;\n f= a*(1.0-f)+b*f; [/b] instead of [b]f=f*f...[/b] could be interesting",
        "date": "1391943713",
        "username": "iterationsteppa",
        "userpicture": "/img/profile.jpg",
        "id": "MsS3zw",
        "hidden": 0
      },
      {
        "text": "how can i tell if     return [b]fract(n*543.5988)*fract(n*43758.5453)[/b]is faster than the [b]fract(sin(n)*5435.543)[/b]",
        "date": "1391788078",
        "username": "iterationsteppa",
        "userpicture": "/img/profile.jpg",
        "id": "XdB3zm",
        "hidden": 0
      },
      {
        "text": "your hash is based on hash-sin function... Sin is great because it is nonlinear, although there is an even cheaper perhaps funtion which is simply (x*x) (frac(x)^2) is perhaps faster than Sin sometimes.",
        "date": "1391787507",
        "username": "iterationsteppa",
        "userpicture": "/img/profile.jpg",
        "id": "4sS3zm",
        "hidden": 0
      },
      {
        "text": "I've made a pic of this noise fucntion to assess it's forms,  using a more random hash value from cpu, here is it in full glory, note the xyz axes should be absolute: http://i.stack.imgur.com/97UKq.jpg",
        "date": "1391779779",
        "username": "iterationsteppa",
        "userpicture": "/img/profile.jpg",
        "id": "4dS3zm",
        "hidden": 0
      },
      {
        "text": "iq - can you recommend a good reference on noise for someone new to shaders?  thanks\n",
        "date": "1375994603",
        "username": "JellyBean",
        "userpicture": "/media/users/JellyBean/profile.jpeg",
        "id": "4sXGRj",
        "hidden": 0
      },
      {
        "text": "Have you tried halving the step values and doubling the ray-march for-loop?\n- Looks astonishing!",
        "date": "1373031369",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Mds3DN",
        "hidden": 0
      },
      {
        "text": "I removed the per-octave rotation in the fractional brownian motion (thx Simon Green), and I went from 50 to 60 fps without much noticeable isotropic artifacts (although it only seems to work fine for clouds, which are very transparent - if I try it in solid raymarching I can see alignment artifacts).",
        "date": "1372973661",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "Mdl3DN",
        "hidden": 0
      },
      {
        "text": "Artifacts gone! :) ",
        "date": "1372943378",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "ldsGDN",
        "hidden": 0
      },
      {
        "text": "I have brought it here and optimized it a lot (there was lots of shared computations between the two noise layers), and now it's pretty fast again.\n\nI have published a reference implementation here: [url=https://www.shadertoy.com/view/4sfGzS]https://www.shadertoy.com/view/4sfGzS[/url]",
        "date": "1372878706",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "Mdl3WN",
        "hidden": 0
      },
      {
        "text": "Hmm, if you use the same noise function as your 'Volcanic' shader, the artifacts disappear, it's not quite as fast though, but still worth it.",
        "date": "1372876331",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MssGWN",
        "hidden": 0
      },
      {
        "text": "Yep, its fast as hell. However, there are some visible artifacts now.",
        "date": "1372688804",
        "username": "srtuss",
        "userpicture": "/media/users/srtuss/profile.jpeg",
        "id": "4slGDN",
        "hidden": 0
      },
      {
        "text": "I replaced the noise computations from a pure procedural version to a LUT based one (and linear interpolation instead of cubic). That went from 16 fps to 60 fps in my machine.",
        "date": "1372660163",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4dl3WN",
        "hidden": 0
      },
      {
        "text": "incredible. I am speechless.",
        "date": "1365883474",
        "username": "atomek",
        "userpicture": "/media/users/atomek/profile.jpeg",
        "id": "4dl3R4",
        "hidden": 0
      },
      {
        "text": "absolutely stunning composition",
        "date": "1364172415",
        "username": "weyland",
        "userpicture": "/media/users/weyland/profile.jpeg",
        "id": "ldlGz8",
        "hidden": 0
      },
      {
        "text": "Stunning! But verrrrry slow :(",
        "date": "1362138135",
        "username": "neave",
        "userpicture": "/img/profile.jpg",
        "id": "Xdl3Rn",
        "hidden": 0
      },
      {
        "text": "nice!, raymarch got future",
        "date": "1362065494",
        "username": "mmword",
        "userpicture": "/img/profile.jpg",
        "id": "MsfGzr",
        "hidden": 0
      },
      {
        "text": "Ahh...looking forward to 52 weeks of beauty iq!",
        "date": "1361989033",
        "username": "rotomonkey",
        "userpicture": "/img/profile.jpg",
        "id": "MdX3Rr",
        "hidden": 0
      },
      {
        "text": "Gorgeous!\n\nCan't wait for the next ones :P",
        "date": "1361928459",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "MsXGRr",
        "hidden": 0
      },
      {
        "text": "You should definitely write somewhere that this is the 1st of the 52 shaders (one per week) you want to write this year ;)",
        "date": "1361848883",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "lsXGzn",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "XtcGWn",
      "date": "1468535381",
      "viewed": 77012,
      "name": "Ray Marching: Part 5",
      "username": "jlfwong",
      "description": "Part 5 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/",
      "likes": 17,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/**\n * Part 5 Challenges:\n * - Change the axis of motion of the cube being intersected with the sphere\n * - Rotate the intersection \n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;\n    float cubeDist = cubeSDF(samplePoint + vec3(0.0, sin(iTime), 0.0));\n    return intersectSDF(cubeDist, sphereDist);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "Xtd3z7",
      "date": "1468453826",
      "viewed": 78213,
      "name": "Ray Marching: Part 3",
      "username": "jlfwong",
      "description": "Part 3 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/",
      "likes": 29,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/**\n * Part 3 Challenges\n * - Make the camera move up and down while still pointing at the cube\n * - Make the camera roll (stay looking at the cube, and don't change the eye point)\n * - Make the camera zoom in and out\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return cubeSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "@jlfwong Thanks for the reply, I think this thing snuck its way into my dreams last night...\nGlad I'm not losing the plot here.... Indeed, indeed, I could feel it was some normalisation shizzle of the function itself - but like you, couldnt understand why gluLookAt would be any different?\nThanks dude, you saved me alot of confuddlings... :)",
        "date": "1486684717",
        "username": "metta",
        "userpicture": "/img/profile.jpg",
        "id": "XscXzf",
        "hidden": 0
      },
      {
        "text": "@metta That is an excellent question!\n\nThis nerd sniped me super hard, and spent the last hour trying to understand the problem.\n\nI believe the problem is, in fact, a bug in the viewMatrix function!\n\nWith the bug, the side vector \"s\" is defined as cross(f, up).\n\nI believe the correction should be vec3 s = normalize(cross(f, up));\n\nWhat I can't figure out is why the man page for gluLookAt doesn't normalize. Looking around for implementations of gluLookAt, it looks like this might be a bug in the docs?\n\nI guess I should go through all the shadertoys and the blog post and fix that!",
        "date": "1486624943",
        "username": "jlfwong",
        "userpicture": "/img/profile.jpg",
        "id": "Xd3XRf",
        "hidden": 0
      },
      {
        "text": "Why is it that setting the line:\nvec3 eye = vec3(8.0, 5.0*sin(iGlobalTime), 7.0);\nMoves the camera vertically, looking at vec3(0.0, 0.0, 0.0), but the apparent size of the cube does not change? (as the eye gets further from the target)\nYet - Conversely, vec3 eye = vec3(8.0*sin(iGlobalTime), 5.0, 7.0);\ngives the expected horizontal effect?",
        "date": "1486583430",
        "username": "metta",
        "userpicture": "/img/profile.jpg",
        "id": "XdcSzX",
        "hidden": 0
      },
      {
        "text": "@TriBar the camera angle isn't specified directly. Instead, the position of the camera is placed, and the center of view is specified (this is what the first two arguments to viewMatrix represent).\n\nIf you *did* want to specify a camera angle directly, you can make eye (the camera position) a function of an angle.",
        "date": "1472234416",
        "username": "jlfwong",
        "userpicture": "/img/profile.jpg",
        "id": "4stGRf",
        "hidden": 0
      },
      {
        "text": "Hello! Thank you for the excellent tutorial.\nI have a problem with the second challenge.\nWhat part of code stands for camera angle? I tried playing with up vector, it turns a bit but on large numbers it starts to zoom out.",
        "date": "1472213581",
        "username": "TriBar",
        "userpicture": "/img/profile.jpg",
        "id": "4dtGzX",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "XtlSD7",
      "date": "1438211838",
      "viewed": 67691,
      "name": "[SIG15] Mario World 1-1",
      "username": "knarkowicz",
      "description": "NES Super Mario Bros. World 1-1. My favorite game moment (just like for most kids in the early 90s). 20 years later implemented in a single shader.",
      "likes": 223,
      "published": 3,
      "flags": 8,
      "tags": [
        "2d",
        "sound",
        "music",
        "crt",
        "sprite",
        "mario",
        "nes",
        "sig15"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Interesting findings from original NES Super Mario Bros.:\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\n// -Overworld (main theme) drum sound uses only the APU noise generator\n\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\n\nconst float MARIO_SPEED\t = 89.0;\nconst float GOOMBA_SPEED = 32.0;\nconst float INTRO_LENGTH = 2.0;\n\nvoid SpriteBlock( inout vec3 color, float x, float y )\n{\n    // black\n    float idx = 1.0;\n    \n    // light orange\n    idx = x < y ? 3.0 : idx;\n    \n    // dark orange\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\n    idx = x == 15.0 - y ? 2.0 : idx;\n    \n    color = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteHill( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    // dark green\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\n    \n    // black\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n}\n\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\n{\n    float offset = h * 16.0;\n\n    // light green\n\tfloat idx = 3.0;\n    \n    // dark green\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \n    \n    // black\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \n    \n    // transparent\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\n{\n\tfloat idx = 0.0;\n    \n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\n\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\n\tcolor = idx == 2.0 ? colorB \t\t: color;\n\tcolor = idx == 3.0 ? colorC \t\t: color;\n}\n\nvoid SpriteFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? 43690.0 : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\n{\n\tfloat idx = 0.0;\n\n    // second frame is flipped first frame\n    x = frame == 1.0 ? 15.0 - x : x;\n\n    if ( frame <= 1.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\n        idx = y ==  6.0 ? 43690.0 : idx;\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\n\t\tidx = y == 3.0 ? 43690.0 : idx;\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\n}\n\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\n{    \n\tfloat idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\n    }\n\telse\n\t{\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\n\t}\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 0.0 ? 21845.0 : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\n}\n\nvoid SpriteMushroom( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\n\tidx = y == 5.0 ? 43690.0 : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGround( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\n\tidx = y == 7.0 ? 1360.0  : idx;\n\tidx = y == 6.0 ? 6836.0  : idx;\n\tidx = y == 5.0 ? 27309.0 : idx;\n\tidx = y == 4.0 ? 27309.0 : idx;\n\tidx = y == 3.0 ? 27305.0 : idx;\n\tidx = y == 2.0 ? 27305.0 : idx;\n\tidx = y == 1.0 ? 6820.0  : idx;\n\tidx = y == 0.0 ? 1360.0  : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 3.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 4.0 )\n    {\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\n    }\n    else if ( frame == 5.0 )\n    {\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\n    }\n    else if ( frame == 6.0 )\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \n}\n\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n    }\n    \n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteBrick( inout vec3 color, float x, float y )\n{    \n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \n    float xmod8 = floor( mod( x, 8.0 ) );\n    float ymod8 = floor( mod( y, 8.0 ) );\n    \n    // dark orange\n    float idx = 2.0;\n   \n    // black\n    idx = ymod4 == 0.0 ? 1.0 : idx;\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\n\n    // light orange\n    idx = y == 15.0 ? 3.0 : idx;\n\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid DrawCastle( inout vec3 color, float x, float y )\n{\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\n\t{\n\t\tfloat ymod4    = mod( y, 4.0 );\n\t\tfloat xmod8    = mod( x, 8.0 );\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\n\t\tfloat ymod8    = mod( y, 8.0 );\n\n\t\t// dark orange\n\t\tfloat idx = 2.0;\n\n\t\t// black\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \n\n\t\t// white\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\n\n\t\t// transparent\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\n\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n\t}\n}\n\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\n{\n    if ( x >= 0.0 && x <= 15.0 )\n    {\n        SpriteKoopa( color, x, y, frame );\n    }\n}\n\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\n{\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\n    DrawKoopa( color, x, worldY - 16.0, frame );    \n}\n\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\n{\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\n    t = 1.0 - abs( 2.0 * t - 1.0 );\n\n    questionY -= floor( t * 8.0 );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {            \n    \tif ( time >= questionHitTime )\n        {                \n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n            {\n                color = RGB( 231, 90, 16 );\n            }\n        }\n        else\n        {\n         \tSpriteQuestion( color, questionX, questionY, questionT );\n        }\n    }\n}\n\nvoid DrawW( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 || x >= 10.0 ) \n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawO( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\n             || ( x >= 2.0 && x <= 4.0 )\n             || ( x >= 9.0 && x <= 11.0 )\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawR( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 )\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\n             || ( x >= 8.0  && y <= 1.0 )\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawL( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( x <= 3.0 || y <= 1.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawD( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n    \tcolor = RGB( 255, 255, 255 );        \n        \n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\n           )\n        {\n            color = RGB( 0, 0, 0 );\n        }\n    }\n}\n\nvoid Draw1( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( y <= 1.0 )\n             || ( x >= 5.0 && x <= 8.0 )\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawM( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( y >= 4.0 && y <= 7.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\n{\n    color = RGB( 0, 0, 0 );\n        \n    float offset \t= 18.0;     \n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\n    float marioX\t= textX - offset * 4.0;\n    float marioY\t= textY + 16.0 * 3.0;\n\t\n    DrawW( color, textX - offset * 0.0, textY );\n    DrawO( color, textX - offset * 1.0, textY );\n    DrawR( color, textX - offset * 2.0, textY );\n    DrawL( color, textX - offset * 3.0, textY );\n    DrawD( color, textX - offset * 4.0, textY );\n    Draw1( color, textX - offset * 6.0, textY );\n    DrawM( color, textX - offset * 7.0, textY );\n    Draw1( color, textX - offset * 8.0, textY );\n    \n    if ( marioX >= 0.0 && marioX <= 15.0 )\n    {\n    \tSpriteMario( color, marioX, marioY, 4.0 );\n    }\n}\n\nfloat CoinAnimY( float worldY, float time, float coinTime )\n{\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\n}\n\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\n{\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\n}\n\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\n{\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\n}\n\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\n{\n    float mushroomPauseStart \t= 16.25;    \n    float mushroomPauseLength \t= 2.0;    \n    float flagPauseStart\t\t= 38.95;\n    float flagPauseLength\t\t= 1.5;\n\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\n    float worldX \t\t= pixelX + cameraX;\n    float worldY  \t\t= pixelY - 8.0;\n    float tileX\t\t\t= floor( worldX / 16.0 );\n    float tileY\t\t\t= floor( worldY / 16.0 );\n    float tile2X\t\t= floor( worldX / 32.0 );\n    float tile2Y\t\t= floor( worldY / 32.0 );    \n    float worldXMod16\t= mod( worldX, 16.0 );\n    float worldYMod16 \t= mod( worldY, 16.0 );\n\n\n    // default background color\n    color = RGB( 92, 148, 252 );\n\n    \n    // draw hills\n    float bigHillX \t = mod( worldX, 768.0 );\n    float smallHillX = mod( worldX - 240.0, 768.0 );\n    float hillX \t = min( bigHillX, smallHillX );\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\n    SpriteHill( color, hillX, hillY );\n\n\n    // draw clouds and bushes\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \n    float scCloudX  = min( sc1CloudX, sc2CloudX );\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\n    float sCloudX\t= min( scCloudX, sbCloudX );\n    float mCloudX\t= min( mcCloudX, mbCloudX );\n    float lCloudX\t= min( lcCloudX, lbCloudX );\n    float cloudX\t= min( cCloudX, bCloudX );\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\n    {\n        if ( cloudSeg == 1.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\n        }\n        if ( cloudSeg == 2.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\n        }\n        \n    \tSpriteCloud( color, cloudX, cloudY, isBush );\n    }\n\n    \n    \n    // draw flag pole\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \n    {\n        color = RGB( 189, 255, 24 );\n    }\n    \n    // draw flag\n    float flagX = worldX - 3160.0;\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\n    if ( flagX >= 0.0 && flagX <= 15.0 )\n    {\n    \tSpriteFlag( color, flagX, flagY );\n    }     \n    \n    // draw flagpole end\n    float flagpoleEndX = worldX - 3172.0;\n    float flagpoleEndY = worldY - 176.0;\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\n    {\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\n    }\n    \n    \n\n    // draw blocks\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\n         || ( tileX == 198.0 && tileY == 1.0 )\n       )\n    {\n        SpriteBlock( color, worldXMod16, worldYMod16 );\n    }\n    \n    \n    // draw pipes\n    float pipeY = worldY - 16.0;  \n    float pipeH\t= 0.0;    \n    float pipeX = worldX - 179.0 * 16.0;\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 163.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 57.0 * 16.0;\n        pipeH = 2.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 46.0 * 16.0;\n        pipeH = 2.0;\n    } \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 38.0 * 16.0;\n        pipeH = 1.0;\n    }         \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 28.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\n\t{\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\n\t}\n    \n    \n    // draw mushroom\n    float mushroomStart = 15.7;    \n    if ( time >= mushroomStart && time <= 17.0 )\n    {\n        float jumpTime = 0.5;\n        \n        float mushroomX = worldX - 1248.0;\n        float mushroomY = worldY - 4.0 * 16.0;\n        if ( time >= mushroomStart )\n        {\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\n        }\n        if ( time >= mushroomStart + 0.5 )\n        {\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\n        }\n        if ( time >= mushroomStart + 0.5 + 0.4 )\n        {\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\n        }\n        \n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\n        {\n        \tSpriteMushroom( color, mushroomX, mushroomY );\n        }\n    }\n\n    \n    // draw coins\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\n    float coinX \t= worldX - 2720.0;\n    float coinTime \t= 33.9;    \n    float coinY \t= CoinAnimY( worldY, time, coinTime );\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 1696.0;\n    \tcoinTime \t= 22.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \n    }\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 352.0;\n    \tcoinTime \t= 5.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\n    } \n    \n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\n    {   \n        SpriteCoin( color, coinX, coinY, coinFrame );\n    }\n\n    \n    // draw questions\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\n    }\n    \n    \n    // draw hitted questions\n    float questionHitTime \t= 33.9;\n    float questionX \t\t= worldX - 2720.0;\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 22.4;\n        questionX\t\t= worldX - 1696.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 15.4;\n        questionX\t\t= worldX - 1248.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 5.3;\n        questionX\t\t= worldX - 352.0;\n    }    \n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {\n    \tSpriteQuestion( color, questionX, questionY, questionT );\n    }\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n    {\n        color = RGB( 231, 90, 16 );\n    }    \n\n    \n    // draw bricks\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteBrick( color, worldXMod16, worldYMod16 );\n    }   \n    \n    \n    // draw castle flag\n    float castleFlagX = worldX - 3264.0;\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\n    {\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\n\t}\n    \n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\n\n    // draw ground\n    if ( tileY <= 0.0\n         && !( tileX >= 69.0  && tileX < 71.0 )\n         && !( tileX >= 86.0  && tileX < 89.0 ) \n         && !( tileX >= 153.0 && tileX < 155.0 ) \n       )\n    {\n        SpriteGround( color, worldXMod16, worldYMod16 );\n    }    \n    \n\n    // draw Koopa\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\n    \n    \n    // draw stomped walking Goombas\n    float goombaY \t\t\t= worldY - 16.0;        \n    float goombaLifeTime \t= 26.3;\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 25.3;\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n\t\tgoombaLifeTime \t= 23.5;\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n        goombaLifeTime \t= 20.29;\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 10.3;\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    }\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }    \n    \n    // draw walking Goombas\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }\n    \n\n    \n    // Mario jump\n    float marioBigJump1 \t= 27.1;\n    float marioBigJump2 \t= 29.75;\n    float marioBigJump3 \t= 35.05;    \n    float marioJumpTime \t= 0.0;\n    float marioJumpScale\t= 0.0;\n    \n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\n    \n    float marioJumpOffset \t\t= 0.0;\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\n    {\n        float t = ( time - marioJumpTime ) / marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n    \n    // Mario land\n    float marioLandTime \t= 0.0;\n    float marioLandAplitude = 0.0;\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\n    \n    float marioLandLength = marioLandAplitude / 120.0;\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\n    {\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\n    }\n    \n    \n    // Mario flag jump\n    marioJumpTime \t\t= flagPauseStart - 0.3;\n    marioJumpLength \t= 1.5  * 0.45;\n    marioJumpAmplitude\t= 76.0 * 0.45;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \n    {\n        float time2 = time;\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \n        {\n            time2 = flagPauseStart;\n        }\n        else if ( time >= flagPauseStart )\n        {\n            time2 = time - flagPauseLength;\n        }\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n\n    // Mario base (ground offset)\n    float marioBase = 0.0;\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\n    {\n        marioBase = 16.0 * 3.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\n    {\n        marioBase = 16.0 * 7.0;\n    }\n\n    float marioX\t\t= pixelX - 112.0;\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\n    {\n    \tmarioFrame = 1.0;\n    }    \n    if ( time > mushroomPauseStart + 0.7 )\n    {\n        float t = time - mushroomPauseStart - 0.7;\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\n        {\n            // super mario offset\n            marioFrame += 4.0;\n        }\n    }    \n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\n    {\n        SpriteMario( color, marioX, marioY, marioFrame );\n    }\n}\n\nvec2 CRTCurveUV( vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\nvoid DrawVignette( inout vec3 color, vec2 uv )\n{    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n}\n\nvoid DrawScanline( inout vec3 color, vec2 uv )\n{\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \n    color *= scanline * grille * 1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\n    float resMultX  = floor( iResolution.x / 224.0 );\n    float resMultY  = floor( iResolution.y / 192.0 );\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\n    \n    float time\t\t\t= iTime;\n    float screenWidth\t= floor( iResolution.x * resRcp );\n    float screenHeight\t= floor( iResolution.y * resRcp );\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\n\n    vec3 color = RGB( 92, 148, 252 );\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\n    if ( time < INTRO_LENGTH )\n    {\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\n    }    \n\n    \n    // CRT effects (curvature, vignette, scanlines and CRT grille)\n    vec2 uv    = fragCoord.xy / iResolution.xy;\n    vec2 crtUV = CRTCurveUV( uv );\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\n    {\n        color = vec3( 0.0, 0.0, 0.0 );\n    }\n    DrawVignette( color, crtUV );\n    DrawScanline( color, uv );\n    \n\tfragColor.xyz \t= color;\n    fragColor.w\t\t= 1.0;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [
          {
            "id": "XsfGRr",
            "channel": 0
          }
        ],
        "code": "// Overworld theme based on notes from geoffrey1218's famitracker cover\n// Level clear theme based on notes from WheeljackDude's famitracker cover\n\nfloat SquareWave25( float f, float x )\n{\n    return floor( 4.0 * floor( f * x ) - floor( 4.0 * f * x ) + 1.0 );\n}\n\nfloat SquareWave50( float f, float x )\n{\n    return floor( 2.0 * floor( f * x ) - floor( 2.0 * f * x ) + 1.0 );\n}\n\nfloat SinWave( float f, float x )\n{\n    return sin( f * x * 2.0 * 3.14 );\n}\n\nfloat SawtoothWave( float q, float x )\n{\n    float f = fract( x ) - q;\n    f /= (f >= 0.0 ? 1.0 : 0.0) - q;\n    return f * 2.0 - 1.0;\n}\n\nfloat Noise( float x )\n{\n    return fract( sin( 123523.9898 * x ) * 43758.5453 );\n}\n\nfloat Jump( float t )\n{\n    if ( t < 0.0 || t > 0.5 )\n    {\n        return 0.0;\n    }\n    \n\n\tfloat freq = mix( 250.0, 330.0, t / 0.5 );\n    \n    float waveSwitchT = 0.068;\n    if ( t < waveSwitchT ) \n    {\n        return SquareWave50( freq, t ) * 0.5;\n    }\n    else\n    {\n        return SquareWave25( freq, t ) * clamp( 1.0 - ( t - 0.1 ) / ( 0.5 - 0.1 ), 0.0, 1.0 ) * 0.5;\n    }\n}\n\nfloat Stomp( float t )\n{\n    if ( t < 0.0 || t > 0.25 )\n    {\n        return 0.0;\n    }\n \n    float freq = mix( 200.0, 300.0, t / 0.2 );\n\n    if ( t <= 0.1 )\n    {\n    \treturn SquareWave50( freq, t ) * clamp( t / 0.1, 0.0, 1.0 );\n    }\n    else\n    {\n        return SquareWave50( freq, t ) * clamp( ( t - 0.1 ) / 0.15, 0.0, 1.0 );\n    }\n}\n\nfloat PowerUp( float t )\n{\n    if ( t < 0.0 || t > 0.9 )\n    {\n        return 0.0;\n    }\n    \n    float freq = 250.0 + mod( t, 0.3 ) * 50.0;\n    return mix( SquareWave50( freq, t ), SquareWave25( freq, t ), mod( t, 0.3 ) > 0.2 ? 0.5 : 0.0 ) * 0.5;\n}\n\nfloat Bump( float t )\n{\n    if ( t < 0.0 || t > 0.15 )\n    {\n        return 0.0;\n    }\n    \n    float freq = mix( 150.0, 130.0, abs( t - 0.075 ) / 0.075 );\n    return SquareWave50( freq, t ) * 0.5 + SinWave( freq, t ) * 0.5;\n}\n\nfloat Coin( float t )\n{\n    if ( t < 0.0 || t > 0.75 )\n    {\n        return 0.0;\n    }    \n    \n    float freq = t > 0.1 ? 600.0 : 480.0;\n    return SquareWave50( freq, t ) * clamp( 1.0 - ( t - 0.1 ) / 0.65, 0.0, 1.0 );\n}\n\nfloat DownTheFlagpole( float t )\n{\n    if ( t < 0.0 || t > 1.0 )\n    {\n        return 0.0;\n    } \n    \n    float freq = floor( mix( 200.0, 600.0, t ) * 0.1 ) * 10.0;\n\treturn SquareWave50( freq, t ) * clamp( 1.0 - ( t - 0.95 ) / 0.05, 0.0, 1.0 );\n}\n\nfloat InstrumentMain( float f, float t )\n{\n    float ret = 0.0;\n    ret += SquareWave50( f, t ) * clamp( 1.0 - t / 0.250, 0.0, 1.0 ) * 0.5;\n    return ret;\n}\n\nfloat InstrumentBass( float f, float t )\n{\n\treturn SinWave( f, t ) * clamp( 1.0 - ( t - 0.1 ) / 0.01, 0.0, 1.0 );\n}\n\nfloat InstrumentDrums( float f, float t )\n{\n    if ( f == 1.0 )\n    {\n        // open\n    \treturn Noise( t ) * clamp( 1.0 - ( t - 0.08 ) / ( 0.001 ), 0.0, 1.0 ) * 0.66;  \n    }\n    else if ( f == 2.0 )\n    {\n        // close\n        return Noise( t ) * clamp( 1.0 - ( t - 0.0165 ) / ( 0.001 ), 0.0, 1.0 ) * 0.66;\n    }\n    else\n    {\n    \t// kick\n        return SquareWave50( 100.0, t ) * clamp( 1.0 - ( t - 0.0165 ) / ( 0.001 ), 0.0, 1.0 );\n    }\n}\n\n// note frequencies\nconst float E2\t=  82.41;\nconst float F2\t=  87.31;\nconst float G2 \t=  98.00;\nconst float GH2 = 103.83;\nconst float AH2 = 116.54;\nconst float C3 \t= 130.81;\nconst float CH3\t= 138.59;\nconst float D3 \t= 146.83;\nconst float DH3 = 155.56;\nconst float E3 \t= 164.81;\nconst float F3\t= 174.61;\nconst float FH3 = 185.00;\nconst float G3 \t= 196.00;\nconst float GH3 = 207.65;\nconst float A3 \t= 220.00;\nconst float AH3\t= 233.08;\nconst float B3 \t= 246.94;\nconst float C4 \t= 261.63;\nconst float D4  = 293.66;\nconst float DH4 = 311.13;\nconst float E4 \t= 329.63;\nconst float F4 \t= 349.23;\nconst float FH4 = 369.99;\nconst float G4 \t= 392.00;\nconst float GH4 = 415.30;\nconst float A4\t= 440.00;\nconst float AH4 = 466.16;\nconst float C5  = 523.25;\nconst float G5  = 783.99;\n\n#define N( off, freq ) \tif( pos > patternPos + float( off ) ) { notePos = patternPos + float( off ); noteFreq = float( freq ); }\n#define PEND\t\t\tpatternPos += 32.0;\n\nconst float TimeToPos = 1000.0 / 75.0;\nconst float PosToTime = 1.0 / TimeToPos;\n\nfloat OverworldMelody( float time )\n{\n    float pos\t\t\t= time * TimeToPos;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n#define P0  N(0,E4)N(2,E4)N(6,E4)N(10,C4)N(12,E4)N(16,G4)PEND\n#define P1  N(0,C4)N(6,G3)N(12,E3)N(18,A3)N(22,B3)N(26,AH3)N(28,A3)PEND\n#define P2  N(0,G3)N(3,E4)N(6,G4)N(8,A4)N(12,F4)N(14,G4)N(18,E4)N(22,C4)N(24,D4)N(26,B3)PEND\n#define P3  N(4,G4)N(6,FH4)N(8,F4)N(10,DH4)N(14,E4)N(18,GH3)N(20,A3)N(22,C4)N(26,A3)N(28,C4)N(30,D4)PEND\n#define P4  N(4,G4)N(6,FH4)N(8,F4)N(10,DH4)N(14,E4)N(18,C5)N(22,C5)N(24,C5)PEND\n#define P5  N(4,DH4)N(10,D4)N(16,C4)PEND\n#define P6  N(0,C4)N(2,C4)N(6,C4)N(10,C4)N(12,D4)N(16,E4)N(18,C4)N(22,A3)N(24,G3)PEND\n#define P7  N(0,C4)N(2,C4)N(6,C4)N(10,C4)N(12,D4)N(14,E4)PEND\n    \n    P0 P1 P2 P1 P2 P3 P4 P3 P5 P3 \n    P4 P3 P5 P6 P7 P6 P0 P1 P2 P1\n        \n#undef P0\n#undef P1\n#undef P2\n#undef P3        \n#undef P4        \n#undef P5\n#undef P6\n#undef P7\n\n\treturn InstrumentMain( noteFreq, ( pos - notePos ) * PosToTime );\n}\n\nfloat OverworldHarmony( float time )\n{\n    float pos\t\t\t= time * TimeToPos;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n#define P0  N(0,FH3)N(2,FH3)N(6,FH3)N(10,FH3)N(12,FH3)N(16,B3)N(24,G3)PEND\n#define P1  N(0,E3)N(6,C3)N(12,G2)N(18,C3)N(22,D3)N(26,CH3)N(28,C3)PEND\n#define P2  N(0,C3)N(3,G3)N(6,B3)N(8,C4)N(12,A3)N(14,B3)N(18,A3)N(22,E3)N(24,F3)N(26,D3)PEND    \n#define P3  N(4,E4)N(6,DH4)N(8,D4)N(10,B3)N(14,C4)N(18,E3)N(20,F3)N(22,G3)N(26,C3)N(28,E3)N(30,F3)PEND    \n#define P4  N(4,E4)N(6,DH4)N(8,D4)N(10,B3)N(14,C4)N(18,F4)N(22,F4)N(24,F4)PEND\n#define P5  N(4,GH3)N(10,F3)N(16,E3)PEND\n#define P6  N(0,GH3)N(2,GH3)N(6,GH3)N(10,GH3)N(12,AH3)N(16,G3)N(18,E3)N(22,E3)N(24,C3)PEND\n#define P7  N(0,GH3)N(2,GH3)N(6,GH3)N(10,GH3)N(12,AH3)N(14,G3)PEND\n    \n    P0 P1 P2 P1 P2 P3 P4 P3 P5 P3 \n    P4 P3 P5 P6 P7 P6 P0 P1 P2 P1\n        \n#undef P0\n#undef P1\n#undef P2\n#undef P3        \n#undef P4        \n#undef P5\n#undef P6\n#undef P7\n\n    return InstrumentMain( noteFreq, ( pos - notePos ) * PosToTime );\n}\n\n\nfloat OverworldBass( float time )\n{\n    float pos\t\t\t= time * TimeToPos;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n\n#define P0 N(0,D3)N(2,D3)N(6,D3)N(10,D3)N(12,D3)N(16,G4)N(24,G3)PEND\n#define P1 N(0,G3)N(6,E3)N(12,C3)N(18,F3)N(22,G3)N(26,FH3)N(28,F3)PEND\n#define P2 N(0,E3)N(3,C4)N(6,E4)N(8,F4)N(12,D4)N(14,E4)N(18,C4)N(22,A3)N(24,B3)N(26,G3)PEND    \n#define P3 N(0,C3)N(6,G3)N(12,C4)N(16,F3)N(22,C4)N(24,C4)N(28,F3)PEND\n#define P4 N(0,C3)N(6,E3)N(12,G3)N(14,C4)N(18,G5)N(22,G5)N(24,G5)N(28,G3)PEND\n#define P5 N(0,C3)N(4,GH3)N(10,B3)N(16,C4)N(16,C4)N(22,G3)N(24,G3)N(28,C3)PEND\n#define P6 N(0,GH2)N(6,DH3)N(12,GH3)N(16,G3)N(22,C3)N(28,G2)PEND\n    \n    P0 P1 P2 P1 P2 P3 P4 P3 P5 P3 \n    P4 P3 P5 P6 P6 P6 P0 P1 P2 P1\n        \n#undef P0\n#undef P1\n#undef P2\n#undef P3        \n#undef P4        \n#undef P5\n#undef P6        \n\n    return InstrumentBass( noteFreq, ( pos - notePos ) * PosToTime );\n}\n\nfloat OverworldDrums( float time )\n{\n    float pos\t\t\t= time * TimeToPos;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n    // 1 - open\n    // 2 - close\n    // 3 - kick\n#define P0 N(0,1)N(4,2)N(6,1)N(10,2)N(12,1)N(16,1)N(24,1)N(26,2)N(28,2)N(30,2)PEND\n#define P1 N(0,3)N(4,2)N(7,2)N(8,1)N(12,2)N(15,2)N(16,3)N(20,2)N(23,2)N(24,1)N(28,2)N(31,2)PEND\n#define P2 N(0,1)N(4,2)N(6,1)N(10,2)N(12,1)N(15,1)N(22,1)N(26,2)N(28,2)N(30,2)PEND    \n    \n    P0 P1 P1 P1 P1 P1 P1 P1 P1 P1\n    P1 P1 P1 P2 P2 P2 P0 P1 P1 P1\n        \n#undef P0\n#undef P1        \n#undef P2\n    \n    return InstrumentDrums( noteFreq, ( pos - notePos ) * PosToTime );\n}\n\nconst float TimeToPos2 = 0.5 * TimeToPos;\nconst float PosToTime2 = 1.0 / TimeToPos2;\n\nfloat LevelClearMelody( float time )\n{\n    float pos\t\t\t= time * TimeToPos2;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n\tN(0,G2)N(1,C3)N(2,E3)N(3,G3)N(4,C4)N(5,E4)N(6,G4)N(9,E4)N(12,GH2)N(13,C3)N(14,DH3)N(15,GH3)N(16,C4)N(17,DH4)N(18,GH4)N(21,DH4)N(24,AH2)N(25,DH3)N(26,F3)N(27,AH3)N(28,D4)N(29,F4)N(30,AH4)N(33,AH4)N(34,AH4)N(35,AH4)N(36,E4)\n\n    return InstrumentMain( noteFreq, ( pos - notePos ) * PosToTime2 );\n}\n\nfloat LevelClearHarmony( float time )\n{\n    float pos\t\t\t= time * TimeToPos2;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n\tN(1,E2)N(2,G2)N(3,C3)N(4,E3)N(5,G3)N(6,C4)N(9,G3)N(13,E2)N(14,GH2)N(15,C3)N(16,DH3)N(17,GH3)N(18,C4)N(21,GH3)N(25,F2)N(26,AH2)N(27,D3)N(28,F3)N(29,AH3)N(30,D4)N(33,D4)N(36,C5)\n\n    return InstrumentMain( noteFreq, ( pos - notePos ) * PosToTime2 );\n}\n\nfloat LevelClearBass( float time )\n{\n    float pos\t\t\t= time * TimeToPos2;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n\tN(3,C3)N(4,E3)N(5,G3)N(6,E4)N(9,C4)N(15,C3)N(16,DH3)N(17,GH3)N(18,DH4)N(21,C4)N(27,D3)N(28,F3)N(29,AH3)N(30,F4)N(33,D4)N(34,D4)N(35,D4)N(36,C4)\n\n    return InstrumentBass( noteFreq, ( pos - notePos ) * PosToTime2 );\n}\n\nfloat GameSounds( float time )\n{\n    // play sounds a bit earlier\n    time += 0.1;\n\n    float ret = 0.0;\n    \n    float marioBigJump1 = 27.1;\n    float marioBigJump2 = 29.75;\n    float marioBigJump3 = 35.05;    \n    \n    \n    // Jump sounds\n    float jumpTime = time - 38.7;\n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump3 - 1.2 - 0.75; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump3 - 1.2; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump3; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 34.15; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 33.7; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 32.3; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump2 - 1.0; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump2; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump1 - 1.0; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump1; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 25.75; }    \n\tif ( jumpTime <= 0.0 ) { jumpTime = time - 24.7; }        \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 23.0; } \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 21.7; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 19.65; }   \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 18.7; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 15.1; } \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 13.62; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 11.05; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 9.0; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 7.8; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 6.05; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 5.0; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 4.2; }\n\tret += Jump( jumpTime );                           \n\n    // block bump sounds\n    float bumpTime = time - 33.9;\n    if ( bumpTime <= 0.0 ) { bumpTime = time - 22.4; }\n    if ( bumpTime <= 0.0 ) { bumpTime = time - 15.4; }\n    if ( bumpTime <= 0.0 ) { bumpTime = time - 5.3; }\n    ret += Bump( bumpTime );\n    \n    // coin sounds\n    float coinTime = time - 33.9;\n    if ( coinTime <= 0.0 ) { coinTime = time - 22.4; }\n    if ( coinTime <= 0.0 ) { coinTime = time - 5.4; }    \n    ret += Coin( coinTime );    \n\n    float stompTime = time - 26.3;\n    if ( stompTime <= 0.0 ) { stompTime = time - 25.3; }\n    if ( stompTime <= 0.0 ) { stompTime = time - 23.5; }    \n    if ( stompTime <= 0.0 ) { stompTime = time - 20.29; }    \n    if ( stompTime <= 0.0 ) { stompTime = time - 10.3; }    \n    ret += Stomp( stompTime );\n    \n\tret += PowerUp( time - 17.0 );    \n\n    ret += DownTheFlagpole( time - 38.95 );    \n    \n    return ret;\n}\n\nvec2 mainSound( float time )\n{    \n    float ret = 0.0;\n    \n    float overworldTime  = max( time -  1.0, 0.0 );\n    float levelClearTime = max( time - 40.2, 0.0 );\n\n    ret += OverworldMelody( overworldTime ) \t* 0.3;\n    ret += OverworldHarmony( overworldTime ) \t* 0.2;\n    ret += OverworldBass( overworldTime )   \t* 0.2;\n    ret += OverworldDrums( overworldTime )\t\t* 0.15;  \n    \n    // overworld theme fadout before the castle\n    ret *= 1.0 - smoothstep( 38.0, 40.0, time );\n    \n    ret += LevelClearMelody( levelClearTime ) \t* 0.3;\n    ret += LevelClearHarmony( levelClearTime ) \t* 0.3;\n    ret += LevelClearBass( levelClearTime ) \t* 0.3;\n    \n    ret += GameSounds( time )\t\t\t\t\t* 0.2;\n    \n    // disable output on first frames\n    ret = time <= 1.0 ? 0.0 : ret;\n    \n    return vec2( ret, ret );\n}",
        "name": "Sound",
        "description": "",
        "type": "sound"
      }
    ],
    "comments": [
      {
        "text": "loooove it!",
        "date": "1535456684",
        "username": "hk_shao",
        "userpicture": "/img/profile.jpg",
        "id": "MdlBWn",
        "hidden": 0
      },
      {
        "text": "Scary part is when you take a look at size of the code. Impressive",
        "date": "1525371156",
        "username": "akhgary",
        "userpicture": "/img/profile.jpg",
        "id": "XsSyzz",
        "hidden": 0
      },
      {
        "text": "Just AWESOME!!!",
        "date": "1523643314",
        "username": "jpechevarria",
        "userpicture": "/img/profile.jpg",
        "id": "XsfyDS",
        "hidden": 0
      },
      {
        "text": "I take 'shader update' to be the point where the animation resumes after the pause that starts when I press play, \">\", or ALT+Enter  By that measure, adding a blank line in Image after 1425 and pressing play shows the compile time is sometimes <~1s and otherwise ~3s.  Pressing instead ALT+Enter shows the compile time is always <~1s. This is on Windows 7 Chrome.",
        "date": "1518083306",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "XlyXWt",
        "hidden": 0
      },
      {
        "text": "After first load shader will be cached. In order to measure compile time, change something (e.g. add a blank line) and then count the time between pressing play and shader update.",
        "date": "1518060938",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "XtGSWt",
        "hidden": 0
      },
      {
        "text": "Image compile time is <1s here - 3.5GHz quad-core Intel. How can one measure the complete compile time accurately?",
        "date": "1518034458",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "llKSDc",
        "hidden": 0
      },
      {
        "text": "Image compile time is <1s here - 3.5GHz quad-core Intel. How can one measure the complete compile time accurately?",
        "date": "1518034414",
        "username": "chrisjj",
        "userpicture": "/media/users/chrisjj/profile.jpeg",
        "id": "MtKSDc",
        "hidden": 0
      },
      {
        "text": "it took me the entire time to realize that I wasn't controlling the jumps by clicking.",
        "date": "1488744584",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "Ms3XDs",
        "hidden": 0
      },
      {
        "text": "It won't be pixel perfect unless you implement Mario's gravity system: on falling slope gravity is 3 times higher - lack of it is immediately visible.",
        "date": "1481823921",
        "username": "metalim",
        "userpicture": "/media/users/metalim/profile.jpeg",
        "id": "MsGGWd",
        "hidden": 0
      },
      {
        "text": "Oooh man ! :-)\n\nI thought all competitors were already showing their work, but you're right, there might be a dozen secret projects currently out of the radar :-)",
        "date": "1469127370",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Xdt3RM",
        "hidden": 0
      },
      {
        "text": "I didn't add tag \"game\", because IMHO this tag is more suited for real interactive games (with multi-pass). \n\nI spend a lot of time making this shader (~100-150h), as it was my first Shadertoy and I had to learn a lot of stuff and I wanted to make everything pixel perfect to the original Mario. Music and sound part was very hard to make and took a lot of time, as I didn't know anything about that and have no talent for music. But, hey! I'm a seasoned game developer with countless crunches under my belt and this thing was quite fun to make.\n\nYes, it's not far from a game and it would be fairy easy to make a nice [SH16C] entry from it, but that would be too easy. So I'm cooking something more crazy for the [SH16C] :).",
        "date": "1469122444",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "XddGRM",
        "hidden": 0
      },
      {
        "text": "I know what you mean. Even with the sprite data automatically produced it's a bit of a nightmare.",
        "date": "1469119983",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Mdc3z7",
        "hidden": 0
      },
      {
        "text": "BTW, I'm curious: how many time one spends to develop such a 48000 chars shader ???",
        "date": "1469119675",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Ms33z7",
        "hidden": 0
      },
      {
        "text": "Oh you're right, I just got a look at several of them and did not noticed. oops.\n\n( but with all the work behind, is there really far to a working game ? the most tedious is the art, I guess you already have some objects engine, etc. )",
        "date": "1469119606",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ls33z7",
        "hidden": 0
      },
      {
        "text": "It's not playable though, so a 'game' tag wouldn't be quite right?",
        "date": "1469119406",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Md33z7",
        "hidden": 0
      },
      {
        "text": "you should add the tag \"game\" ! \n\nNB: several new ones thanks to [SH16C] competition :-) [url]https://www.shadertoy.com/results?query=%5BSH16C%5D[/url]",
        "date": "1469119008",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ld33z7",
        "hidden": 0
      },
      {
        "text": "Hold down the mouse button near the top of the screen to make Mario jump higher at the end flag, once you change line 1315 :-)\n    marioJumpAmplitude\t= iMouse.y * 0.5; // 76.0 * 0.45\n",
        "date": "1463776534",
        "username": "MichaelPohoreski",
        "userpicture": "/media/users/MichaelPohoreski/profile.png",
        "id": "MtBXDW",
        "hidden": 0
      },
      {
        "text": "*kabooooom* ..... Mind. Blown.",
        "date": "1453190938",
        "username": "nenovrak",
        "userpicture": "/media/users/nenovrak/profile.jpeg",
        "id": "4t23zV",
        "hidden": 0
      },
      {
        "text": "Unfortunately, there is no multi-pass for sound, so it's not possible to run SFX at moments defined by user's input. On the other hand, now I can implement proper CRT post processing (with blur etc).",
        "date": "1451979147",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "XtB3Wh",
        "hidden": 0
      },
      {
        "text": "now  (and not no) i would say :)",
        "date": "1451949265",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "Ml23Wz",
        "hidden": 0
      },
      {
        "text": "no with multipass its time to do a real game :)",
        "date": "1451949226",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "ll23Wz",
        "hidden": 0
      },
      {
        "text": "Wow!",
        "date": "1450393371",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "Xl23zW",
        "hidden": 0
      },
      {
        "text": "not playable on sahdertoy, because you must saved state of some vars, but on a dedicated webgl content outside of shadertoy it will be possible indeed",
        "date": "1440117235",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "MsBXDt",
        "hidden": 0
      },
      {
        "text": "Good!",
        "date": "1439910224",
        "username": "lamxung",
        "userpicture": "/img/profile.jpg",
        "id": "Ms2XWc",
        "hidden": 0
      },
      {
        "text": "Thanks! I don't think I can make it playable as Shadertoys are stateless.",
        "date": "1439813791",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "Xd2XWc",
        "hidden": 0
      },
      {
        "text": "wow! could you make this playable somehow?",
        "date": "1439641776",
        "username": "Mourtz",
        "userpicture": "/media/users/Mourtz/profile.jpeg",
        "id": "4d2SW3",
        "hidden": 0
      },
      {
        "text": "wow, now it's complete! 60fps on my slow gpu ... perfect!",
        "date": "1439140985",
        "username": "movAX13h",
        "userpicture": "/media/users/movAX13h/profile.png",
        "id": "4dBXW3",
        "hidden": 0
      },
      {
        "text": "Completely stunning :)\n\nIt sounds like the sound is all an octave too low, though..? Is it just me?",
        "date": "1439127438",
        "username": "RavenWorks",
        "userpicture": "/media/users/RavenWorks/profile.png",
        "id": "4sSSW3",
        "hidden": 0
      },
      {
        "text": "Yes!!!! Love the new flagpoint end!",
        "date": "1438840843",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "ldjXWK",
        "hidden": 0
      },
      {
        "text": "Thanks! I just added did some small tweaks: added flagpoint end, tweaked coin speed, added some flag interaction and a raising castle flag at the end.",
        "date": "1438729835",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "4sjSDV",
        "hidden": 0
      },
      {
        "text": "!!!\nThat is all.",
        "date": "1438669444",
        "username": "NBickford",
        "userpicture": "/img/profile.jpg",
        "id": "4s2XDK",
        "hidden": 0
      },
      {
        "text": "It works perfectly on my Mac now.\nWhat an incredible shader!! Congratulations.",
        "date": "1438499082",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "4sjSWK",
        "hidden": 0
      },
      {
        "text": "Wow! this is awesome! ^^",
        "date": "1438472236",
        "username": "revers",
        "userpicture": "/media/users/revers/profile.gif",
        "id": "ldBXDV",
        "hidden": 0
      },
      {
        "text": "OMG this is so crazy! 37128 chars!\nGood job! The shadertoy competition will be really interesting!",
        "date": "1438444204",
        "username": "vgs",
        "userpicture": "/media/users/vgs/profile.jpeg",
        "id": "MdSSDV",
        "hidden": 0
      },
      {
        "text": "this is completely insane and awesome!!!",
        "date": "1438406367",
        "username": "DelvarWorld",
        "userpicture": "/img/profile.jpg",
        "id": "MdSSWV",
        "hidden": 0
      },
      {
        "text": "I've optimized compilation times. Initial version was compiling ~10s on my PC and now it's down to 3s. I don't think I can optimize significantly more without obfuscating code by expanding all conditions using an offline pre-processing step.",
        "date": "1438386439",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "MdBSDK",
        "hidden": 0
      },
      {
        "text": "took ages to load/compile but well worth the wait :D",
        "date": "1438374244",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "XsBSDV",
        "hidden": 0
      },
      {
        "text": "It's a great work!\namazing!\n\n(my browsers crashed if i open the shadertoy website,\nbut Open alone is ok!)",
        "date": "1438287551",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "ld2XWy",
        "hidden": 0
      },
      {
        "text": "@GregRostami Which GPU does this Macbook Pro have?\n@aiekick Yes there should be some interaction. It's a popular demand, so maybe I'll add it later.\n@coyote Thanks! Sadly I don't have access to any Mac, so I couldn't test on it. I added this fix of yours. I'm also working on compilation time improvements. It would make my life easier if Shadertoy could display compilation time somewhere. Now I have to profile using a stopwatch :).",
        "date": "1438281257",
        "username": "knarkowicz",
        "userpicture": "/media/users/knarkowicz/profile.jpeg",
        "id": "lsjXWy",
        "hidden": 0
      },
      {
        "text": "Now, that's a lot of work! :love: it!",
        "date": "1438279661",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Ms2SWy",
        "hidden": 0
      },
      {
        "text": "Wow, amazing! :)",
        "date": "1438267414",
        "username": "4rknova",
        "userpicture": "/media/users/4rknova/profile.png",
        "id": "ldjXDG",
        "hidden": 0
      },
      {
        "text": "it totally hang my linux/chrome browser and almost even the whole window manager, as soon as the iconic view: it makes shadertoy home page a dangerous trap. solve urgently !  :-(",
        "date": "1438263472",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MsjSDG",
        "hidden": 0
      },
      {
        "text": "Excellent!!! :love:\nJust one small thing... Initialise \"float ret=0.;\" in sound program. Otherwise sound is corrupted on mac.\nBtw, works on mac mini with iris and chrome in 60 fps with sound.\nSafari is very slow, about 3 fps, until I click on the close at the sound tab. Sound tab doesn't disappear, but the image shader is working in 60 fps then. (Although, I must admit, sound is not working in any shader in Safari on my computer. Don't know why...)\nBtw, compiling of your shader takes about 15 seconds for me. Among the longest of any shader I've tried here! It seems that I'll have to deactivate live previews again... :(",
        "date": "1438258360",
        "username": "coyote",
        "userpicture": "/img/profile.jpg",
        "id": "Md2XWG",
        "hidden": 0
      },
      {
        "text": "but nice :)",
        "date": "1438252165",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "MdjXWG",
        "hidden": 0
      },
      {
        "text": "at the end there is no interact betweend the flag and mario ? it was not in the orginal ?",
        "date": "1438251971",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "ldjXWG",
        "hidden": 0
      },
      {
        "text": "That's insane. The only way to top that is to ray march it. :P",
        "date": "1438234660",
        "username": "otaviogood",
        "userpicture": "/media/users/otaviogood/profile.jpeg",
        "id": "4sjXDy",
        "hidden": 0
      },
      {
        "text": "It crashes my browser. Macbook Pro, crashes on both Chrome and Safari.",
        "date": "1438222235",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "4djXDy",
        "hidden": 0
      },
      {
        "text": "Very, very nice!",
        "date": "1438213128",
        "username": "strikemedown1981",
        "userpicture": "/img/profile.jpg",
        "id": "XdjXDy",
        "hidden": 0
      },
      {
        "text": "Pretty amazing!",
        "date": "1438212896",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4s2SDy",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ld3Gz2",
      "date": "1450918438",
      "viewed": 97735,
      "name": "Snail",
      "username": "iq",
      "description": "Procedural modeling and procedural lighting. Shading is a mix of procedural and textures. Raymarched. You'll need a fast machine for this one.",
      "likes": 441,
      "published": 3,
      "flags": 0,
      "tags": [
        "procedural",
        "3d",
        "raymarching",
        "distancefield"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "XsX3Rn",
            "filepath": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
            "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
            "type": "texture",
            "channel": 2,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "Xsf3zn",
            "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "type": "texture",
            "channel": 3,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sf3Rr",
            "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
            "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// antialiasing - make AA 2, meaning 4x AA, if you have a fast machine\n#define AA 1\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 udSegment( vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec3 smax( vec3 a, vec3 b, float k )\n{\n\tvec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n//---------------------------------------------------------------------------\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(n+vec3(0.0,13.1,31.3))*158.5453123);\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//---------------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\nconst float pi = 3.1415927;\n\n//---------------------------------------------------------------------------\n\nfloat mapShell( in vec3 p, out vec4 matInfo ) \n{\n    \n    const float sc = 1.0/1.0;\n    p -= vec3(0.05,0.12,-0.09);    \n\n    p *= sc;\n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    float n = (log(r)/b - t)/(2.0*pi);\n\n    const float th = 0.11;\n    float nm = (log(th)/b-t)/(2.0*pi);\n\n    n = min(n,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + 2.0*pi*ni));\n    float r2 = r1 * 3.019863;\n    \n    //-------\n\n    float h1 = q.z + 1.5*r1 - 0.5;\n    float d1 = sqrt( (r1-r)*(r1-r) + h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5;\n    float d2 = sqrt( (r2-r)*(r2-r) + h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n\n\n    float di = textureLod( iChannel2, vec2(t+r,0.5), 0. ).x;\n    d += 0.002*di;\n    \n    matInfo = vec4(dx,dy,r/0.4,t/3.14159);\n\n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d/sc;\n}\n\nvec2 mapSnail( vec3 p, out vec4 matInfo )\n{\n    vec3 head = vec3(-0.76,0.6,-0.3);\n    \n    vec3 q = p - head;\n\n    // body\n#if 1\n    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.1,0.0), head+vec3(0.04,0.01,0.0), p );\n    float d1 = b1.x;\n    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));\n    b1 = sdBezier( vec3(-0.085,0.0,0.0), vec3(-0.1,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );\n    float d2 = b1.x;\n    d2 -= 0.1 - 0.06*b1.y;\n    d1 = smin( d1, d2, 0.03 );\n    matInfo.xyz = b1.yzw;\n#else\n    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.11,0.0), head+vec3(0.05,0.01-0.02,0.0), p );\n    float d1 = b1.x;\n    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.75*0.07*smoothstep(0.5,1.0,b1.y));\n    matInfo.xyz = b1.yzw;\n    float d2;\n#endif\n    d2 = sdSphere( q, vec4(0.0,-0.06,0.0,0.085) );\n    d1 = smin( d1, d2, 0.03 );\n    \n    d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );\n    \n    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;\n\n    vec3 sq = vec3( q.xy, abs(q.z) );\n    \n    // top antenas\n    vec3 af = 0.05*sin(0.5*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );\n    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );\n    float d3 = b2.x;\n    d3 -= 0.03 - 0.025*b2.y;\n    d1 = smin( d1, d3, 0.04 );\n    d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.016) + vec4(af,0.0) );\n    d1 = smin( d1, d3, 0.01 );    \n    \n    // bottom antenas\n    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );\n    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.2,0.18)+bf );\n    d3 = b3.x;\n    d3 -= 0.025 - 0.02*b3.y;\n    d1 = smin( d1, d3, 0.06 );\n    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );\n    d1 = smin( d1, d3, 0.02 );\n    \n    // bottom\n    vec3 pp = p-vec3(-0.17,0.15,0.0);\n    float co = 0.988771078;\n    float si = 0.149438132;\n    pp.xy = mat2(co,-si,si,co)*pp.xy;\n    d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );\n    d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );\n    \n    // disp\n    float dis = textureLod( iChannel1, 5.0*p.xy, 0. ).x;\n    float dx = 0.5 + 0.5*(1.0-smoothstep(0.5,1.0,b1.y));\n    d1 -= 0.005*dis*dx*0.5;\n        \n    return vec2(d1,1.0);\n}\n    \nfloat mapDrop( in vec3 p )\n{\n    p -= vec3(-0.26,0.25,-0.02);\n    p.x -= 2.5*p.y*p.y;\n    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );\n}\n\nfloat mapLeaf( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    \n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n \n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    \n    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);// + 1.0*sin(5.0*p.x)*sin(5.0*p.z);\n    float rr = sin( ph );\n    rr = rr*rr;    \n    rr = rr*rr;    \n    p.y += 0.005*rr;\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;\n    \n    rr = sin( ph*2.0 );\n    rr = rr*rr;    \n    rr *= 0.5+0.5*sin( p.x*12.0 );\n\n    float ri = 0.035*rr;\n    \n    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );\n\n    float d2 = p.y-0.02;\n    d = smax( d, -d2, 0.02 );\n    \n    return d;\n}\n\nvec2 mapOpaque( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n   \t//--------------\n    vec2 res = mapSnail( p, matInfo );\n    \n    //---------------\n    vec4 tmpMatInfo;\n    float d4 = mapShell( p, tmpMatInfo );    \n    if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }\n\n    //---------------\n    \n    // plant\n    vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );\n    d4 = b3.x;\n    d4 -= 0.04 - 0.02*b3.y;\n    if( d4<res.x  ) { res = vec2(d4,3.0); }\n\t\n\t//----------------------------\n    \n    float d5 = mapLeaf( p );\n    if( d5<res.x ) res = vec2(d5,4.0);\n        \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalOpaque( in vec3 pos, in float eps )\n{\n    vec4 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapOpaque( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapOpaque( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapOpaque( pos + e.xxx, kk ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapOpaque(pos+eps*e,kk).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n//=========================================================================\n\nfloat mapLeafWaterDrops( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    vec3 s = p;\n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n  \n    vec3 q = p;\n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    //---------------\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = r*(1.0-r)*(1.0-r)*6.0;\n    float d0 = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r) );\n    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );\n    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );\n    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );\n    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );\n\n    d3 = max( d3, p.y-0.01);\n    \n    return min( min(d1,d4), min(d2,d3) );\n}\n\nvec2 mapTransparent( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    float d5 = mapDrop( p );\n    vec2  res = vec2(d5,4.0);\n\n    float d6 = mapLeafWaterDrops( p );\n    res.x = min( res.x, d6 );\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalTransparent( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapTransparent( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapTransparent( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapTransparent( pos + e.xxx, kk ).x );\n}\n\n//=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash1(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.1;\n        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\nfloat calcSSS( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.002 + 0.11*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        occ += (h-mapOpaque(pos-h*dir, kk).x);\n    }\n    occ = clamp( 1.0 - 11.0*occ/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec4 kk;    \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = mapOpaque(ro + rd*t, kk ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nconst vec3 sunDir = normalize( vec3(0.2,0.1,0.02) );\n\nvec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )\n{\n    float eps = 0.002;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalOpaque( pos, eps );\n\n    vec3 mateD = vec3(0.0);\n    vec3 mateS = vec3(0.0);\n    vec2 mateK = vec2(0.0);\n    vec3 mateE = vec3(0.0);\n\n    float focc = 1.0;\n    float fsha = 1.0;\n\n    if( m<1.5 ) // snail body\n    {\n        float dis = texture( iChannel1, 5.0*pos.xy ).x;\n\n        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );\n        be = 1.0-smoothstep( -0.01, 0.01, be );        \n        \n        float ff = abs(matInfo.x-0.20);\n        \n        mateS = 6.0*mix( 0.7*vec3(2.0,1.2,0.2), vec3(2.5,1.8,0.9), ff );\n        mateS += 2.0*dis;\n        mateS *= 1.5;\n        mateS *= 1.0 + 0.5*ff*ff;\n        mateS *= 1.0-0.5*be;\n        \n        mateD = vec3(1.0,0.8,0.4);\n        mateD *= dis;\n        mateD *= 0.015;\n        mateD += vec3(0.8,0.4,0.3)*0.15*be;\n        \n        mateK = vec2( 60.0, 0.7 + 2.0*dis );\n        \n        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );\n        f = 1.0-pow( f, 8.0 );\n        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);\n        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);\n        \n        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));\n        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );\n    }\n\telse if( m<2.5 ) // shell\n    {\n        mateK = vec2(0.0);\n        \n        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );\n        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );\n        \n        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );\n        \n        vec3 ral = texture( iChannel1, vec2(2.0*matInfo.w+matInfo.z*0.5,0.5) ).xxx;\n        mateD *= 0.25 + 0.75*ral;\n        \n        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );\n        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));\n        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );\n        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;\n        \n        mateK = vec2( 64.0, 0.2 );\n        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;\n    }\n    else if( m<3.5 ) // plant\n    {\n        mateD = vec3(0.05,0.1,0.0)*0.2;\n        mateS = vec3(0.1,0.2,0.02)*25.0;\n        mateK = vec2(5.0,1.0);\n        \n        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n        mateD += 0.2*fre*vec3(1.0,0.5,0.1);\n        \n        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;\n        mateS *= 0.5 + 1.5*te;\n        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);\n    }\n    else //if( m<4.5 ) // leave\n    {\n        vec3 p = pos - vec3(-1.8,0.6,-0.75);\n        vec3 s = p;\n        p = mat3(0.671212, 0.366685, -0.644218,\n                -0.479426, 0.877583,  0.000000,\n                 0.565354, 0.308854,  0.764842)*p;\n\n        vec3 q = p;\n        p.y += 0.2*exp(-abs(2.0*p.z) );\n\n        float v = smoothstep( 0.01, 0.02, abs(p.z));\n        \n        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );\n\n        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;\n\n        float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n        r = r*(1.0-r)*(1.0-r)*6.0;\n        float ff = length(p.xz/vec2(2.0,r));\n\n        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );\n        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );\n        mateD *= 1.0 + 0.25*te;\n        mateD *= 0.8;\n        \n        mateS = vec3(0.15,0.2,0.02)*0.8;\n        mateS *= 1.0 + 0.2*rr;\n        mateS *= 0.8;\n\n        mateK = vec2(64.0,0.25);\n        \n        //---------------------\n        \n        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);\n        nor = normalize( nor );\n\n        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );\n        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );\n        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );\n        float dd = min(d1,min(d2,d4));\n        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);\n        \n        d1 = abs( sdCircle( q.xz, vec2( 0.5, 0.20), 1.0*0.15 ));\n        d2 = abs( sdCircle( q.xz, vec2( 0.8,-0.15), 0.5*0.15 ));\n        d4 = abs( sdCircle( q.xz, vec2(-0.5,-0.20), 1.0*0.04 ));\n        dd = min(d1,min(d2,d4));\n        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);\n        \n        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );\n        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );\n        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;\n        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    \n    }\n    \n  \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n    float sss = calcSSS( pos, nor );\n    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;\n    \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float sha = calcSoftShadow( pos, sunDir, 20.0 ); \n    dif1 *= sha*fsha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    // illumination\n    \n    vec3 col = vec3(0.0);\n    col += 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;           // sun\n    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);    // sky\n    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;                // bounce\n\n    col *= mateD;\n\n    col += 0.4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS; // sss\n    col = pow(col,vec3(0.6,0.8,1.0));\n    \n    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;   // sun lobe1\n    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y; // sun lobe2\n\tcol += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0)); // sky\n\n    col += mateE;\n\n    return col;        \n}\n\nvec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )\n{\n    vec3 oriCol = col;\n    \n    float dz = depth - t;\n    float ao = clamp(dz*50.0,0.0,1.0);\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormalTransparent( pos, 0.002 );\n    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    vec3  ref = reflect( -rd, nor );\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );\n\n\n    float ds = 1.6 - col.y;\n    \n    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );\n\n    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );\n    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);\n    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    \n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );\n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );\n    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,texture( iChannel1, 0.8*nor.xy ).x)*(0.1+0.9*fre*fre);\n    \n    // hide aliasing a bit\n    return mix( col, oriCol, smoothstep(0.6,1.0,fre) ); \n}\n\n//--------------------------------------------\n\nvec2 intersectOpaque( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapOpaque( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x*0.9;\n    }\n\treturn res;\n}\n\nvec2 intersectTransparent( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTransparent( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x;\n    }\n\treturn res;\n}\n\nvec3 background( in vec3 d )\n{\n    // cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                                     d.xy/d.z;\n    \n    // fancy blur\n    vec3  col = vec3( 0.0 );\n    for( int i=ZERO; i<200; i++ )\n    {\n        float h = float(i)/200.0;\n        float an = 31.0*6.2831*h;\n        vec2  of = vec2( cos(an), sin(an) ) * h;\n\n        vec3 tmp = texture( iChannel2, uv*0.25 + 0.0075*of, 4.0 ).yxz;\n        col = smax( col, tmp, 0.5 );\n    }\n    \n    return pow(col,vec3(3.5,3.0,6.0))*0.2;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 q )\n{\n    //-----------------------------\n\n    vec3 col = background( rd );\n    \n    //-----------------------------\n    \n    float mindist = 1.0;\n    float maxdist = 4.0;\n\n    vec4 matInfo;\n    vec2 tm = intersectOpaque( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeOpaque( ro, rd, tm.x, tm.y, matInfo );\n        maxdist = tm.x;\n    }\n\n    //-----------------------------\n    \n    tm = intersectTransparent( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeTransparent( ro, rd, tm.x, tm.y, matInfo, col, maxdist );\n    }\n\n    //-----------------------------\n    \n    float sun = clamp(dot(rd,sunDir),0.0,1.0);\n    col += 1.0*vec3(1.5,0.8,0.7)*pow(sun,4.0);\n\n    //-----------------------------\n\n    col = pow( col, vec3(0.45) );\n    \n    col = vec3(1.05,1.0,1.0)*col*(0.7+0.3*col*max(3.0-2.0*col,0.0)) + vec3(0.0,0.0,0.04);\n\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    return clamp( col, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt )\n{\n    vec3 w = normalize(ro-rt);\n    \n    float m = sqrt(1.0-w.y*w.y);\n    \n    return mat3( w.z,     0.0, -w.x, \n                 0.0,     m*m, -w.z*w.y,\n                 w.x*m, w.y*m,  w.z*m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    #if AA<2\n    \n        vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n        vec2  q = fragCoord.xy/iResolution.xy;\n        float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n        vec3  ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n        vec3  ta = vec3(-0.6,0.2,0.0);\n        mat3  ca = setCamera( ro, ta );\n        vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n        vec3 col = render( ro, rd, q );\n    \n    #else\n\n        vec3 col = vec3(0.0);\n        for( int m=ZERO; m<AA; m++ )\n        for( int n=ZERO; n<AA; n++ )\n        {\n            vec2 rr = vec2( float(m), float(n) ) / float(AA);\n\n            vec2 p = (-iResolution.xy+2.0*(fragCoord.xy+rr))/iResolution.y;\n            float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n            vec2 q = (fragCoord.xy+rr)/iResolution.xy;\n\n            vec3 ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n            vec3 ta = vec3(-0.6,0.2,0.0);\n            mat3 ca = setCamera( ro, ta );\n            vec3 rd = normalize( ca * vec3(p,-2.8) );\n\n\t\t    col += render( ro, rd, q );\n        }    \n        col /= float(AA*AA);\n    #endif\n                \n\n    fragColor = vec4( col, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Nice! Runs very smoothly on my laptop now!",
        "date": "1557378607",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "MtScDm",
        "hidden": 0
      },
      {
        "text": "I fixed the color underflow in the antennas and neck, and simplified/optimized some code.",
        "date": "1557377981",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MlByDm",
        "hidden": 0
      },
      {
        "text": "Love everything here!\nThe sub-surface-scattering, the material system, bezier curve based objects and the animated snail antennae! <3",
        "date": "1544008840",
        "username": "nylki",
        "userpicture": "/img/profile.jpg",
        "id": "XdSBDW",
        "hidden": 0
      },
      {
        "text": "unbelievable!!!\n",
        "date": "1542185137",
        "username": "zhimo",
        "userpicture": "/img/profile.jpg",
        "id": "XsjBRW",
        "hidden": 0
      },
      {
        "text": "wonderful",
        "date": "1540545755",
        "username": "zhaishengfu",
        "userpicture": "/img/profile.jpg",
        "id": "MslfDX",
        "hidden": 0
      },
      {
        "text": "Follow the tutorials for your shader load plugin...",
        "date": "1540348903",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "XsXfDX",
        "hidden": 0
      },
      {
        "text": "hi iam new beginner in shader toy i want know how can use this code in resolume arena 6 .plse someone can help me\n ",
        "date": "1540331553",
        "username": "momsul",
        "userpicture": "/img/profile.jpg",
        "id": "4dffWX",
        "hidden": 0
      },
      {
        "text": "Featured in this video :) ! [video]http://youtu.be/7BB8TkY4Aeg[/video]",
        "date": "1532120815",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "Md2cDV",
        "hidden": 0
      },
      {
        "text": "How do you add your own texture resources",
        "date": "1530525029",
        "username": "Waylon_J",
        "userpicture": "/media/users/Waylon_J/profile.jpeg",
        "id": "Ms2yz3",
        "hidden": 0
      },
      {
        "text": "god like",
        "date": "1525548495",
        "username": "akhgary",
        "userpicture": "/img/profile.jpg",
        "id": "4d2yzR",
        "hidden": 0
      },
      {
        "text": "Epic!",
        "date": "1514782166",
        "username": "rhgrafix",
        "userpicture": "/media/users/rhgrafix/profile.png",
        "id": "ltKXWw",
        "hidden": 0
      },
      {
        "text": "This shader is one of my favourites from I\u00f1igo, it looks so realitic and beautiful... I'm amazed :)",
        "date": "1511019670",
        "username": "eclectic",
        "userpicture": "/img/profile.jpg",
        "id": "4tdSDB",
        "hidden": 0
      },
      {
        "text": "I see a trend here. therefore have [url=http://ollj.turboherz.de/commence-your-pathetic-witch-hunting]a longer response[/url]. sorry, this got too long. Just to put this in nice spin, consider yourself today's lucky 10000 on, lets call it; [critical hypocrisy].",
        "date": "1510937964",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "ll3SWB",
        "hidden": 0
      },
      {
        "text": "@Ollj!\nHow come you can be rude enough and say things like:\n\n-\"there are a few \"this appears like it was coded drunk\" segments in this shader.\";\n\nThe same goes for my shaders. It\u00b4s insulting and stupid. I think you should show some respect and use a better vocabular.\nThis is a great shader, no matter what you trying to say.",
        "date": "1510932635",
        "username": "ingagard",
        "userpicture": "/img/profile.jpg",
        "id": "MtcXDS",
        "hidden": 0
      },
      {
        "text": "something like \n1.-smoothstep(a,b,c)=smoothstep(b,a,1.-c) is an almost-identity, right ?",
        "date": "1510046182",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "MlcSz2",
        "hidden": 0
      },
      {
        "text": "there are a few \"this appears like it was coded drunk\" segments in this shader.\nlike, [4.0*0.25*], twice.\nand a lot of [1.0-.smoothstep( ] is usually easily optimized by changing the sign of he last parameter and swapping first with second parameter. or something like this. it replaces one subtraction with a negation.",
        "date": "1510046009",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "llcSz2",
        "hidden": 0
      },
      {
        "text": "you only use getClosest() once, and with repeating differentials of input parameters.\nA [url=https://www.shadertoy.com/view/Xt2yDG]specialized variant of getClosest()[/url] has a lot of differentials cancel each other out, making it faster.\n",
        "date": "1510003846",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "ll3SR2",
        "hidden": 0
      },
      {
        "text": "@Lucky4Luuk\n\nSorry to have upset you. I went ahead and made my own version of this where I can spam all I want:\nhttps://www.geometricalgorithm.com/edit?algorithm=IQ_Is_The_Man&",
        "date": "1506491701",
        "username": "voz",
        "userpicture": "/img/profile.jpg",
        "id": "4ly3W3",
        "hidden": 0
      },
      {
        "text": "@vox Please don't spam that everywhere.",
        "date": "1505556574",
        "username": "Lucky4Luuk",
        "userpicture": "/img/profile.jpg",
        "id": "XlGGRd",
        "hidden": 0
      },
      {
        "text": "hu this used to kill my machine, now it runs at 30-40 fps nice!",
        "date": "1489860308",
        "username": "Dain",
        "userpicture": "/img/profile.jpg",
        "id": "ldKXzh",
        "hidden": 0
      },
      {
        "text": "i'm in love with this shader, it's awesome",
        "date": "1482015195",
        "username": "sawass",
        "userpicture": "/media/users/sawass/profile.png",
        "id": "MdVGWt",
        "hidden": 0
      },
      {
        "text": "Ninja!",
        "date": "1481111742",
        "username": "Flavio",
        "userpicture": "/media/users/Flavio/profile.jpeg",
        "id": "XsyGWc",
        "hidden": 0
      },
      {
        "text": "great work, shame the machine to run it doesn't exist yet ;-) Threw this bad boy at a GTX1080 full-screen with AA = 2, got about 5 fps. One day... ",
        "date": "1478681659",
        "username": "russ",
        "userpicture": "/img/profile.jpg",
        "id": "MdKGRG",
        "hidden": 0
      },
      {
        "text": "but i wanted a pony!",
        "date": "1467986022",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "XddGRn",
        "hidden": 0
      },
      {
        "text": "it's truely a crazy work... oO",
        "date": "1467659417",
        "username": "dello32",
        "userpicture": "/img/profile.jpg",
        "id": "4tjXD3",
        "hidden": 0
      },
      {
        "text": "there is a time lapse \"making of\" youtube video of this, not much of a making of but it shows the construction an union of the elements.",
        "date": "1466758728",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "MtBSDy",
        "hidden": 0
      },
      {
        "text": "great image and i finally can see it on a fast enough fragmentshader in realtime. would benefit a lot from any border-smoothening function. ootherwise the borders of any object break the illusion.",
        "date": "1460984237",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "ltSSRR",
        "hidden": 0
      },
      {
        "text": "I agree with haxiomic and velocity, it would be wonderful to see this as a live coding session.",
        "date": "1460593829",
        "username": "huttarl",
        "userpicture": "/media/users/huttarl/profile.jpeg",
        "id": "XtXXDs",
        "hidden": 0
      },
      {
        "text": "Great Master",
        "date": "1454417643",
        "username": "YamSquirrel",
        "userpicture": "/img/profile.jpg",
        "id": "llj3DK",
        "hidden": 0
      },
      {
        "text": "hum... Sorry to make this remark but actually the shell is reversed !    :octopusballoon:\n\nI suggest :    p.x *= -1.;   line 771 !",
        "date": "1454416720",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "Mtj3DK",
        "hidden": 0
      },
      {
        "text": "Superbe !",
        "date": "1453896168",
        "username": "Unix",
        "userpicture": "/img/profile.jpg",
        "id": "ltj3zt",
        "hidden": 0
      },
      {
        "text": "You are a legend.",
        "date": "1451875976",
        "username": "lowww",
        "userpicture": "/media/users/lowww/profile.png",
        "id": "XljGDz",
        "hidden": 0
      },
      {
        "text": "jawdroppin' :O",
        "date": "1451300035",
        "username": "Rackdoll",
        "userpicture": "/media/users/Rackdoll/profile.png",
        "id": "XlB3WR",
        "hidden": 0
      },
      {
        "text": "That is insane. Looks beautiful.\nI'd love to see the progression of the code like @haxiomic suggested, maybe next time use Github?",
        "date": "1451245834",
        "username": "Vel0city",
        "userpicture": "/media/users/Vel0city/profile.jpeg",
        "id": "lt23zm",
        "hidden": 0
      },
      {
        "text": ":love:",
        "date": "1451223069",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "Ml23Rm",
        "hidden": 0
      },
      {
        "text": "@iq This is unbelievably good work! Thanks for the making of video, is there someway we can see the progression of the code?",
        "date": "1451178844",
        "username": "haxiomic",
        "userpicture": "/img/profile.jpg",
        "id": "MtjGRm",
        "hidden": 0
      },
      {
        "text": "Epic!",
        "date": "1451139865",
        "username": "vgs",
        "userpicture": "/media/users/vgs/profile.jpeg",
        "id": "lt23zw",
        "hidden": 0
      },
      {
        "text": "I saved more than a dozen intermediate steps, so I could easily create a breakdown of the process as I improvised my way to the final image:\r\n\r\n[video]https://www.youtube.com/watch?v=XuSnLbB1j6E&loop=1&playlist=XuSnLbB1j6E[/video]",
        "date": "1451099198",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ltjGzw",
        "hidden": 0
      },
      {
        "text": "@drift : hahaha...Game? Do you know \"ShaderToy Engine\"?\nThe game made by it...\nIt should include these:\n    1.model system\n    2.render system\n    3.UI system\n    4.physics system\n    5.logic system\n    6.procedural texture system\nIf you can create the Engine,the game just begin.:D",
        "date": "1451099188",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "MtjGzw",
        "hidden": 0
      },
      {
        "text": "Incredible!",
        "date": "1451072764",
        "username": "knighty",
        "userpicture": "/img/profile.jpg",
        "id": "llj3Rw",
        "hidden": 0
      },
      {
        "text": "Runs ~5fps on iPhone 6s, marvellous job!",
        "date": "1451071214",
        "username": "kakka",
        "userpicture": "/img/profile.jpg",
        "id": "Mtj3Rw",
        "hidden": 0
      },
      {
        "text": "WOW!",
        "date": "1451064154",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "ltj3Rw",
        "hidden": 0
      },
      {
        "text": "Awesome !! Can render at 8 fps on smartphone (adreno 330) but fails on my laptop (i5 HD3000)",
        "date": "1451035250",
        "username": "Atrahasis",
        "userpicture": "/media/users/Atrahasis/profile.png",
        "id": "Xt23zm",
        "hidden": 0
      },
      {
        "text": "Game over, everyone else go home.",
        "date": "1451010410",
        "username": "drift",
        "userpicture": "/img/profile.jpg",
        "id": "4ljGzm",
        "hidden": 0
      },
      {
        "text": "Dave, I didn't use any photo reference. Well, I did a google search for water drops to see what they look like at this scale. I also discovered there's lots of cute snail pictures online at some point, but this image was freestyled, like the rest of my previous shadertoys (except for Arlo and Eve, which I used google images for reference shapes).",
        "date": "1451008603",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XljGzm",
        "hidden": 0
      },
      {
        "text": "Actually works now at 8 FPS. But I really love this.",
        "date": "1450990639",
        "username": "anastadunbar",
        "userpicture": "/media/users/anastadunbar/profile.png",
        "id": "4l23Rm",
        "hidden": 0
      },
      {
        "text": "My computer can't handle the code.",
        "date": "1450990458",
        "username": "anastadunbar",
        "userpicture": "/media/users/anastadunbar/profile.png",
        "id": "Xl23Rm",
        "hidden": 0
      },
      {
        "text": "I absolutely love this. It's amazing, the BSSRDF material alone looks just awesome and then the leaf and caustics created by the water on top of that and so on...",
        "date": "1450989482",
        "username": "Harha",
        "userpicture": "/media/users/Harha/profile.png",
        "id": "4t23Rm",
        "hidden": 0
      },
      {
        "text": "Incredible! Too bad I can only see it on iPhone at 5fps. Not working in Chrome or IE on Win10 with GTX980 (Failed to create D3D shaders)",
        "date": "1450981810",
        "username": "strikemedown1981",
        "userpicture": "/img/profile.jpg",
        "id": "4lj3Rm",
        "hidden": 0
      },
      {
        "text": ":love: it! I thought the thumbnail was photo at first! Hey iq, did you use a photo reference quite a lot with this?",
        "date": "1450979446",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Xlj3Rm",
        "hidden": 0
      },
      {
        "text": "Amazing again!",
        "date": "1450968917",
        "username": "candycat",
        "userpicture": "/media/users/candycat/profile.jpeg",
        "id": "4l2GRm",
        "hidden": 0
      },
      {
        "text": "It doesn't compile on chrome on GTX 690.\nBut screenshot look amazing.",
        "date": "1450966309",
        "username": "lovelyH",
        "userpicture": "/media/users/lovelyH/profile.png",
        "id": "4t2GRm",
        "hidden": 0
      },
      {
        "text": "Dude... wtf... most impressive! I still have a long way to go :)",
        "date": "1450966190",
        "username": "MacSlow",
        "userpicture": "/media/users/MacSlow/profile.jpeg",
        "id": "Xt2GRm",
        "hidden": 0
      },
      {
        "text": "iq=alien :!",
        "date": "1450966018",
        "username": "gigatron",
        "userpicture": "/img/profile.jpg",
        "id": "4ljGRm",
        "hidden": 0
      },
      {
        "text": "Looks awesome. Top hardcoding skills (modeling/lighting/shading). Unfortunately, it's not real-time, at least not on a consumer GPU. Will it ever be 60FPS in HD (not to mention VR)? ;-)",
        "date": "1450963774",
        "username": "tomkh",
        "userpicture": "/media/users/tomkh/profile.jpeg",
        "id": "XljGRm",
        "hidden": 0
      },
      {
        "text": "ha. display driver crashed for intel 3300\nkeep up the awesome work!",
        "date": "1450953853",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "XtjGRm",
        "hidden": 0
      },
      {
        "text": "Whaaaat !!! \nthis is so cool !",
        "date": "1450952400",
        "username": "antonOTI",
        "userpicture": "/media/users/antonOTI/profile.png",
        "id": "4l23zw",
        "hidden": 0
      },
      {
        "text": "Just perfect! :love: :love: :love: :love: :love:",
        "date": "1450952149",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "Xl23zw",
        "hidden": 0
      },
      {
        "text": "Wow !",
        "date": "1450948202",
        "username": "u2Bleank",
        "userpicture": "/media/users/u2Bleank/profile.png",
        "id": "4lj3zw",
        "hidden": 0
      },
      {
        "text": "Perfection! :love:",
        "date": "1450947368",
        "username": "coyote",
        "userpicture": "/img/profile.jpg",
        "id": "4tj3zw",
        "hidden": 0
      },
      {
        "text": "Amazing, I love the subtle detail on the leaf from iChannel3.  This blows my mind.",
        "date": "1450935068",
        "username": "trapzz",
        "userpicture": "/img/profile.jpg",
        "id": "Xl2Gzw",
        "hidden": 0
      },
      {
        "text": "Incredible Quality :D  Totally agree - this is the new leader for realistic shaders.  Inigo sets yet another benchmark for others to strive toward.  :love:",
        "date": "1450933473",
        "username": "AndrewNZ",
        "userpicture": "/media/users/AndrewNZ/profile.jpeg",
        "id": "4t2Gzw",
        "hidden": 0
      },
      {
        "text": "Yes, I just fixed it a few minutes ago",
        "date": "1450931094",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4ljGzw",
        "hidden": 0
      },
      {
        "text": "Absolutely jaw dropping!  Getting an artifact for mapLeaf(p) on a 15\" mac powerbook running Yosemite with a AMD Radeon R9 M370X 2048 MB.  It seems to be fixed with this change on line 291:\n\n    r = max(0.01, r*(1.0-r)*(1.0-r)*6.0);\n",
        "date": "1450930196",
        "username": "mplanck",
        "userpicture": "/media/users/mplanck/profile.png",
        "id": "XljGzw",
        "hidden": 0
      },
      {
        "text": "This is the new best looking shader!",
        "date": "1450925118",
        "username": "otaviogood",
        "userpicture": "/media/users/otaviogood/profile.jpeg",
        "id": "4tjGzw",
        "hidden": 0
      },
      {
        "text": "This is quite possibly the most visually pleasing shader I've ever seen, and it's certainly the most clever usage of minimal resources. :love:",
        "date": "1450923407",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "XtjGzw",
        "hidden": 0
      },
      {
        "text": "Epic!",
        "date": "1450923124",
        "username": "ZigguratVertigo",
        "userpicture": "/media/users/ZigguratVertigo/profile.jpeg",
        "id": "4l23Rw",
        "hidden": 0
      },
      {
        "text": "I can't believe this... Amazing.",
        "date": "1450921059",
        "username": "OneManBand",
        "userpicture": "/img/profile.jpg",
        "id": "Xlj3Rw",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ldd3DX",
      "date": "1542803894",
      "viewed": 22803,
      "name": "Surfer Boy",
      "username": "iq",
      "description": "A surfer boy posing in the beach, in pixar style unapologetically. I had to compromise quality so it would compile in my CPU, and had to model and paint it to camera (rather than full 3D) so I could move fast during the making. I took out the animation.",
      "likes": 136,
      "published": 3,
      "flags": 32,
      "tags": [
        "3d",
        "raymarching",
        "distancefield",
        "sdf"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "Xsf3zn",
            "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [],
        "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// A surfer boy in the beach, disney/pixar style. I had to be very careful\n// with the complexity, otherwise the browser would crash during shader\n// compilation. I also had to split the boy in two layers because of that,\n// see below (the single pass version is smaller of course but takes 3 extra\n// seconds to compile, and renders a bit more slowly)\n//\n// This is totally painted to camera, it won't work from others perspectives.\n//\n// I did an animated version (blinking, eyeball micromovements, breathing, \n// hair and head movement) but it looked super creepy, so I left it out this\n// time. I need to lear to animate before publishing something like that.\n//\n// Common   - contains some basic stuff\n// Buffer A - renders the brackground - not super polished really\n// Buffer B - blurs the background\n// Buffer C - paints the boy, except the hand and the board\n// Image    - paints the hand and the board, and does some minimal postpro\n\n\n\n// hands and board\nvec3 map( vec3 p )\n{\n    // hands\n    float d = 1.0;\n\tif( p.x<-0.8 && p.y<-0.1)\n\t{\n\t\tvec3 hp = p - vec3(-0.9,-0.30,0.12);\n\n\t\thp.z *= 1.2;\n\t\t\n\t\tfloat ss = sign(hp.y+0.05);\n\n\t\tvec4 a1 = vec4(-0.030+0.010*ss, -0.050 +0.050 *ss, 0.06, 0.0225);\n\t\tvec4 b1 = vec4(-0.070+0.010*ss, -0.049 +0.051 *ss, 0.05, 0.024);\n\t\tvec4 c1 = vec4(-0.145+0.015*ss, -0.0465+0.0535*ss, 0.01, 0.027);\n\t\tvec4 d1 = vec4(-0.12,           -0.0465+0.0535*ss,-0.06, 0.030);\n\t\tvec3 u1 = vec3(-0.0290+0.011*ss,-0.05  +0.05  *ss, 0.08);\n\t\tvec3 v1 = vec3(-0.0185,         -0.05  +0.05  *ss, 0.08);\n\n\t\tfloat dd =     sdCapsule( hp, a1, b1 ).x;\n\t\tdd = smin( dd, sdCapsule( hp, b1, c1 ).x, 0.005 );\n\t\tdd = smin( dd, sdCapsule( hp, c1, d1 ).x, 0.005 );\n\t\tdd = smax( dd,-sdCapsule( hp, u1, v1, 0.021 ),0.005);\n\t\td = min( d, dd/1.2 );\n\t\t\n\t\tss = sign(hp.y+0.1);\n\t\t\n\t\tif( hp.y>-0.1 )\n\t\t{\n\t\t\tconst vec4 a2 = vec4(-0.02,-0.050, 0.06, 0.024);\n\t\t\tconst vec4 b2 = vec4(-0.06,-0.050, 0.05, 0.0256);\n\t\t\tconst vec4 c2 = vec4(-0.15,-0.050, 0.01, 0.0288);\n\t\t\tconst vec4 d2 = vec4(-0.13,-0.050,-0.06, 0.032);\n\t\t\tconst vec3 u2 = vec3(-0.018,-0.05,0.08);\n\t\t\tconst vec3 v2 = vec3(-0.017,-0.05,0.08);\n\n\t\t\tdd =           sdCapsule( hp, a2, b2 ).x;\n\t\t\tdd = smin( dd, sdCapsule( hp, b2, c2 ).x, 0.005 );\n\t\t\tdd = smin( dd, sdCapsule( hp, c2, d2 ).x, 0.005 );\n\t\t\tdd = smax( dd,-sdCapsule( hp, u2, v2, 0.021 ),0.005);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst vec4 a2 = vec4(-0.07,-0.145, 0.06, 0.021);\n\t\t\tconst vec4 b2 = vec4(-0.10,-0.145, 0.05, 0.0224);\n\t\t\tconst vec4 c2 = vec4(-0.16,-0.145, 0.01, 0.0252);\n\t\t\tconst vec4 d2 = vec4(-0.15,-0.145,-0.06, 0.028);\n\t\t\tconst vec3 u2 = vec3(-0.07,-0.145,0.08);\n\t\t\tconst vec3 v2 = vec3(-0.05,-0.145,0.08);\n\n\t\t\tdd =           sdCapsule( hp, a2, b2 ).x;\n\t\t\tdd = smin( dd, sdCapsule( hp, b2, c2 ).x, 0.005 );\n\t\t\tdd = smin( dd, sdCapsule( hp, c2, d2 ).x, 0.005 );\n\t\t\tdd = smax( dd,-sdCapsule( hp, u2, v2, 0.019 ),0.005);\n\t\t}\n        d = min( d, dd/1.2 );\n\t}\n    \n\tvec3 res = vec3(d,1.0,1.0);\n\n    // nails\n\t{\n\t\tvec3 np = mat3(0.990,0.0,0.141,\n\t\t\t\t\t   0.000,1.0,0.000,\n\t\t\t\t\t   -0.141,0.0,0.990)*\n\t\t\t\t\t   (p-vec3(-0.9,-0.30,0.12));\n\t\td =       sdEllipsoid(np, vec3(-0.025, 0.000,0.056), vec3(0.022,0.018,0.006) );\n\t\td = min(d,sdEllipsoid(np, vec3(-0.025,-0.050,0.056), vec3(0.023,0.019,0.006) ));\n\t\td = min(d,sdEllipsoid(np, vec3(-0.046,-0.100,0.053), vec3(0.022,0.018,0.006) ));\n\t\td = min(d,sdEllipsoid(np, vec3(-0.073,-0.145,0.048), vec3(0.021,0.017,0.006) ));\n\t\tif( d<res.x ) res = vec3(d,9.0,1.0);\n\t}\n\n\t\n    // board\n\t//if( p.x<-0.2 )\n\t{\n\tvec3 bp = p - vec3(-0.695,-1.5,0.1 );\n\n\tbp.x = 0.15 + almostIdentity( abs(bp.x), 0.05, 0.01 );\n\td = sdEllipsoid( bp, vec3(0.0),vec3(0.65,1.8,0.1) );\n\tif( d<res.x ) res = vec3(d,6.0,1.0);\n\t}\n\t\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalmap( in vec3 pos, in float ep )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*map(pos+e.xyy*ep).x + \n\t\t\t\t\t e.yyx*map(pos+e.yyx*ep).x + \n\t\t\t\t\t e.yxy*map(pos+e.yxy*ep).x + \n\t\t\t\t\t e.xxx*map(pos+e.xxx*ep).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep).x;\n    }\n    return normalize(n);\n#endif    \n    \n}\n\n\n//=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int sampleID )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=ZERO; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i+12*sampleID)));\n\t\t\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08).x*3.0, 0.0, 1.0 );\n        \n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = 0.001;\n\tfor( int i=ZERO; i<50; i++ )\n\t{\n\t\tfloat h = map(ro + rd*t ).x;\n\n\t\tres = min( res, smoothstep(0.0,1.0,1.8*k*(h+0.001)/sqrt(t)) );\n\t\t\n\t\tt += clamp( h, 0.003, 0.1 );\n\t\tif( res<0.001 || t>0.8) break;\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in float matInfo, in int sampleID )\n{\n\tvec3 pos = ro + t*rd;\n\tvec3 nor = calcNormalmap( pos, 0.0002 );\n\t\n\n\tvec3 mateD = vec3(0.0);\n\tvec2 mateK = vec2(0.0);\n\tfloat mateS = 0.0;\n\tvec3 mateSG = vec3(1.0);\n\n\tif( m<1.5 )\n\t{\n\t\tmateD = vec3(0.132,0.06,0.06);\n\t\t\n\t\tvec3 p = pos;\n\t\tfloat no = texture(iChannel0,p.xy).x;\n\t\tmateSG = vec3(0.75,0.97,1.0);\n\t\tmateK = vec2(0.08,0.5);\n\t\tmateS = 1.0;    \n\t\tmateK *= 0.5 + no;\n\t}\n\telse if( m<6.5 )\n\t{\n        mateD = vec3(0.22,0.24,0.26);\n\t\t\n\t\tvec3 bp = pos - vec3(-0.695,-1.6,0.1 );\n\n\t\tmateD = mix( mateD, vec3(0.15,0.08,0.05), 1.0-smoothstep(0.003,0.01,abs(bp.x)) );\n\t\t\n\t\tfloat h = bp.y - 0.15*sin( 6.0*bp.x );\n\t\th = min( abs(h-1.15)-0.04, abs(h-1.05)-0.01 );\n\t\t\n\t\tmateD = mix( mateD, vec3(0.004), 1.0-smoothstep( 0.01, 0.02, h ) );\n\t\t\n\t\tmateD *= 0.9 + 0.1*texture(iChannel0, 1.0*pos.xy ).x;\n\t\tmateS = 3.0;\n\t\tmateK = vec2(1.0,16.0);\n\t\t\n\t\tvec2 uv = pos.xy*0.1;\n\t\tfloat te = 0.0;\n\t\tfloat s = 0.5;\n\t\tfor( int i=0; i<9; i++ )\n\t\t{\n\t\t\tte += s*texture(iChannel0,uv).x;\n\t\t\tuv *= 2.11;\n\t\t\ts *= 0.6;\n\t\t}\n\t\tmateD = mix( mateD, vec3(0.16,0.08,0.0)*0.27, \t\t\t0.15*smoothstep(0.6,0.9,te) );\n\t\tmateK.x *= 1.0-te;\n\t\t\n\t\t\n\t}\n\telse if( m<9.5 )\n\t{\n\t\tmateD = vec3(0.134,0.07,0.07);\n\t\t\n\t\tvec3 hp = pos - vec3(-0.945,-0.30,0.12);\n\t\t\n\t\tfloat r = length(hp.xy);\n\t\tr = min( r, length(hp.xy-vec2(0.0,-0.05)) );\n\t\tr = min( r, length(hp.xy-vec2(-0.02,-0.095)) );\n\t\tr = min( r, length(hp.xy-vec2(-0.048,-0.14)) );\n\t\t\n\t\tmateD += 0.023*(1.0 - smoothstep( 0.014,0.018,r));\n\t\t\n\t\tmateK = vec2(0.2,2.0);\n\t\tmateS = 1.0;\n\t\t\n\t}\n\t\n\tfloat fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n\tfloat occ = calcAO( pos, nor, sampleID );\n\t\n\tvec3 col = vec3(0.0);\n\t\n    {\n\t\t// key\n\t\tfloat dif1 = dot(nor,sunDir);\n\t\tvec3 hal = normalize( sunDir-rd );\n\t\tfloat spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\n\t\tfloat sha = calcSoftShadow( pos+nor*0.0005, sunDir, 24.0 ); \n        \n        sha *= 0.15+0.85*smoothstep(0.1,0.3,length((pos-vec3(-0.45,0.16,0.1))*vec3(1.4,0.4,1.0)));\n        \n\t\tfloat ssha = 1.0;\n\t\tif( abs(m-3.0)<0.2 ) { dif1=0.5*dif1+0.5; sha=0.95*sha+0.05; }\n\t\tif( abs(m-2.0)<0.2 ) { sha=clamp(0.2+sha*dif1*2.0,0.0,1.0); dif1=0.4+0.6*dif1; ssha=0.0; }\n\t\t\n\t\tdif1 = clamp(dif1,0.0,1.0);\n\n\t\tvec3 sha3 = vec3(sha,sha*0.4+0.6*sha*sha,sha*sha);\n\t\t\n\t\tcol += mateD*3.1*vec3(2.5,1.1,0.5)*dif1*sha3;\n\t\tcol += mateK.x*vec3(1.5,1.4,1.3)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0))*ssha;\n    }\n\t{\n\t\t// fill\n\t\t\n\t\tcol += mateD*vec3(0.45,0.75,1.0)*occ*occ*occ*(0.5+0.5*nor.y)*4.5;\n\n\t\tfloat dif1 = 0.5 + 0.5*nor.y;\n\t\tfloat sha = 1.0;\n\t\tfloat spe = smoothstep( -0.15, 0.15, reflect(rd,nor).y );\n\t\tcol += mateK.x*vec3(0.7,0.9,1.0)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0))*occ*occ*3.0;\n\t}\n\t{\n\t\t// bounce\n\t\tvec3 bak = normalize( sunDir*vec3(-1.0,-3.5,-1.0));\n\t\tfloat dif = clamp(0.3+0.7*dot(nor,bak),0.0,1.0);\n\t\tcol += mateD*vec3(1.2,0.8,0.6)*occ*occ*dif*2.5;\n\t}\n\t{\n\t\tcol += mateS*mateD*fre    *vec3(2.0,0.95,0.80)*0.7*occ;\n\t\tcol += mateS*mateD*fre*fre*vec3(1.1,0.80,0.65)*1.2*occ;\n\t}\n\n\tcol = pow( col, mateSG );\n\n    return col;        \n}\n\n//--------------------------------------------\n\nvec3 intersect( in vec3 ro, in vec3 rd, float mindist, float maxdist )\n{\n\tvec3 res = vec3(-1.0);\n\t\n\tfloat t = mindist;\n\tfor( int i=ZERO; i<150; i++ )\n\t{\n\t\tvec3 p = ro + t*rd;\n\t\tvec3 h = map( p );\n\t\tres = vec3(t,h.yz);\n\t\tif( abs(h.x)<0.00025 || t>maxdist ) break;\n\t\tt += h.x;\n\t}\n\treturn res;\n}\n\n///////////////////////////////////////////////\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in int sampleID )\n{\n\tvec4 res = texture(iChannel1,uv);\n\tvec3 col = res.xyz;\n\t\n\tconst float mindist = 0.8;\n\tconst float maxdist = 1.8;\n\t\n\tvec3 tm = intersect( ro, rd, mindist, maxdist );\n\tif( tm.y>-0.5 && tm.x < maxdist )\n\t{\n\t\tcol = shade( ro, rd, tm.x, tm.y, tm.z, sampleID );\n\t}\n\n\tfloat sun = clamp(0.5+0.5*dot( rd, sunDir ),0.0,1.0);\n\tcol += 20.0*vec3(1.2,0.7,0.4)*pow(sun,8.0);\n\n\tcol = pow( col, vec3(0.4545) );\n\n\t//col.z += 0.005;\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n\tmat3 ca; vec3 ro; float fl;\n\tcomputeCamera( iTime, ca, ro, fl );\n\n#if AA<2\n\tvec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3  rd = normalize( ca*vec3(p,-fl) );\n\tvec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, 0 );\n#else\n\tvec3 col = vec3(0.0);\n\tfor( int m=ZERO; m<AA; m++ )\n\tfor( int n=ZERO; n<AA; n++ )\n\t{\n\t\tvec2 rr = vec2( float(m), float(n) ) / float(AA) - 0.5;\n\t\tvec2 p = (2.0*(fragCoord.xy+rr)-iResolution.xy)/iResolution.y;\n\t\tvec3 rd = normalize( ca * vec3(p,-fl) );\n\t\tcol += render( ro, rd, (fragCoord+rr)/iResolution.xy, AA*m+n );\n\t}    \n\tcol /= float(AA*AA);\n#endif\n\t\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tcol *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n\tfragColor = vec4( col, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "Xsf3zn",
            "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat noise( in vec2 p )\n{\n  return -1.0+2.0*textureGood( iChannel0, p-0.5 );\n}\n\nconst float hmin = -6.0;\nconst float hmax = -1.0;\n\nfloat mapWater( in vec3 p )\n{\n    float w = 0.0;\n    float s = 0.5;\n    vec2 q = p.xz;\n    for( int i=0; i<4; i++ )\n    {\n        w += s*noise(q*vec2(0.5,1.0));\n        q = 2.01*(q + vec2(0.03,0.07));\n        s = 0.5*s;\n    }\n    w /= 0.9375;\n    \n    \n    float h = hmin + (hmax-hmin)*w;\n    \n\n    float cr = 0.0;\n    float wh = 0.2 + 0.8*smoothstep( 0.0, 75.0, -p.z );\n    vec2 pp = p.xz/50.0;\n    float d = 1e20;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 o = floor( pp );\n        o += vec2( float(i), float(j) );\n        vec4 ra = texelFetch( iChannel0, ivec2(o)&255, 0 );\n        o += ra.xy;\n        vec3 r = p - vec3(o.x*50.0,-4.0-(1.0-wh)*5.0+ra.z*ra.z*2.0-3.0,o.y*50.0 + mod(10.0*iTime*0.2,50.0));\n        r.yz = mat2(0.99,0.141,-0.141,0.99)*r.yz;\n        d = smin( d, sdEllipsoid( r, vec3(0.0,0.0,0.0), (0.2+0.8*wh)*vec3(35.0,(0.1+0.9*ra.z*ra.z)*3.0,15.0)), 2.10 );\n        \n        float pm = (0.1+0.9*wh)*15.0;\n        float cc = 1.0-smoothstep( 0.0, 2.0, abs(abs(r.z)-pm) );\n        cr = max( cr, cc );\n    }\n    d = d - w*0.5;\n    d = smin( d, p.y+4.0, 1.0);\n    d = d - w*0.03;\n\n    return d;\n}\n\nconst vec3 bnor = normalize(vec3(0.0,0.9,-0.05));\n\nfloat mapBeach( in vec3 p )\n{\n    float d = dot(p,bnor)-2.8;\n    \n    vec2 w = vec2(0.0);\n    vec2 s = vec2(0.5);\n    vec2 t = vec2(0.0);\n\t\n    vec2 q = p.xz*1.25;\n    q += 1.0*cos( 0.3*q.yx );\n    for( int i=0; i<7;i++ )\n    {\n        float n = 0.5 + 0.5*noise(q);\n\t\tw += s*vec2(1.0-almostIdentity(abs(-1.0+2.0*n),0.1,0.05 ),n);\n\t\tt += s;\n        q = mat2(1.6,1.2,-1.2,1.6)*q;\n\t\ts *= vec2(0.3,0.5);\n    }\n\tw /= t;\n\n\tfloat f = w.x + w.y*0.4;\n    \n    float wet = 1.0-smoothstep(-16.0, -10.0, p.z );\n    \n    return d - 0.15*mix(f, (1.0-f)*0.1, wet );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalmapWater( in vec3 pos, in float ep )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*mapWater(pos+e.xyy*ep) + \n\t\t\t\t\t e.yyx*mapWater(pos+e.yyx*ep) + \n\t\t\t\t\t e.yxy*mapWater(pos+e.yxy*ep) + \n\t\t\t\t\t e.xxx*mapWater(pos+e.xxx*ep) );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalmapBeach( in vec3 pos, in float ep )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*mapBeach(pos+e.xyy*ep) + \n\t\t\t\t\t e.yyx*mapBeach(pos+e.yyx*ep) + \n\t\t\t\t\t e.yxy*mapBeach(pos+e.yxy*ep) + \n\t\t\t\t\t e.xxx*mapBeach(pos+e.xxx*ep) );\n}\n\n\nfloat intersectWater( in vec3 ro, in vec3 rd, in float mint )\n{\n    float t = mint;\n    for( int i=0; i<200; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = mapWater( p );\n        if( abs(h)<(0.0004*t) ) break;\n        t += h;\n    }\n\treturn t;\n}\n\nvec3 sky( in vec3 rd )\n{\n    if( rd.y<0.0 ) return vec3(0.0,0.05,0.10);\n    \n    // gradient\n    float dy = max(0.0,rd.y);\n    vec3 col = vec3(0.3,0.7,0.9) - dy*0.5;\n\tcol = mix( col, vec3(1.3,0.45,0.10), exp(-4.0*dy) );\n\tcol = mix( col, vec3(1.5,0.10,0.05), exp(-30.0*dy) );\n\tcol = mix( col, vec3(0.1,0.10,0.10), exp(-60.0*dy) );\n    \n    // clouds\n    vec2 uv = 0.003*rd.xz/rd.y;\n\tuv += 0.006*sin(100.0*uv.yx);\n    float f  = 0.5000*texture( iChannel0, 1.0*uv.xy ).x;\n          f += 0.2500*texture( iChannel0, 1.9*uv.yx ).x;\n          f += 0.1250*texture( iChannel0, 4.1*uv.xy ).x;\n          f += 0.0625*texture( iChannel0, 7.9*uv.yx ).x;\n          \n    return mix( col, vec3(1.0,0.37,0.4)*(1.0-f)*0.5,0.3*smoothstep(0.4,0.7,f) );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n\tvec3 col = vec3(0.0);\n    \n    float ma = -1.0;\n    float tmin = 1e20;\n    \n    float t = (hmax-ro.y)/rd.y;\n    if( t>5.0 )\n    {\n        t = intersectWater( ro, rd, t );\n        ma = 0.0;\n        tmin = t;\n    }\n\n    t = (-2.8-dot(ro,bnor))/dot(rd,bnor);\n    if( t>0.0 && t<tmin)\n    {\n\t\ttmin = t;\n\t\tma = 1.0;\n    }\n\n    if( ma<0.0 )\n    {\n        col = sky( rd );\n    }\n    else if( ma<0.5 )\n    {\n    \tvec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormalmapWater(pos,0.0001*tmin);\n\n        float h = (pos.y - hmin)/(hmax-hmin);\n        float f = exp(-0.01*tmin);\n        col = mix( vec3(0.03,0.1,0.1), vec3(0.02,0.04,0.08), 1.0-f );\n        \n        h = 1.0-abs(nor.y);\n        col += h*vec3(0.00,0.03,0.03)*2.0;\n\n        vec3 ref = reflect( rd, nor );\n        float kr = pow( clamp(1.0 + dot( rd, nor ),0.0,1.0), 5.0 );\n        col += 0.7*(0.01 + 0.99*kr)*sky( ref );\n        \n        \n        float dif = clamp( dot(nor,sunDir),0.0,1.0);\n        col *= 0.8 + 0.4*dif;\n        col *= 0.75;\n        \n        // foam waves\n        float foam = smoothstep( -0.5, 0.1, -nor.y );\n\t\t// foam shore\n\t\tfloat te = texture(iChannel0,0.016*pos.xz + vec2(-0.002,-.007)*iTime).x;\n\t\tfoam += \n\t\tsmoothstep(-24.0,-23.0,pos.z + 0.5*sin(pos.x*0.4+te*2.0))*\n\t\tsmoothstep(0.4,0.5,te)*0.8;\n\t    col = mix( col, vec3(0.8,0.9,1.0), 0.4*foam );\n    \n        // fog\n\t\tcol = mix( col, vec3(0.1), 1.0-exp(-0.000001*tmin*tmin) );\n    }\n\telse if( ma<1.5 )\n    {\n        col = vec3(0.0);\n\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormalmapBeach(pos,0.0002);\n\n\t\tvec3 mateD = vec3(1.0,0.7,0.5)*0.17;\n        vec2 mateK = vec2(1.0,0.5);\n        float mateS = 0.0;\n\n\t\t\n        float fr = pow(clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),2.0);\n\t\tmateD += 0.05*vec3(1.0,0.5,0.2)*fr;\n\n\t\t\n        float wet = 1.0-smoothstep(-17.0, -11.0, pos.z );\n\t\tmateD = mix( mateD, vec3(0.05,0.02,0.0)*0.8, wet );\n        mateK.x += 12.0*wet;\n        mateK.y += 9.0*wet;\n        \n\t\tmateD *= 0.9;\n        \n\t\tfloat dif1 = clamp( -0.1+1.4*dot(nor,sunDir),0.0,1.0);\n        vec3 hal = normalize( sunDir-rd );\n        float spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\t\tcol += mateD*4.0*vec3(2.5,1.0,0.5)*dif1;\n\t\t\tcol += mateK.x*vec3(1.4,1.30,1.3)*dif1*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0));\n\n        col += mateD*vec3(1.0,0.9,0.9)*(0.5+0.5*nor.y)*0.2;\n        col += mateK.x*vec3(0.8,0.8,0.9)*smoothstep( -0.1,0.3,reflect(rd,nor).y) *(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0));\n        \n    }\n    \n    return vec4(col,tmin);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    mat3 ca; vec3 ro; float fl;\n    computeCamera( iTime, ca, ro, fl );\n    \n    vec2  p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3  rd = normalize( ca * vec3(p,-fl) );\n    \n    fragColor = render( ro, rd );\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// antialiasing - make AA 2, meaning 4x AA, if you have a fast machine\n#define AA 1\n\nconst vec3 sunDir = normalize( vec3(1.0,0.5,0.7) );\n\n\nvoid computeCamera( in float time, out mat3 rCam, out vec3 rRo, out float rFl )\n{\n    vec3 ro = vec3(-0.045+0.05*sin(0.12*time),-0.04,1.3);\n\tvec3 ta = vec3(-0.19,-0.08,0.0);\n\tfloat fl = 2.45;\n    \n    vec3 w = normalize(ta-ro);\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    rCam = mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 -w);\n    rRo = ro;\n    rFl = fl;\n}\n\n//------------------------------------------------------\n\n// http://iquilezles.org/www/articles/texture/texture.htm\nfloat textureGood( sampler2D sam, in vec2 x )\n{\n\tivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = texelFetch(sam,(p+ivec2(0,0))&255,0).x;\n\tfloat b = texelFetch(sam,(p+ivec2(1,0))&255,0).x;\n\tfloat c = texelFetch(sam,(p+ivec2(0,1))&255,0).x;\n\tfloat d = texelFetch(sam,(p+ivec2(1,1))&255,0).x;\n\treturn mix(mix( a, b,f.x), mix( c, d,f.x), f.y);\n}\n\n//------------------------------------------------------\n\n// http://iquilezles.org/www/articles/functions/functions.htm\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n//------------------------------------------------------\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n  p = p-c;\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  return length(pa-ba*h) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 sdCapsule( in vec3 p, in vec4 a, in vec4 b )\n{\n  vec3 pa = p-a.xyz, ba = b.xyz-a.xyz;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return vec2( length(pa-ba*h) - mix(a.w,b.w,h), h );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n  return length(p-c)-r;\n}\n\nfloat sdEllipsoidXY2Z( in vec3 p, in vec3 r )\n{\n  vec3 d = p/r;\n  float h = pow(d.x*d.x + abs(d.y*d.y*d.y) + d.z*d.z, 1.0/3.0); \n  return (h-1.0)*min(r.x,min(r.y,r.z));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec2 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2 d21 = b2-b1;\n  vec2 d10 = b1-b0;\n  vec2 d20 = b2-b0;\n  vec2 gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2 pp = -f*gf/dot(gf,gf);\n  vec2 d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec4 sdBezier2( vec3 a, vec3 b, vec3 c, vec3 p, out vec3 resP )\n{\n  vec3 w = normalize( cross( c-b, a-b ) );\n  vec3 u = normalize( c-b );\n  vec3 v =          ( cross( w, u ) );\n\n  vec2 m = vec2( dot(a-b,u), dot(a-b,v) );\n  vec2 n = vec2( dot(c-b,u), dot(c-b,v) );\n  vec3 q = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n  vec3 cp = getClosest( m-q.xy, -q.xy, n-q.xy );\n\n  resP = mix( mix(a,b,cp.z), mix(b,c,cp.z), cp.z );\n\n  return vec4( sqrt(dot(cp.xy,cp.xy)+q.z*q.z), cp.z, length(cp.xy), q.z );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n  vec3 kk;\n  return sdBezier2(a,b,c,p,kk);\n}\n\n// trick by klems\n#define ZERO (min(iFrame,0))\n",
        "name": "Common",
        "description": "",
        "type": "common"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XsXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord/iResolution.xy;\n\n    vec4 acc = vec4(0.0);\n    const int N = 5;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off/vec2(1280.0,720.0) ); \n        if( dot(off,off) < float(N*N) )\n        {\n            acc += vec4(tmp.xyz,1.0);\n        }\n    }\n    vec3 col = acc.xyz / acc.w;\n\n    fragColor = vec4(col,1.0);\n}\n",
        "name": "Buffer B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "Xsf3zn",
            "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4sXGR8",
            "channel": 0
          }
        ],
        "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 corner1 = vec3(-0.088,-0.103,0.084);\nconst vec3 center  = vec3(-0.005,-0.193,0.14);\nconst vec3 corner2 = vec3( 0.098,-0.105,0.08);\n\nvec3 transformHead( in vec3 p )\n{\n  p.x += 0.012;\n  return mat3( 0.986264,-0.097838, -0.133010,\n               0.086792, 0.992467, -0.086465,\n               0.140468, 0.073733,  0.987326)*p;\n}\n\nvec3 transformHat(in vec3 p)\n{\n  p.y -= 0.03;\n  p = mat3( 0.79200, -0.141, 0.59400,\n           -0.26976,  0.792, 0.54768,\n           -0.54768, -0.594, 0.58924)*p;\n  p.y -= 0.1;\n  return p;\n}\n\nvec3 map( vec3 p )\n{\n\tvec3 headp = transformHead( p );\n\tvec3 headq = vec3( abs(headp.x), headp.yz );\n\n    // head\n\tfloat d = sdEllipsoid( headp, vec3(0.0,0.015,-0.06 ),vec3(0.33,0.365,0.34) );\n\td = smax(d,-sdEllipsoid( vec3( almostIdentity( headq.x, 0.03, 0.01 ), headp.yz),  vec3( 0.25,0.06,0.4),vec3(0.4,0.2,0.2) ), 0.015);\n\td = smin(d,sdEllipsoid( headp, vec3(0.0,-0.165,0.13),vec3(0.22,0.15,0.145)), 0.01 );\n\td = smin(d,sdEllipsoid( headp, vec3(0.01,-0.2,0.17),vec3(0.12,0.115,0.105)), 0.01 );\n\td = smin(d,sdEllipsoid( headq, vec3(0.1,-0.103,0.09),vec3(0.175,0.146,0.18) ), 0.02);\n\n    \n    // nose\n\tvec3 n = headp-vec3(0.0,0.1,0.23);\n\tn.x -= n.y*n.y*0.18;\n\tn.yz = mat2(0.98,0.198997,-0.198997,0.98)*n.yz;\n\td = smin( d, sdCone( n, vec2(0.01733,-0.13) ), 0.03);\n\tn.yz -= vec2(-0.102975, 0.004600);\n\tvec3 m = vec3(abs(n.x),n.yz);\n\tfloat na = sdCone( n, vec2(0.527,-0.85) );\n\tna = smax( na, sdSphere(n,vec3(0.0,-0.03,-0.04),0.1), 0.015 );\n\tna = smin( na, sdEllipsoid(m, vec3(0.038,-0.085,0.0),vec3(0.027)), 0.016 );\n\tna = smin( na, sdEllipsoid(m, vec3(0.0,-0.11,-0.01), vec3(0.02,0.02,0.02)), 0.02 );\n\tna = smax(na,-sdEllipsoid(m, vec3(0.033,-0.09,0.008),vec3(0.01,0.02,0.009)*1.5), 0.008 );\n\td = smin( d, na, 0.01);\n\n    // mouth\n\tvec3 bocap = headp-vec3(-0.006,-0.026,0.22);\n\tvec3 bocap3 = bocap;\n\tbocap.xy = mat2x2(0.99,-0.141,0.141,0.99)*bocap.xy;\n\tvec3 bocap2 = bocap;\n\tbocap.yz = mat2x2(0.9,-0.346,0.346,0.9)*bocap.yz;\n\tfloat  labioa = sdCone(bocap, vec2(0.219,-0.18) );\n\tlabioa = smax( labioa, sdEllipsoid(bocap,vec3(0.0,0.1,-0.15), vec3(0.22,0.35,0.34)), 0.02 );\n\td = smin( d, labioa, 0.015 );\n\td = smax( d, -sdCapsule( bocap, vec3(0.0,-0.077,0.115),vec3(0.0,-0.09,0.135), 0.013 ), 0.01 );\n\tbocap2.y -= min(bocap2.x*bocap2.x*4.0,0.04);\n\td = smax( d, -sdEllipsoid(bocap2,vec3(0.0,-0.172,0.15), vec3(0.09+0.008*sign(bocap.x),0.017,0.25)), 0.01 );\t\t\n\tvec4 b = sdBezier( corner1, center, corner2, bocap );\n\td = smin(d,b.x - 0.0075*sqrt(4.0*b.y*(1.0-b.y)), 0.005);\n\n    // ears\n\tvec3 earq = headq - vec3(0.34,-0.04,0.02);\n\tearq.xy = mat2(0.9,0.436,-0.436,0.9)*earq.xy;\n\tearq.xz = mat2(0.8,0.6,-0.6,0.8)*earq.xz;\n\tfloat ear = sdEllipsoid( earq, vec3(0.0),vec3(0.08,0.12,0.09) );\n\tear = smax( ear, (abs(earq.z)-0.016), 0.01 );\n\tear = smin( ear, sdSphere(earq,vec3(0.015,0.0,-0.03),0.04), 0.02);        \n\tear = smax( ear, -0.8*sdEllipsoid( earq, vec3(0.0,0.022,0.02),vec3(0.06,0.08,0.027) ),0.01 );\n\tear = smax( ear, -sdEllipsoid( earq, vec3(-0.01,-0.01,0.01),vec3(0.04,0.04,0.05) ), 0.01 );\n\td = smin(d,ear, 0.015);\n    \n    // eye sockets\n\td = smax(d,-sdEllipsoid( headq, vec3(0.1,0.03,0.11),vec3(0.105,max(0.0,0.12-0.2*headq.x),0.115)+0.01),0.01 );\n\tb = sdBezier( vec3(0.053,0.017,0.225), vec3(0.12,-0.02,0.255), vec3(0.18,0.02,0.205), headq-vec3(0.0,0.03-0.04,0.0) );\n\td = smin(d,b.x - 0.003*b.y*(1.0-b.y)*4.0,0.012);\n\n    // chin fold\n\tn = (headp-vec3(0.14,-0.16,0.297));\n\tn.xy = mat2(0.8,0.6,-0.6,0.8)*n.xy;\n\td = smax(d, -sdEllipsoid( n,  vec3(0.0), vec3(0.096,0.01,0.03)), 0.007);\n\t\n    // neck/body\n\t{\n\tvec3 q = vec3( abs(p.x), p.yz );\n\td = smin( d, sdCapsule( p, vec4(0.0,-0.1,-0.1,0.1), vec4(0.0,-0.6,-0.1, 0.12 )).x, 0.05 );\n\td = smin( d, sdCapsule( q, vec3(0.0,-0.62,-0.08), vec3(0.24,-0.71,0.02-0.1), 0.16 ), 0.05 );        \n\td = smin( d, sdCapsule( q, vec4(0.046,-0.555,0.05,0.01), vec4(0.250,-0.55,-0.035,-0.02) ).x, 0.03 );\n\t}\n    \n\tvec3 res = vec3(d,1.0,1.0);\n    \n\n    // eyes\n\tm = headq - vec3(0.0021,0.0,0.019);\n\td = sdEllipsoid( m, vec3(0.1,0.03,0.11),vec3(0.105,0.09,0.1) );\n\td = smax(d,-sdEllipsoid( headq, vec3(0.102+0.004*sign(headp.x)*1.8,0.03+0.004*1.8,0.28),vec3(0.07) ),0.001);\n\tif( d<res.x ) res = vec3(d,2.0,1.0);\n\n    // teeth\n\t{\n\tbocap3 = bocap3 - vec3(0.01,-0.055,0.04);\n\tbocap3.xz = mat2x2(0.99,0.141,-0.141,0.99)*bocap3.xz;\n\td = sdCappedCylinder( bocap3.xzy, vec2(0.11,0.01) );\n\tvec3 dd = bocap3;\n\tdd.x = mod(dd.x+0.0075,0.015)-0.0075;\n\tfloat sp = sdBox( dd-vec3(0.0,-0.1,0.0), vec3(0.0004,0.018,0.015) );\n\td = smax(d,-sp,0.003);\n\td = max( d, dot(bocap3.xy,vec2(-0.707,0.707))+0.05 );\n\tif( d<res.x ) res = vec3(d,8.0,1.0);\n\t}\n\n\t\n\t// eyebrows\n\tb = sdBezier( vec3(0.035,0.16,0.0), vec3(0.1,0.18,-0.02), vec3(0.2,0.12,-0.1), \n\t(headq-vec3(0.0,0.0,0.25))*vec3(1.0,1.0,2.0) );\n\td = b.x - 0.01*sqrt(clamp(1.0-b.y,0.0,0.9));\n\tfloat fr = (sign(b.w)*headq.x*0.436+0.9*headq.y);\n\tfloat cp = cos(1300.0*fr);\n\tcp -= 0.5*cos(600.0*fr); \n\tcp += 0.3*cos(330.0*fr);\n\tcp *= clamp(1.0-3.0*headq.x,0.0,0.8);\n\td -= cp*0.0017;\n\td/=1.5;\n\tif( d<res.x ) { res = vec3(d,3.0,0.4);}\n\n    // hair\n\t//if( p.x>-0.4 && p.y>-0.1) // +10%\n\t{\n\t\tfloat hh = 0.27 - headp.y;\n\n\t\tfloat ss = sign(headp.x);\n\n\t\tvec3 pelop = headp;\n\t\tpelop.x += (1.0-hh)*0.007*cos(pelop.y*30.0);\n\t\tvec3 peloq = vec3( abs(pelop.x), pelop.yz );\n\t\t\n\t\tvec3 ta = vec3(0.0);\n\t\tfloat vc = 0.0;\n\n\t\t{\n\t\tconst vec3 p0a = vec3(0.05,0.3,0.15);\n\t\tconst vec3 p0b = vec3(0.18,0.17,0.22);\n\t\tconst vec3 p0c = vec3(0.1,0.2,0.23);\n\t\tvec4 b = sdBezier( p0a, p0c, p0b, pelop );\n\t\tfloat d1 = b.x - 0.06*(1.0-0.9*b.y);\n\t\td = d1; ta = p0b - p0a; vc = b.y;\n\t\t}\n\t\t{\n\t\tconst vec4 p1a = vec4(-0.04,0.26,0.15,0.075);\n\t\tconst vec4 p1c = vec4(0.02,0.2,0.24,0.015);\n\t\tvec2 b = sdCapsule(pelop, p1a, p1c );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = (p1a.xyz-p1c.xyz)*vec3(ss,1.0,1.0); vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec4 p2a = vec4(0.16,0.25,0.14,0.07);\n\t\tvec4 p2b = vec4(0.185+0.025*ss,0.14,0.23-0.02*ss,0.006);\n\t\tvec2 b = sdCapsule(peloq, p2a, p2b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p2b.xyz-p2a.xyz; vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec3 p3a = vec3(0.205,0.20,0.14);\n\t\tvec3 p3b = vec3(0.255+0.01*ss,0.05,0.17);\n\t\tvec3 p3c = vec3(0.21+0.01*ss,0.15,0.18);\n\t\tvec4 b = sdBezier( p3a, p3c, p3b, peloq );\n\t\tfloat d1 = b.x - 0.06*(1.0-0.9*b.y);\n\t\tif( d1<d ) { d=d1; ta = p3b-p3a; vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec4 p4a = vec4(0.24,0.16,0.11,0.06);\n\t\tvec4 p4b = vec4(0.285,-0.04,0.14,0.006);\n\t\tvec2 b = sdCapsule(peloq, p4a, p4b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p4b.xyz-p4a.xyz; vc = b.y; }\n\t\t}\n\t\t{\n\t\tconst vec4 p5a = vec4(0.275,0.12,0.07,0.06);\n\t\tvec4 p5b = vec4(0.295,-0.09,0.1,0.006);\n\t\tvec2 b = sdCapsule(peloq, p5a, p5b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p5b.xyz-p5a.xyz; vc = b.y; }\n\t\t}\n\n\t\t\n\t\t{\n\t\tvec3 vv = normalize(vec3(ta.z*ta.z+ta.y*ta.y, -ta.x*ta.y, -ta.x*ta.z) );\n\t\tfloat ps  = dot(peloq,vv);\n\t\td -= 0.003*sin(300.0*ps);\n\t\td -= 0.008*(-1.0+2.0*textureGood( iChannel0, vec2(1024.0*ps,vc*5.12) ));\n\t\t}\n\t\t\n\t\tif( d<res.x ) res = vec3(d,3.0,vc);\n\t}\n\n    // eyelashes\n\t{\n\tvec3 cp;\n\tvec4 b = sdBezier2(  vec3(0.0525+0.0025*sign(headp.x),0.063, 0.225), \n\t\t\tvec3(0.120,0.135, 0.215), vec3(0.1825+0.0025*sign(headp.x),0.050, 0.200), \n\t\t\theadq, cp );\n\tfloat ls = 4.0*b.y*sqrt(1.0-b.y);\n\td = b.x - 0.002*ls;\n\td += 0.001*ls*sin(headq.x*300.0-headq.y*300.0)*step(cp.y,headq.y);\n\td += 0.001*ls*sin(headq.x*1000.0-headq.y*1000.0)*step(cp.y,headq.y);\n\tif( d<res.x ) { res = vec3(d,3.0,0.35);}\n    }\n\t\n\n    // hat\n    {\n\tvec3 hatp = transformHat( headp );\n\td = sdEllipsoidXY2Z( hatp, vec3(0.36,0.38,0.365) );\n\td = abs(d+0.003)-0.003;\n\td = smax(d,-0.065-hatp.y,0.006);\n\tfloat gb = abs(hatp.x)-hatp.z-0.0975;\n\td -= 0.002*sqrt(clamp(abs(gb)/0.015,0.0,1.0)) - 0.002;\n\thatp.y += 0.1;\n\tfloat p1 = abs(sin(600.0*hatp.x+hatp.y*200.0));\n\tfloat p2 = abs(cos(150.0*hatp.z)*sin(150.0*hatp.y));\n\tp2 *= smoothstep(0.01,0.02,hatp.y-0.035);\n\td -= 0.0005*mix(p1,2.0*p2,smoothstep(0.0,0.01,gb));\n\tif( d<res.x ) res = vec3(d,4.0,1.0);\n\tvec3 vp = hatp - vec3(0.0,0.19,0.0);\n\tvp.yz = mat2(0.8,-0.6,0.6,0.8)*vp.yz;\n\tvp.y -= 0.2*sqrt(clamp(1.0-vp.x*vp.x/0.115,0.0,1.0))-0.1;\n\td = 0.8*sdEllipsoid( vp, vec3(0.0,0.0,0.25),vec3(0.3,0.04,0.35) );\n\tif( d<res.x ) res = vec3(d,5.0,1.0);\n    }\t\n\t\n\t\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalmap( in vec3 pos, in float ep )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*map(pos+e.xyy*ep).x + \n\t\t\t\t\t e.yyx*map(pos+e.yyx*ep).x + \n\t\t\t\t\t e.yxy*map(pos+e.yxy*ep).x + \n\t\t\t\t\t e.xxx*map(pos+e.xxx*ep).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n//=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=ZERO; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = 0.001;\n\tfor( int i=ZERO; i<50; i++ )\n\t{\n\t\tfloat h = map(ro + rd*t ).x;\n\t\tres = min( res, smoothstep(0.0,1.0,1.4*k*(h+0.0015)/sqrt(t)) );\n\t\tt += clamp( h, 0.003, 0.1 );\n\t\tif( res<0.001 || t>0.8) break;\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in float matInfo )\n{\n\tfloat eps = (abs(m-3.0)<0.2) ? 0.002: 0.0002;\n\t\n\tvec3 pos = ro + t*rd;\n\tvec3 nor = calcNormalmap( pos, eps );\n\t\n\n\tvec3 mateD = vec3(0.0);\n\tvec2 mateK = vec2(0.0);\n\tfloat mateS = 0.0;\n\tvec3 mateSG = vec3(1.0);\n\n\tif( m<1.5 )\n\t{\n\t\tmateD = vec3(0.132,0.06,0.06);\n\t\t\n\t\tvec3 p = transformHead( pos );\n\t\tvec3 headp = p;\n\t\tvec3 q = vec3( abs(p.x), p.yz );\n\n\t\tfloat m = 1.0 - smoothstep( 0.04, 0.14, length(q-vec3(0.16,-0.11,0.23)) );\n\t\tfloat no = texture(iChannel0,p.xy).x;\n\t\tm = clamp( m + 0.25*(-1.0+2.0*no), 0.0, 1.0 );\n\t\tmateD = mix( mateD, vec3(0.13,0.03,0.03), m );\n\t\t\n\n\t\tmateSG = vec3(0.75,0.97,1.0);\n\n\t\t\t\t\t\n\t\tm = 1.0 - smoothstep( 0.04, 0.17, length(q-vec3(0.45,-0.01,0.0)) );\n\t\tmateD += vec3(1.0,0.01,0.0)*m*0.3*(1.0+0.4*sign(p.x));\n\t\tmateSG = mix( mateSG, vec3(0.3-0.1*sign(p.x),0.9,1.0), m );;\n\n\t\tm = 1.0 - smoothstep( 0.05, 0.1, length(vec3(0.5,1.0,1.0)*(q-vec3(0.0,-0.06,0.23))) );\n\n\t\tvec2 uv = pos.xy*22.0;\n\t\tvec2 iuv = floor(uv);\n\t\tvec2 fuv = fract(uv);\n\t\tvec4 ran = texelFetch( iChannel0, (ivec2(iuv)+6)&255, 0 );\n\t\tvec2 off = ran.xy;\n\t\tfloat sss = pow(ran.z,5.0);\n\t\tfloat size = max(0.0,(0.5+0.5*m)*(0.3+0.7*sss)*0.12);\n\t\tfloat fr = 1.0 - smoothstep( size*0.5, size*2.0, length(fuv-off) );\n\t\tmateD = mix(mateD,vec3(0.25,0.05,0.0)*0.2, 0.6*(1.0-0.4*sss)*fr );\n\t\t\t\t\t\n\t\tmateK = vec2(0.08,0.5);\n\t\tmateS = 1.0;    \n\n\t\t\n\t\tvec3 bocap = headp-vec3(-0.006,-0.025,0.22);\n\t\tbocap.xy = mat2x2(0.99,-0.141,0.141,0.99)*bocap.xy;\n\t\tbocap.yz = mat2x2(0.9,-0.346,0.346,0.9)*bocap.yz;\n\t\t\n\t\t{\n\t\tvec4 b = sdBezier( corner1, center, corner2, bocap );\n\t\tfloat d1 = b.x - 0.01*4.0*b.y*(1.0-b.y);\n\t\tfloat isLip = 1.0-smoothstep( 0.0005, 0.0050, d1 );\n\t\tmateD = mix( mateD, vec3(0.14,0.04,0.05), 0.7*isLip );\n\t\tmateK = mix( mateK, vec2(0.4,1.5), isLip );\n\t\t}\n\t\t\n\t\tmateK *= 0.5 + no;\n\t}\n\telse if( m<2.5 )\n\t{\n\t\tmateD = vec3(0.18,0.18,0.225)*0.85;\n\t\tmateK = vec2(0.5,10.0);\n\t\tmateSG = vec3(1.0,1.0,0.9);\n\t\t\n\t\tvec3 p = transformHead( pos );\n\t\tvec3 q = vec3( abs(p.x), p.yz );\n\t\t\n\t\tvec2 r = q.xy-vec2(0.102+0.004*sign(p.x),0.03+0.004);\n\t\t\n\t\tfloat m = length(r) - 0.042;\n\t\tif( m<0.0 )\n\t\t{\n\t\t\tm = abs(m);\n\t\t\tmateD = mix( mateD, vec3(0.0), smoothstep(0.0,0.003,m));\n\t\t\tmateD = mix( mateD, vec3(0.06,0.02,0.0), smoothstep(0.003,0.006,m));\n\t\t\t\n\t\t\tr.x *= -sign(p.x);\n\t\t\tfloat an = atan(r.y,r.x) + 1.5;\n\t\t\tfloat ca = 1.0-smoothstep(0.0,1.0,abs(an-1.0));\n\t\t\tca *= 1.0-smoothstep(0.0,0.008,abs(m-0.011));\n\n\t\t\tfloat te = texture(iChannel0, vec2(an*0.1,m)).x;\n\t\t\tmateD = mix( mateD, (1.8*te*vec3(0.06,0.02,0.0)+(0.5+0.5*te)*ca*1.3*vec3(0.1,0.07,0.05)), smoothstep(0.003,0.006,m));\n\n\t\t\tmateD = mix( mateD, vec3(0.0), smoothstep(0.017,0.018,m-0.001));\n\t\t\tmateK = vec2(0.05,8.0);\n\t\t}\n\n\t\tr = q.xy-vec2(0.105+0.03*sign(p.x),0.058);\n\t\tmateD += (1.0-smoothstep(0.00,0.012,length(r)))*1.0;\n\t}\n\telse if( m<3.5 )\n\t{\n\t\tfloat focc = smoothstep(0.0,1.0,matInfo);\n\n\t\tmateD = vec3(0.025,0.015,0.01)*0.6*focc;\n\t\tmateK = vec2(0.1*focc,1.0);\n\t}\n\telse if( m<4.5 )\n\t{\n\t\tvec3 hatp = pos;\n\t\thatp = transformHat(hatp);\n\t\thatp.y += 0.1;\n\t\tfloat f = abs(hatp.x)-hatp.z;\n\t\tf = smoothstep(0.19,0.2,f );\n\t\t\n\t\tvec3 blue = vec3(0.01,0.04,0.08);\n\t\tvec3 te = \n\t\ttexture( iChannel0, 0.15*pos.yz ).xyz+\n\t\ttexture( iChannel0, 1.0*pos.yz ).xyz;\n\t\tblue *= 0.5+0.5*te.z;\n\t\tmateD = mix( vec3(0.18), blue, f );\n\t\tmateS = 0.05;\n\t\t\n\t\t\t\n\t\tvec2 si = (hatp.xy-vec2(0.0,-0.18)) * 3.5;\n\t\tfloat h = si.y - 0.1*sin( 8.0*si.x );\n\t\th = min( abs(h-1.15)-0.06, abs(h-1.0)-0.015 );\n\t\th += clamp( (abs(hatp.x)-0.25)/0.1, 0.0, 1.0 );\n\t\tmateD = mix( mateD, vec3(0.004,0.008,0.014), 1.0-smoothstep( 0.01, 0.02, h ) );\n\t\t\n\t}\n\telse if( m<5.5 )\n\t{\n\t\tmateD = 0.5*vec3(0.01,0.04,0.08);\n\t\tmateD *= 0.7+0.6*texture( iChannel0, 2.0*pos.xz ).x;\n\t\tmateS = 0.05;\n\t}\n\telse if( m<8.5 )\n\t{\n\t\tmateD = vec3(0.30,0.30,0.40)*0.5;\n\t\tmateK = vec2(0.5,1.0);\n\t\tmateS = 0.2;\n\t\t\n\t}\n\t\n\tfloat fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n\tfloat occ = calcAO( pos, nor );\n\t\n\tvec3 col = vec3(0.0);\n\t\n    {\n\t\t// key\n\t\tfloat dif1 = dot(nor,sunDir);\n\t\tvec3 hal = normalize( sunDir-rd );\n\t\tfloat spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\t\tfloat sha = calcSoftShadow( pos+nor*0.0005, sunDir, 24.0 ); \n\t\tfloat ssha = 1.0;\n\t\tif( abs(m-3.0)<0.2 ) { dif1=0.5*dif1+0.5; sha=0.95*sha+0.05;  }\n\t\tif( abs(m-2.0)<0.2 ) { sha=clamp(0.2+sha*dif1*2.0,0.0,1.0); dif1=0.4+0.6*dif1; ssha=0.0; }\n\t\t\n\t\tdif1 = clamp(dif1,0.0,1.0);\n\n        float sks = (abs(m-1.0)<0.2)?0.5:0.0;\n\t\tvec3 sha3 = vec3((1.0-sks)*sha+sks*sqrt(sha),sha*0.4+0.6*sha*sha,sha*sha);\n\t\t\n\t\tcol += mateD*3.1*vec3(2.5,1.1,0.5)*dif1*sha3;\n\t\tcol += mateK.x*vec3(1.5,1.4,1.3)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0))*ssha;\n    }\n\t{\n\t\t// fill\n\t\tcol += mateD*vec3(0.45,0.75,1.0)*occ*occ*occ*(0.5+0.5*nor.y)*4.5;\n\t\tfloat dif1 = 0.5 + 0.5*nor.y;\n\t\tfloat sha = 1.0;\n\t\tfloat spe = smoothstep( -0.15, 0.15, reflect(rd,nor).y );\n\t\tcol += mateK.x*vec3(0.7,0.9,1.0)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0))*occ*occ*3.0;\n\t}\n\t{\n\t\t// bounce\n\t\tvec3 bak = normalize( sunDir*vec3(-1.0,-3.5,-1.0));\n\t\tfloat dif = clamp(0.3+0.7*dot(nor,bak),0.0,1.0);\n\t\tcol += mateD*vec3(1.2,0.8,0.6)*occ*occ*dif*2.5;\n\t}\n\t{\n\t\tcol += mateS*mateD*fre    *vec3(2.0,0.95,0.80)*0.7*occ;\n\t\tcol += mateS*mateD*fre*fre*vec3(1.1,0.80,0.65)*1.2*occ;\n\t}\n\n\tcol = pow( col, mateSG );\n\n    return col;\n}\n\n//--------------------------------------------\n\nvec3 intersect( in vec3 ro, in vec3 rd, float mindist, float maxdist )\n{\n\tvec3 res = vec3(-1.0);\n\t\n\tfloat t = mindist;\n\tfor( int i=ZERO; i<150; i++ )\n\t{\n\t\tvec3 p = ro + t*rd;\n\t\tvec3 h = map( p );\n\t\tres = vec3(t,h.yz);\n\t\tif( abs(h.x)<0.00025 || t>maxdist ) break;\n\t\tt += h.x;\n\t}\n\treturn res;\n}\n\n///////////////////////////////////////////////\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in int sampleID )\n{\n\tvec4 res = texture(iChannel1,uv);\n\tvec3 col = res.xyz;\n\t\n\tconst float mindist = 0.8;\n\tconst float maxdist = 1.8;\n\t\n\tvec3 tm = intersect( ro, rd, mindist, maxdist );\n\tif( tm.y>-0.5 && tm.x < maxdist )\n\t{\n\t\tcol = shade( ro, rd, tm.x, tm.y, tm.z );\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tmat3 ca; vec3 ro; float fl;\n\tcomputeCamera( iTime, ca, ro, fl );\n#if AA<2\n\tvec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3  rd = normalize( ca*vec3(p,-fl) );\n\tvec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, 0 );\n#else\n\tvec3 col = vec3(0.0);\n\tfor( int m=ZERO; m<AA; m++ )\n\tfor( int n=ZERO; n<AA; n++ )\n\t{\n\t\tvec2 rr = vec2( float(m), float(n) ) / float(AA) - 0.5;\n\t\tvec2 p = (2.0*(fragCoord.xy+rr)-iResolution.xy)/iResolution.y;\n\t\tvec3 rd = normalize( ca * vec3(p,-fl) );\n\t\tcol += render( ro, rd, (fragCoord+rr)/iResolution.xy, AA*m+n );\n\t}    \n\tcol /= float(AA*AA);\n#endif\n\t\t\n\tfragColor = vec4( col, 1.0 );\n}",
        "name": "Buffer C",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "*iq writes shader* Wow nice! *6 months pass* What the heck, still top of the hot page?",
        "date": "1557611146",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "4lSyRG",
        "hidden": 0
      },
      {
        "text": "kepwewew wew",
        "date": "1551428559",
        "username": "hl123456",
        "userpicture": "/img/profile.jpg",
        "id": "XtscD7",
        "hidden": 0
      },
      {
        "text": "Another masterpiece!",
        "date": "1547519704",
        "username": "starea",
        "userpicture": "/media/users/starea/profile.jpeg",
        "id": "Ms2BDG",
        "hidden": 0
      },
      {
        "text": "lol only iq can keep a shader hot for a month",
        "date": "1547410363",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "4sjfWG",
        "hidden": 0
      },
      {
        "text": "nice",
        "date": "1545928798",
        "username": "joshuakeler",
        "userpicture": "/media/users/joshuakeler/profile.png",
        "id": "lsBBRV",
        "hidden": 0
      },
      {
        "text": "remember me of the guy back in school i stole the lunch from, after some shader experiments with nature, you start documenting the poor people. very nice",
        "date": "1544903597",
        "username": "nabr",
        "userpicture": "/media/users/nabr/profile.jpeg",
        "id": "MsjfWm",
        "hidden": 0
      },
      {
        "text": "Who needs Renderman? We've got two triangles.",
        "date": "1543341365",
        "username": "CLPB",
        "userpicture": "/img/profile.jpg",
        "id": "Xs2BDz",
        "hidden": 0
      },
      {
        "text": "I love showing your works to 3d artists and seeing their eyes after i tell them this is a pixel shader :D Nice job as always!",
        "date": "1543321870",
        "username": "Pr0fed",
        "userpicture": "/media/users/Pr0fed/profile.png",
        "id": "XdjBDz",
        "hidden": 0
      },
      {
        "text": ":love: Amazing piece! Very inspiring.",
        "date": "1543251679",
        "username": "duvengar",
        "userpicture": "/img/profile.jpg",
        "id": "XdjBWR",
        "hidden": 0
      },
      {
        "text": "WOW! Incredible",
        "date": "1543223741",
        "username": "EvilRyu",
        "userpicture": "/media/users/EvilRyu/profile.jpeg",
        "id": "ldSBWz",
        "hidden": 0
      },
      {
        "text": "Whoa insane modeling work, and very cool detail on the hair and hat!",
        "date": "1543094164",
        "username": "mmerchante",
        "userpicture": "/media/users/mmerchante/profile.jpeg",
        "id": "4dBBDz",
        "hidden": 0
      },
      {
        "text": "this is ridiculously good",
        "date": "1543071928",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "XsSBWz",
        "hidden": 0
      },
      {
        "text": "Wooow.  I did what adx suggested and this is amazing!",
        "date": "1543025211",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "XsSfWR",
        "hidden": 0
      },
      {
        "text": "Changing smin/smax to regular min/max (exposing the underlying primitives) reveals just how precise the modelling really is - very impressive! And with everything else (composition, lighting etc.) also top notch, you've definitely raised the bar.",
        "date": "1543009278",
        "username": "adx",
        "userpicture": "/media/users/adx/profile.jpeg",
        "id": "XsSBWR",
        "hidden": 0
      },
      {
        "text": "what the fractal.. duuude",
        "date": "1542909782",
        "username": "GottZ",
        "userpicture": "/img/profile.jpg",
        "id": "lsjfRw",
        "hidden": 0
      },
      {
        "text": "wow! so good. and performs really well with that amount of detail.",
        "date": "1542892460",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "Xdjfzm",
        "hidden": 0
      },
      {
        "text": "Crazy amazing as always... the waves/foam work so well too, the brain extrapolates all the intricate water animation detail... (it doesn't loop properly on this machine though I think?)",
        "date": "1542877381",
        "username": "blackjero",
        "userpicture": "/img/profile.jpg",
        "id": "4d2BRm",
        "hidden": 0
      },
      {
        "text": "Wow, Amazing!!!",
        "date": "1542872263",
        "username": "rcrookie",
        "userpicture": "/media/users/rcrookie/profile.jpeg",
        "id": "XdjBRm",
        "hidden": 0
      },
      {
        "text": "You are amazing, did I tell you that before? :)",
        "date": "1542850547",
        "username": "Kali",
        "userpicture": "/media/users/Kali/profile.jpeg",
        "id": "4sjfzw",
        "hidden": 0
      },
      {
        "text": "Soooo Amazing! Bravo!!",
        "date": "1542842665",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "4sjBzw",
        "hidden": 0
      },
      {
        "text": ":love: Mind blowing, on many levels.",
        "date": "1542842288",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "XsjBzw",
        "hidden": 0
      },
      {
        "text": "huh, nice trick in the normal calculation; somehow missed that until now.",
        "date": "1542837627",
        "username": "KylBlz",
        "userpicture": "/media/users/KylBlz/profile.jpeg",
        "id": "4djfRw",
        "hidden": 0
      },
      {
        "text": "Wow.  Such pixar!",
        "date": "1542836338",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "4s2BRw",
        "hidden": 0
      },
      {
        "text": "Amazing! I can't even comprehend this...",
        "date": "1542827612",
        "username": "saidwho12",
        "userpicture": "/img/profile.jpg",
        "id": "MdBfzm",
        "hidden": 0
      },
      {
        "text": "What is this sourcery!? Jaw drops.",
        "date": "1542827104",
        "username": "jmaasing",
        "userpicture": "/media/users/jmaasing/profile.jpeg",
        "id": "ldBfzm",
        "hidden": 0
      },
      {
        "text": "Brilliant!",
        "date": "1542822186",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MdSfzm",
        "hidden": 0
      },
      {
        "text": "incredible!",
        "date": "1542818809",
        "username": "wyatt",
        "userpicture": "/media/users/wyatt/profile.png",
        "id": "MdBBzm",
        "hidden": 0
      },
      {
        "text": "Mind blowing shader!",
        "date": "1542815321",
        "username": "vgs",
        "userpicture": "/media/users/vgs/profile.jpeg",
        "id": "MsSBzm",
        "hidden": 0
      },
      {
        "text": "Beautiful! Really nice.",
        "date": "1542813043",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "MdSBzm",
        "hidden": 0
      },
      {
        "text": "Superb! The modelling of the eyes is crazy but really works. The code is all so fantastically simple and the end result is so good.",
        "date": "1542810316",
        "username": "P_Malin",
        "userpicture": "/media/users/P_Malin/profile.jpeg",
        "id": "MsSfRm",
        "hidden": 0
      },
      {
        "text": "I hope to be as good as you someday. Another masterpiece from the master.",
        "date": "1542808729",
        "username": "PlNG",
        "userpicture": "/img/profile.jpg",
        "id": "MdSfRm",
        "hidden": 0
      },
      {
        "text": "WOW, nice scene! Looks awesome! :)",
        "date": "1542807800",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "ldSfRm",
        "hidden": 0
      },
      {
        "text": "Shadertoy The Movie!",
        "date": "1542804482",
        "username": "Antonalog",
        "userpicture": "/media/users/Antonalog/profile.jpeg",
        "id": "MsBBRm",
        "hidden": 0
      },
      {
        "text": "awesome as usual.",
        "date": "1542804269",
        "username": "Del",
        "userpicture": "/media/users/Del/profile.jpeg",
        "id": "lsBBRm",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ldfyzl",
      "date": "1489383273",
      "viewed": 42251,
      "name": "Rainier mood",
      "username": "Zavie",
      "description": "Improving upon https://www.shadertoy.com/view/XslcWn by avoiding using pixel derivatives (which are shared by 2x2 blocs, thus give an aliased look).\nTo do: fix a glitch between tiles.\n\nClick and drag to change scale.",
      "likes": 93,
      "published": 3,
      "flags": 0,
      "tags": [
        "2d",
        "rain",
        "ripple",
        "hash"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "XdX3Rn",
            "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
            "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n\nA quick experiment with rain drop ripples.\n\nThis effect was written for and used in the launch scene of the\n64kB intro \"H - Immersion\", by Ctrl-Alt-Test.\n\n > http://www.ctrl-alt-test.fr/productions/h-immersion/\n > https://www.youtube.com/watch?v=27PN1SsXbjM\n\n-- \nZavie / Ctrl-Alt-Test\n\n*/\n\n// Maximum number of cells a ripple can cross.\n#define MAX_RADIUS 2\n\n// Set to 1 to hash twice. Slower, but less patterns.\n#define DOUBLE_HASH 0\n\n// Hash functions shamefully stolen from:\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolution = 10. * exp2(-3.*iMouse.x/iResolution.x);\n\tvec2 uv = fragCoord.xy / iResolution.y * resolution;\n    vec2 p0 = floor(uv);\n\n    vec2 circles = vec2(0.);\n    for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n    {\n        for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n        {\n\t\t\tvec2 pi = p0 + vec2(i, j);\n            #if DOUBLE_HASH\n            vec2 hsh = hash22(pi);\n            #else\n            vec2 hsh = pi;\n            #endif\n            vec2 p = pi + hash22(hsh);\n\n            float t = fract(0.3*iTime + hash12(hsh));\n            vec2 v = p - uv;\n            float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n            float h = 1e-3;\n            float d1 = d - h;\n            float d2 = d + h;\n            float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n            float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n            circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n        }\n    }\n    circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));\n\n    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n    vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n    vec3 color = texture(iChannel0, uv/resolution - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n\tfragColor = vec4(color, 1.0);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Hello LeeTheDev, for a non-commercial open source project, feel free to use this code as long as you keep the header with it. :)",
        "date": "1530242093",
        "username": "Zavie",
        "userpicture": "/media/users/Zavie/profile.png",
        "id": "4dSczc",
        "hidden": 0
      },
      {
        "text": "Hello, mind if I use this for a little non-commercial open source project?",
        "date": "1529448130",
        "username": "LeeTheDev",
        "userpicture": "/img/profile.jpg",
        "id": "lsjczG",
        "hidden": 0
      },
      {
        "text": "Very nice!",
        "date": "1526686179",
        "username": "d1kkop",
        "userpicture": "/img/profile.jpg",
        "id": "ls2czW",
        "hidden": 0
      },
      {
        "text": "Awesome Thank you!",
        "date": "1523376099",
        "username": "jpkelly",
        "userpicture": "/media/users/jpkelly/profile.png",
        "id": "4slcRl",
        "hidden": 0
      },
      {
        "text": "Hello jpkelly, yes no problem for a VJ set.\nJust keep the header comment in the shader please.",
        "date": "1523372161",
        "username": "Zavie",
        "userpicture": "/media/users/Zavie/profile.png",
        "id": "XdlyRl",
        "hidden": 0
      },
      {
        "text": "Hello Zavie.\nMay I use this shader for an upcoming VJ gig?\nJP",
        "date": "1523345775",
        "username": "jpkelly",
        "userpicture": "/media/users/jpkelly/profile.png",
        "id": "lsXyRs",
        "hidden": 0
      },
      {
        "text": "Hello heliumsoft. Sorry I am only noticing your message now.\nYou may use the effect, as long as you include a mention of \"Ctrl-Alt-Test (http://www.ctrl-alt-test.fr)\" in the credits.",
        "date": "1515691635",
        "username": "Zavie",
        "userpicture": "/media/users/Zavie/profile.png",
        "id": "llKSRK",
        "hidden": 0
      },
      {
        "text": "Very nice effect.\nCan i use your code for commercial project?\nI am developing Video Editor for Mobile, I need your effect like this.\nThanks.",
        "date": "1511492306",
        "username": "heliumsoft",
        "userpicture": "/img/profile.jpg",
        "id": "4l3XDf",
        "hidden": 0
      },
      {
        "text": "seems to be simpler than vorRain() of\nhttps://www.shadertoy.com/view/ldByDw\n\nbecause all fragment code runs in parallel dFdx() and dFdY() give decent first derivatives almost for free.",
        "date": "1493992540",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4sKXR3",
        "hidden": 0
      },
      {
        "text": "Impressive",
        "date": "1489408286",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "MdKXRz",
        "hidden": 0
      },
      {
        "text": "Done. Thanks for the suggestion. :)",
        "date": "1489398853",
        "username": "Zavie",
        "userpicture": "/media/users/Zavie/profile.png",
        "id": "MdVSRz",
        "hidden": 0
      },
      {
        "text": "suggestion: \n   float resolution = 10. * exp2(-3.*iMouse.x/iResolution.x);",
        "date": "1489397251",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ldVSRz",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ldlcRf",
      "date": "1489785393",
      "viewed": 51133,
      "name": "Tribute - Journey!",
      "username": "Shakemayster",
      "description": "This is just a tribute, to the greatest game in the world, ah,\nguh fli-goo ga goo buh dee\nOoh guh goo bee, ooh guh guh bee guh guh bee\nFli-goo gee goo, a-fli-guh woo wa mama Lucifer!",
      "likes": 372,
      "published": 3,
      "flags": 64,
      "tags": [
        "clouds",
        "sky",
        "character",
        "tribute",
        "desert",
        "journey",
        "scarf",
        "sphericalclouds",
        "traveller",
        "tomb"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGzn",
            "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
            "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4dXGzr",
            "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
            "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4djGDV",
            "filepath": "https://soundcloud.com/awintory/journey-i-was-born-for-this?in=awintory/sets/journey",
            "previewfilepath": "https://soundcloud.com/awintory/journey-i-was-born-for-this?in=awintory/sets/journey",
            "type": "musicstream",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 0
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n\tBefore you continue reading, feast your eyes on these beautiful Color Schemes (0,1,2)\n*/\n\n// Modify the number to 0,1,2 or 3 and press play button at bottom for different schemes.\n#define COLOR_SCHEME 1\n\n/*\n\tThis shader is just a tribute to \"Journey\" game by That Game Company. Some answers:\n\t1) No, I do not have any affiliation with That Game Company.\n\t2) Yes, Journey is one of the best games ever made\n\t3) It has taken me around 3-4 months from start to finish, evenings and weekends\n\t4) Most of the time was spent getting the details right\n\t5) Yes, the character needs more work. One day I will finish it\n\t6) Yes, if anybody comes up with something cool to add, I would love to improve :)\n\t7) There is nothing mathemagically amazing in this shader. I hope you do find it pretty though!\n\t8) Yes, the code is fairly ugly. But look at the colors - PRETTY!\n\t9) If you have any other questions, I will be happy to answer\n\n\tThis shader started as a learning playground, but around January, I finished my second round of Journey\n\tand thought, well why the hell not, and so here we are.\n\n\tSpecial thanks to Thibault Girard and Jack Hamilton for their artistic input. Also bigs up to Peter Pimley\n\tfor his constant optimism.\n\n\tYou are hereby granted your wish to follow me on twitter: @shakemayster\n\n\tOther authors (With BIG thanks !!!) \n\tDave_Hoskins\n\tDila\n\tMaurogik\n\tFabriceNeyret2\n*/\n\n#define RGB vec3\n#define mul(a,b) b*a\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\n\n#if COLOR_SCHEME == 0\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.82000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.22632, 0.88099, -0.4155) ;\nconst float _Brightness = 1.00000 ;\nconst float _Contrast = 1.00000 ;\nconst float _Saturation = 1.00000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(1, 0.73741, 0.63971) ;\nconst RGB _Zenith = RGB(0.67128, 0.94118, 0.69204) ;\nconst float _ZenithFallOff = 1.42000 ;\nconst RGB _Nadir = RGB(0, 0, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.80147, 0.80147, 0.80147) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.57353, 0.1488, 0.067474) ;\nconst RGB _CharacterTerrainCol = RGB(0.375, 0.21885, 0.15993) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.38971, 0.10735, 0.054444) ;\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.35588, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 20.00000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(1, 0.96957, 0.88235) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.47735, 0.59559, 0.49705) ;\nconst RGB _TombScarfColor = RGB(0.45588, 0.093858, 0.093858) ;\nconst RGB _PyramidCol = RGB(0.30147, 0.28329, 0.21059) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.05) ;\nconst RGB _TerrainCol = RGB(0.76863, 0.55294, 0.47059) ;\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 1.94000 ;\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 2.00000 ;\nconst float _TerrainRimSpecPower = 1.46000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.40441, 0.34106, 0.31818) ;\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.81471, 0.74265) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.80882, 0.11671, 0.017842) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.56187, 0.0073529) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 4.00000 ;\n#endif\n\n#if COLOR_SCHEME == 1\nconst float _FogMul = -0.00800 ;\nconst float _FogPow = 1.00000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\nconst float _Brightness = 0.40000 ;\nconst float _Contrast = 0.83000 ;\nconst float _Saturation = 1.21000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(1, 0.95441, 0.77206) ;\nconst RGB _Zenith = RGB(0.77941, 0.5898, 0.41263) ;\nconst float _ZenithFallOff = 2.36000 ;\nconst RGB _Nadir = RGB(1, 0.93103, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.96324, 0.80163, 0.38954) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\nconst RGB _CharacterTerrainCol = RGB(0.35294, 0.16016, 0.12197) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.25735, 0.028557, 0.0056769) ;\nconst RGB _CharacterYellowColor = RGB(0.88971, 0.34975, 0) ;\nconst RGB _CharacterWhiteColor = RGB(0.9928, 1, 0.47794) ;\nconst float _CharacterBloomScale = 0.70000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 4.55000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(1, 0.84926, 0.69853) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.64706, 0.38039, 0.27451) ;\nconst RGB _TombScarfColor = RGB(0.38971, 0.10029, 0.10029) ;\nconst RGB _PyramidCol = RGB(0.69853, 0.40389, 0.22086) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.3) ;\nconst RGB _TerrainCol = RGB(0.56618, 0.29249, 0.1915) ;\nconst RGB _TerrainSpecColor = RGB(1, 0.77637, 0.53676) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 3.20000 ;\nconst RGB _TerrainRimColor = RGB(0.16176, 0.13131, 0.098724) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 1.61000 ;\nconst float _TerrainRimSpecPower = 2.88000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.48529, 0.13282, 0) ;\nconst RGB _TerrainDistanceShadowColor = RGB(0.70588, 0.4644, 0.36851) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.85294, 0.11759, 0.012543) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.3931, 0) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 2.61000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 1.75000 ;\n#endif\n\n#if COLOR_SCHEME == 2\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.68000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\nconst float _Brightness = 0.40000 ;\nconst float _Contrast = 0.82000 ;\nconst float _Saturation = 1.21000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(0.97059, 0.97059, 0.97059) ;\nconst RGB _Zenith = RGB(0.98039, 0.83137, 0.53725) ;\nconst float _ZenithFallOff = 2.36000 ;\nconst RGB _Nadir = RGB(0, 0, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.84559, 0.77688, 0.6031) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\nconst RGB _CharacterTerrainCol = RGB(0.5, 0.3404, 0.12868) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.31618, 0.14042, 0.039522) ;\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.30233, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 12.47000 ;\nconst float _CloudTransparencyMul = 0.80000 ;\nconst RGB _CloudCol = RGB(0.99216, 0.9451, 0.76471) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.94118, 0.82759, 0.45675) ;\nconst RGB _TombScarfColor = RGB(0.44118, 0.19989, 0.14922) ;\nconst RGB _PyramidCol = RGB(0.92647, 0.73579, 0.3338) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 4.65) ;\nconst RGB _TerrainCol = RGB(0.71324, 0.5076, 0.236) ;\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 0.03000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 3.20000 ;\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 1.61000 ;\nconst float _TerrainRimSpecPower = 0.38000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.66912, 0.52969, 0.369) ;\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.75466, 0.43382) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.91912, 0.30412, 0.21626) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(0.98529, 0.60477, 0.12316) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 4.00000 ;\n#endif\n\n#if COLOR_SCHEME == 3\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.82000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.29644, 0.6859, -0.66458) ;\nconst float _Brightness = 1.00000 ;\nconst float _Contrast = 1.00000 ;\nconst float _Saturation = 1.00000 ;\nconst vec3 _SunStar = vec3(20.45, 1.49, 0.5) ;\nconst float _SunSize = 26.09000 ;\nconst float _SunScale = 15.04000 ;\nconst float _ExposureOffset = 13.72000 ;\nconst float _ExposurePower = 0.60000 ;\nconst float _ExposureStrength = 0.02000 ;\nconst RGB _SunColor = RGB(0.51471, 0.79919, 1) ;\nconst RGB _Zenith = RGB(0, 0.053922, 0.16176) ;\nconst float _ZenithFallOff = 1.42000 ;\nconst RGB _Nadir = RGB(0.21569, 0.2549, 0.36078) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.35191, 0.30223, 0.47794) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.36765, 0.097656, 0.045956) ;\nconst RGB _CharacterTerrainCol = RGB(0.083261, 0.11379, 0.16176) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.073529, 0.011604, 0) ;\nconst RGB _CharacterYellowColor = RGB(0.60294, 0.33162, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 19.83000 ;\nconst float _CharacterFogScale = 60.00000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(0.0069204, 0.15969, 0.23529) ;\nconst RGB _BackCloudCol = RGB(0, 0.10969, 0.15441) ;\nconst RGB _CloudSpecCol = RGB(0.11765, 0.11765, 0.11765) ;\nconst RGB _BackCloudSpecCol = RGB(0.080882, 0.080882, 0.080882) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.23789, 0.27707, 0.40441) ;\nconst RGB _TombScarfColor = RGB(0.066176, 0, 0.034229) ;\nconst RGB _PyramidCol = RGB(0, 0, 0) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.92) ;\nconst RGB _TerrainCol = RGB(0, 0.058832, 0.10294) ;\nconst RGB _TerrainSpecColor = RGB(0.24622, 0.29188, 0.33824) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 1.94000 ;\nconst RGB _TerrainRimColor = RGB(0.091021, 0.057093, 0.16176) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 2.00000 ;\nconst float _TerrainRimSpecPower = 1.46000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.37) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.11029, 0.11029, 0.11029) ;\nconst RGB _TerrainDistanceShadowColor = RGB(0.0034061, 0.073181, 0.15441) ;\nconst float _TerrainDistanceShadowPower = 0.06000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.12661, 0.004109, 0.13971) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(0.48529, 0.2711, 0) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 5.51000 ;\n#endif\n\n//==========================================================================================\n// Play with these at your own risk. Expect, unexpected results!\n//==========================================================================================\n\nconst mat4 _CameraInvViewMatrix = mat4( 1, 0, 0, 1.04, \n0, 0.9684963, 0.2490279, 2.2, \n0, 0.2490279, -0.9684963, 18.6, \n0, 0, 0, 1 ) ;\nconst vec3 _CameraFOV = vec3(1.038, 0.78984, -1) ;\nconst vec3 _CameraPos = vec3(1.0, 2.2, 18.6) ;\nconst vec4 _CameraMovement = vec4(0.15, 0.1, 0.2, 0.25) ;\n\nconst vec3 _WindDirection = vec3(-0.27, -0.12, 0) ;\n\nconst float _DrawDistance = 70.00000 ;\nconst float _MaxSteps = 64.00000 ;\n\nconst vec3 _SunPosition = vec3(0.2, 56, -40.1) ;\nconst float _CharacterRotation = 0.17000 ;\nconst vec3 _CharacterPosition = vec3(0.52, 2.35, 17.6) ;\nconst vec3 _CharacterScale = vec3(0.4, 0.53, 0.38) ;\nconst float _MainClothRotation = 0.30000 ;\nconst vec3 _MainClothScale = vec3(0.3, 0.68, 0.31) ;\nconst vec3 _MainClothPosition = vec3(0, -0.12, 0) ;\nconst vec3 _MainClothBotCutPos = vec3(0, -0.52, 0) ;\nconst vec3 _MainClothDetail = vec3(6, 0.04, 1.3) ;\nconst float _HeadScarfRotation = -0.19000 ;\nconst vec3 _HeadScarfPosition = vec3(-0.005, -0.16, -0.01) ;\nconst vec3 _HeadScarfScale = vec3(0.18, 0.2, 0.03) ;\nconst float _HeadRotationX = -0.30000 ;\nconst float _HeadRotationY = 0.29000 ;\nconst float _HeadRotationZ = 0.00000 ;\nconst vec3 _HeadPos = vec3(0, -0.04, 0.01) ;\nconst vec3 _LongScarfPos = vec3(0.01, -0.15, 0.09) ;\nconst vec3 _LongScarfScale = vec3(0.05, 1.25, 0.001) ;\nconst vec4 _LongScarfWindStrength = vec4(0.3, 4.52, 5.2, 0.02) ;\nconst float _LongScarfRotX = 1.43000 ;\nconst float _LongScarfMaxRad = 1.99000 ;\nconst vec3 _FacePosition = vec3(0, -0.01, 0.05) ;\nconst vec3 _FaceSize = vec3(0.038, 0.05, 0.03) ;\nconst vec3 _UpperLeftLegA = vec3(-0.02, -0.37, 0.01) ;\nconst vec3 _UpperLeftLegB = vec3(-0.02, -0.67, -0.059999) ;\nconst vec3 _UpperLeftLegParams = vec3(0.026, 1, 1) ;\nconst vec3 _LowerLeftLegA = vec3(-0.02, -0.67, -0.059999) ;\nconst vec3 _LowerLeftLegB = vec3(-0.02, -0.77, 0.12) ;\nconst vec3 _LowerLeftLegParams = vec3(0.028, 0.03, 0.01) ;\nconst vec3 _UpperRightLegA = vec3(0.07, -0.5, 0.02) ;\nconst vec3 _UpperRightLegB = vec3(0.07, -0.61, 0.09) ;\nconst vec3 _UpperRightLegParams = vec3(0.026, 1, 1) ;\nconst vec3 _LowerRightLegA = vec3(0.07, -0.61, 0.09) ;\nconst vec3 _LowerRightLegB = vec3(0.07, -0.91, 0.22) ;\nconst vec3 _LowerRightLegParams = vec3(0.028, 0.03, 0.01) ;\nconst vec3 _BodyPos = vec3(0, -0.45, -0.03) ;\nconst vec3 _CharacterTrailOffset = vec3(0.72, 0.01, 0.06) ;\nconst vec3 _CharacterTrailScale = vec3(0.001, 0, 0.5) ;\nconst vec3 _CharacterTrailWave = vec3(1.97, 0, 0.34) ;\nconst vec2 _CharacterHeightTerrainMix = vec2(1.95, -30) ;\nconst vec3 _CloudNoiseStrength = vec3(0.2, 0.16, 0.1) ;\nconst vec3 _FrontCloudsPos = vec3(9.91, 8.6, -12.88) ;\nconst vec3 _FrontCloudsOffsetA = vec3(-9.1, 3.04, 0) ;\nconst vec3 _FrontCloudsOffsetB = vec3(-2.97, 3.72, -0.05) ;\nconst vec3 _FrontCloudParams = vec3(5.02, 3.79, 5) ;\nconst vec3 _FrontCloudParamsA = vec3(3.04, 0.16, 2) ;\nconst vec3 _FrontCloudParamsB = vec3(1.34, 0.3, 3.15) ;\nconst vec3 _BackCloudsPos = vec3(29.99, 13.61, -18.8) ;\nconst vec3 _BackCloudsOffsetA = vec3(24.87, -1.49, 0) ;\nconst vec3 _BackCloudParams = vec3(7.12, 4.26, 1.68) ;\nconst vec3 _BackCloudParamsA = vec3(6.37, 2.23, 2.07) ;\nconst vec3 _PlaneParams = vec3(7.64, 10.85, 3.76) ;\nconst vec3 _CloudGlobalParams = vec3(0.123, 2.1, 0.5) ;\nconst vec3 _CloudBackGlobalParams = vec3(0.16, 1.4, -0.01) ;\nconst vec3 _CloudNormalMod = vec3(0.26, -0.13, 1.22) ;\nconst float _CloudSpecPower = 24.04000 ;\nconst float _CloudPyramidDistance = 0.14500 ;\nconst vec3 _TombPosition = vec3(5, 5, 9.28) ;\nconst vec3 _TombScale = vec3(0.07, 0.5, 0.006) ;\nconst vec3 _TombBevelParams = vec3(0.44, 0.66, 0.01) ;\nconst float _TombRepScale = 0.79000 ;\nconst vec3 _TombCutOutScale = vec3(0.39, 0.06, -14.92) ;\nconst vec3 _TombScarfOffset = vec3(0, 0.46, 0) ;\nconst vec3 _TombScarfWindParams = vec3(-1.61, 6, 0.05) ;\nconst vec3 _TombScarfScale = vec3(0.03, 0.002, 0.5) ;\nconst float _TombScarfRot = -0.88000 ;\nconst mat4 _TombScarfMat = mat4( 0.9362437, 0, -0.3513514, 0, \n0, 1, 0, 0, \n0.3513514, 0, 0.9362437, 0, \n0, 0, 0, 1 ) ;\nconst vec3 _PyramidPos = vec3(0, 10.9, -50) ;\nconst vec3 _PyramidScale = vec3(34.1, 24.9, 18) ;\nconst vec3 _PrismScale = vec3(1, 1.9, 1) ;\nconst vec3 _PyramidNoisePrams = vec3(1.5, 1, 1) ;\nconst vec3 _PrismEyeScale = vec3(0.7, 1.9, 51.5) ;\nconst vec3 _PyramidEyeOffset = vec3(2.0, -4.9, 0) ;\nconst float _PrismEyeWidth = 5.86000 ;\nconst float _TerrainMaxDistance = 30.04000 ;\nconst float _SmallDetailStrength = 0.00600 ;\nconst vec3 _SmallWaveDetail = vec3(3.19, 16, 6.05) ;\nconst vec2 _WindSpeed = vec2(2, 0.6) ;\nconst float _MediumDetailStrength = 0.05000 ;\nconst vec2 _MediumWaveDetail = vec2(2, 50) ;\nconst vec3 _MediumWaveOffset = vec3(0.3, -2, 0.1) ;\nconst vec2 _LargeWaveDetail = vec2(0.25, 0.73) ;\nconst vec3 _LargeWavePowStre = vec3(0.6, 2.96, -2.08) ;\nconst vec3 _LargeWaveOffset = vec3(-3.65, 4.41, -11.64) ;\nconst vec3 _FlyingHelperPos = vec3(2.15, 4.68, 14.4) ;\nconst vec3 _FlyingHelperScale = vec3(0.25, 0.001, 0.3) ;\nconst vec3 _FlyingHelperMovement = vec3(0.44, 1.44, -2.98) ;\nconst vec3 _FlyingHelperScarfScale = vec3(0.1, 0.001, 1.5) ;\nconst vec3 _FlyingHelperScarfWindParams = vec3(-0.06, 0.31, 0.47) ;\nconst vec3 _FlyingHelperScarfWindDetailParams = vec3(3.93, 0.005, -45.32) ;\nconst vec3 _FlyingHelperSideScarfOffset = vec3(0.16, -0.01, 0) ;\nconst vec3 _FlyingHelperSideScarfScale = vec3(0.06, 0.001, 0.8) ;\nconst vec4 _FlyingScarfSideWindParams = vec4(2.46, -1.59, -0.05, 0.21) ;\n\n// Material ID definitions\n#define MAT_PYRAMID 1.0\n\n#define MAT_TERRAIN 10.0\n#define MAT_TERRAIN_TRAIL 11.0\n\n#define MAT_BACK_CLOUDS 20.0\n#define MAT_FRONT_CLOUDS 21.0\n\n#define MAT_TOMB 30.0\n#define MAT_TOMB_SCARF 31.0\n\n#define MAT_FLYING_HELPERS 40.0\n#define MAT_FLYING_HELPER_SCARF 41.0\n\n#define MAT_CHARACTER_BASE 50.0\n#define MAT_CHARACTER_MAIN_CLOAK 51.0\n#define MAT_CHARACTER_NECK_SCARF 52.0\n#define MAT_CHARACTER_LONG_SCARF 53.0\n#define MAT_CHARACTER_FACE 54.0\n\n#define TEST_MAT_LESS( a, b ) a < (b + 0.1)\n#define TEST_MAT_GREATER( a, b ) a > (b - 0.1)\n\n//==========================================================================================\n// Primitive functions by IQ\n//==========================================================================================\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length( max( abs(p) - b, 0.0) ) - r;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\n\t\tlength(max(d, 0.0));\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n\t// n must be normalized\n\treturn dot(p, n.xyz) + n.w;\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n//==========================================================================================\n// distance field operations\n//==========================================================================================\nvec2 min_mat( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin_mat( vec2 a, vec2 b, float k, float c )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    float x = mix( b.x, a.x, h ) - k*h*(1.0-h);\n    return vec2( x, ( h < c ) ? b.y : a.y);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n//==========================================================================================\n// Rotations\n//==========================================================================================\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.y;\n    p.y = -s * q.x + c * q.y;\n}\n\n//==========================================================================================\n// Value noise and its derivatives: https://www.shadertoy.com/view/MdX3Rr\n//==========================================================================================\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n#if 0\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n//==========================================================================================\n// Noise function: https://www.shadertoy.com/view/4sfGRH \n//==========================================================================================\nfloat pn(vec3 p) {\n    vec3 i = floor(p); \n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);   \n\treturn mix(a.x, a.y, f.z);\n}\n\n//==========================================================================================\n// Sin Wave approximation http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\n//==========================================================================================\nvec4  SmoothCurve( vec4 x ) {  \n  return x * x * ( 3.0 - 2.0 * x );  \n}\n\nvec4 TriangleWave( vec4 x ) {  \n  return abs( fract( x + 0.5 ) * 2.0 - 1.0 );  \n}\n\nvec4 SmoothTriangleWave( vec4 x ) {  \n  return SmoothCurve( TriangleWave( x ) );  \n}  \n\nfloat SmoothTriangleWave( float x )\n{\n  return SmoothCurve( TriangleWave( vec4(x,x,x,x) ) ).x;  \n}  \n\nvoid Bend(inout vec3 vPos, vec2 vWind, float fBendScale)\n{\n\tfloat fLength = length(vPos);\n\tfloat fBF = vPos.y * fBendScale;  \n\tfBF += 1.0;  \n\tfBF *= fBF;  \n\tfBF = fBF * fBF - fBF;  \n\tvec3 vNewPos = vPos;  \n\tvNewPos.xz += vWind.xy * fBF;  \n\tvPos.xyz = normalize(vNewPos.xyz)* fLength;  \n}\n\n//==========================================================================================\n// Modified cone versions for scarf and main cloak\n//==========================================================================================\nfloat sdScarfCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = (p.y - h);\n    float si = 0.5*(r1-r2)/h;\n    p.z = mix(p.z, p.z * 0.2, q);\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nvec2 sdCloakCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = (p.y - h);\n    r2 = (q * r2) + 0.08;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), q);\n}\n\n//==========================================================================================\n// Character\n//==========================================================================================\nvec3 headScarfMatUVW;\nfloat sdHeadScarf(vec3 pos)\n{\n\t\n    vec3 headScarfPos = pos - _HeadScarfPosition;\n    rX( headScarfPos, _HeadScarfRotation );\n\n    float distanceToTop =  min(0.0,(pos.y + 0.01));\n\n    // Put a slight twist in the middle. Gives the feel that the head scarf\n    // is sitting on shoulders. Very subtle, but I can see it :D\n    float midBend = abs( fract( distanceToTop + 0.5 ) * 2.0 - 1.0 );\n    headScarfPos.x += (cos( 2.0 + headScarfPos.y * 50.0 ) * 0.05 * midBend);\n    headScarfPos.z += (sin( 2.0 + headScarfPos.y * 50.0 ) * 0.03 * midBend);\n\n    // Apply wind to head Scarf    \n    headScarfPos += SmoothTriangleWave(vec4(pos.xyz * 5.0+ iTime,1.0) ).xyz * 0.05 * distanceToTop;\n\n    // Scarf shape    \n    float headScarf = sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z );\n    headScarf = max(headScarf, -sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z - 0.011));\n    \n    // Cut out the bottom of the head scarf. I have no idea what I was thinking, when I wrote this\n    vec3 cutOutPos = headScarfPos - vec3( 0.0, 0.08, 0.0);\n    vec3 r = vec3(0.12, 0.8, 0.2);\n    float smallestSize = min(min(r.x,r.y),r.z);\n\tvec3 dp = cutOutPos/r;\n    float h = min(1.0, abs(1.0 - abs(dp.y)) );\n\n    // Apply some crazy power until it looks like a scarf sitting on shoulders\n    h =  pow(h, 5.5);\n    \n    float rad = h ;\n    float d = length( cutOutPos/r );\n    \n    float cutOut = (d - rad) * smallestSize;\n    headScarf\t= max(headScarf, cutOut);\n\n    // material information\n    float materialVal = 1.0 - pow(d - rad, 0.02);\n\theadScarfMatUVW = smoothstep( -1.0, 1.0, materialVal / _HeadScarfScale);\n\n\t// Chop the top off, to make room for head\n    vec3 headPos = pos - vec3(0.0, 0.25, 0.0);\n    float head   = sdBox(headPos, vec3(0.2, 0.19, 0.2)); \n    headScarf = max(headScarf, -head);\n    \n    return headScarf;\n}\nvec3 mainCloakMatUVW;\nfloat sdMainCloak(vec3 pos)\n{\n    vec3 cloakPos = pos - _MainClothPosition;\n    float q =  min(0.0,(cloakPos.y + 0.05));\n    rX( cloakPos, _MainClothRotation );\n    \n    // Apply detailing\n    cloakPos += SmoothTriangleWave(vec4(pos.xyz * _MainClothDetail.x + iTime,1.0) ).xyz * _MainClothDetail.y * q;\n    \n    // Add main Wind direction\n    Bend(cloakPos, _WindDirection.xy, _MainClothDetail.z);\n    \n    vec2 cloak = sdCloakCone( cloakPos, _MainClothScale.y, _MainClothScale.x, _MainClothScale.z);\n    // Cut out the internals of the cloak\n    cloak.x = max( cloak.x, -sdCloakCone( cloakPos, _MainClothScale.y * 1.05, _MainClothScale.x * 0.95, _MainClothScale.z * 1.01).x);\n\n    // UV Information\n    mainCloakMatUVW = smoothstep( -1.0, 1.0, cloakPos / _MainClothScale);\n\n    // Cut out the top section\n    vec3 headPos = cloakPos - vec3(0.0, 0.69, 0.0);\n    float head   = sdBox(headPos, vec3(0.2, 0.67, 0.2)); \n\tcloak.x = max(cloak.x, -head);\n    \n    // Cut the bottom\n    float bottomCut   = sdPlane(cloakPos - _MainClothBotCutPos); \n    cloak.x = max(cloak.x, -bottomCut);\n    \n    return cloak.x;\n}\n\nfloat earWigs(in vec3 pos) \n{   \n\t// Symmetrical ear wigs. Is that even a word... Ear Wigs!\n    pos.x = abs(pos.x);\n\n    vec2  earWig = sdSegment( pos, vec3(0.02, 0.11, 0.0), vec3(0.07, 0.16, 0.05));\n    float ear  = earWig.x - 0.026  + (earWig.y * 0.03);\n    return ear;\n}\n\n\nfloat sdHead( vec3 pos )\n{\n    vec3 headPos = pos - _HeadPos;\n\n    // Slight tilt\n    rY(headPos, _HeadRotationY ); // 1.2\n    rX(headPos, _HeadRotationX );\n\n    float head = sdCylinder( headPos, vec2(0.05, 0.13) );\n    head = smin(earWigs(headPos), head, 0.04 );\n    return head;\n}\n\nvec3 longScarfMatUVW;\nfloat sdScarf(vec3 pos) \n{\n    vec3 scarfPos = pos - _LongScarfPos;\n    vec3 scale \t= _LongScarfScale;\n\n\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.04);\n    scarfPos.x += (sin( scarfPos.z * _LongScarfWindStrength.x + iTime ) * 0.1 * distanceToPoint);\n    scarfPos.y += (sin( scarfPos.z * _LongScarfWindStrength.y + iTime ) * 0.1 * distanceToPoint);\n\n    // Apply detailing\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _LongScarfWindStrength.z + iTime,1.0) ).xyz * _LongScarfWindStrength.w * distanceToPoint;\n\n    // Essentially a box pivoted at a specific point\n    vec3 scarfOffset = vec3(0.0, 0.0, -scale.y);\n\n    rX(scarfPos, _LongScarfRotX) ;\n    float scarf = sdBox(scarfPos - scarfOffset.xzy , scale);\n\n    longScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos - scarfOffset.xzy ) / scale);\n\n    return max(scarf, sdSphere( scarfPos, _LongScarfMaxRad ));\n}\n\nfloat sdLegs( in vec3 pos  )\n{\n    vec2  upperLeftLeg = sdSegment( pos, _UpperLeftLegA, _UpperLeftLegB );\n    float leftLeg  = upperLeftLeg.x - _UpperLeftLegParams.x;\n    vec2 lowerLeftLeg = sdSegment( pos, _LowerLeftLegA, _LowerLeftLegB );\n    leftLeg  = smin( leftLeg, lowerLeftLeg.x - _LowerLeftLegParams.x + (lowerLeftLeg.y * _LowerLeftLegParams.y), _LowerLeftLegParams.z);\n\n    // cut bottom of left leg otherwise looks nasty with harsh tip\n    leftLeg = max( leftLeg, -(length( pos - _LowerLeftLegB) - 0.06 ) );\n\n    vec2  upperRightLeg = sdSegment( pos, _UpperRightLegA, _UpperRightLegB );\n    float rightLeg  = upperRightLeg.x - _UpperRightLegParams.x;\n    vec2 lowerRightLeg = sdSegment( pos, _LowerRightLegA, _LowerRightLegB );\n    rightLeg  = smin( rightLeg, lowerRightLeg.x - _LowerRightLegParams.x + (lowerRightLeg.y * _LowerRightLegParams.y), _LowerRightLegParams.z);\n\n    return min( leftLeg, rightLeg );\n}\n\nvec2 sdFace( vec3 pos, vec2 currentDistance )\n{\n    vec3 headPos = pos - vec3(0.0, -0.05, 0.0);\n    rX( headPos, _HeadRotationX );\n    rY(headPos, _HeadRotationY );\n\n    // head hole - Fire in the hole!    \n    // OK this does not look right. Actually looks like there was \"fire in the hole\" for \n    // the poor travellers face. Need to come back to it one day and finish it. Maybe!\n    vec3 headHole = headPos - vec3(0.0, 0.1, -0.07);\n    float hole = sdEllipsoid( headHole,vec3(0.05, 0.03, 0.04) );\n    hole  = smin ( hole, sdEllipsoid( headHole - vec3(0.0, -0.03, 0.0), vec3(0.03,0.03, 0.04)), 0.05 );\n\n    // Cut it OUT!\n    float character =  smax( currentDistance.x, -hole, 0.001);\n\n    // face. Meh just an ellipsoid. Need to add eyes and bandana\n    float face = sdEllipsoid( headHole - _FacePosition.xyz, _FaceSize );\n    return smin_mat( vec2(face, MAT_CHARACTER_FACE), vec2(character,currentDistance.y), 0.01, 0.2 );\n}\n\nvec2 sdCharacter( vec3 pos )\n{\n    // Now we are in character space - Booo YA! - I never ever say Boooo YA!. Peter Pimley \n    // says that. Peter: have you been putting comments in my code?\n    pos -= _CharacterPosition;\n    vec3 scale = _CharacterScale;\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\n    \n    rY(pos, _CharacterRotation);\n\n    pos /= scale;\n\n    float mainCloak = sdMainCloak( pos );\n    vec2  mainCloakMat = vec2(mainCloak, MAT_CHARACTER_MAIN_CLOAK );\n\n    float headScarf = sdHeadScarf(pos);\n    vec2  headScarfMat = vec2(headScarf, MAT_CHARACTER_NECK_SCARF );\n\n    float longScarf = sdScarf(pos);\n    vec2  longScarfMat = vec2( longScarf, MAT_CHARACTER_LONG_SCARF );\n    headScarfMat = smin_mat( headScarfMat, longScarfMat, 0.02, 0.1 );\n\n    float head      = sdHead( pos );\n    vec2  headMat\t= vec2( head, MAT_CHARACTER_BASE );\n    headScarfMat    = smin_mat(headScarfMat, headMat, 0.05, 0.75);\n\n    vec2  characterMat = min_mat(mainCloakMat, headScarfMat); \n    characterMat = sdFace( pos, characterMat );\n\n    vec2 legsMat = vec2( sdLegs(pos), MAT_CHARACTER_BASE );\n    characterMat = min_mat( characterMat, legsMat );\n\n    // chope the bottom. This is to chop the bottom of right leg. Though\n    // I have positioned the character so that the right leg is hidden by terrain. \n    // Commenting it out for now\n//    characterMat.x = max( characterMat.x, -sdPlane( pos - vec3(0.0, -0.85, 0.0) ) );\n    characterMat.x *= scaleMul;\n\n\n    return characterMat;\n}\n\n//==========================================================================================\n// Clouds\n//==========================================================================================\nfloat sdCloud( in vec3 pos, vec3 cloudPos, float rad, float spread, float phaseOffset, vec3 globalParams)\n{ \n\t// Clouds are simple. A bunch of spheres with varying phase offset, size and \n\t// frequency values. They are also scaled along the z-Axis so more like circles\n\t// than spheres. With additional noise to make them look fluffy. \n\t// While rendering them we \"perturb\" #SpellCheck the normals to get strong specular\n\t// highlights\n\n\t// Add noise to the clouds\n\tpos += pn( pos ) * _CloudNoiseStrength;\n\tpos = pos - cloudPos;\n\n\t// Make us 2d-ish - My artists have confirmed me: 2D is COOL!\n\tpos.z /= globalParams.x;\n\n\t// Repeat the space\n\tfloat repitition = rad * 2.0 + spread;\n\tvec3  repSpace = pos - mod( pos - repitition * 0.5, repitition);\n\n\t// Create the overall shape to create clouds on\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.23  )  * globalParams.y ;\n\n\t// Creates clouds with offset on the main path\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.9 ) * globalParams.z;\n\n\t// repeated spheres\n\tpos.x = fract( (pos.x + repitition * 0.5) / repitition ) * repitition - repitition * 0.5;\n\n\t// return the spheres  \n\tfloat sphere = length(pos)- rad;\n\treturn sphere * globalParams.x;\n}\n\nvec2 sdClouds( in vec3 pos )\n{\n\t// Two layers of clouds. A layer in front of the big pyramid\n    float c1 = sdCloud( pos, _FrontCloudsPos, _FrontCloudParams.x, _FrontCloudParams.y, _FrontCloudParams.z, _CloudGlobalParams );\n    float c2 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetA, _FrontCloudParamsA.x, _FrontCloudParamsA.y, _FrontCloudParamsA.z, _CloudGlobalParams );\n    float c3 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetB, _FrontCloudParamsB.x, _FrontCloudParamsB.y, _FrontCloudParamsB.z, _CloudGlobalParams);\n    float frontClouds = min(c3, min(c1, c2));\n\n    // This plane hides the empty spaces between the front cloud spheres. Not needed\n    // for back spheres, they are covered by front spheres\n  \tfloat mainPlane = length(pos.z - _FrontCloudsPos.z) / _CloudGlobalParams.x + (pos.y - _PlaneParams.y  + sin(_PlaneParams.x + pos.x * 0.23 ) * _PlaneParams.z);// - rad;\n  \tfrontClouds = min(mainPlane * _CloudGlobalParams.x, frontClouds);\n\n\t// Second layer behind the big Pyramid\n    float c4 = sdCloud( pos, _BackCloudsPos, _BackCloudParams.x, _BackCloudParams.y, _BackCloudParams.z, _CloudBackGlobalParams );\n    float c5 = sdCloud( pos, _BackCloudsPos + _BackCloudsOffsetA, _BackCloudParamsA.x, _BackCloudParamsA.y, _BackCloudParamsA.z, _CloudBackGlobalParams );\n    float backClouds = min(c4,c5);\n    return min_mat(vec2(frontClouds,MAT_FRONT_CLOUDS), vec2(backClouds,MAT_BACK_CLOUDS));\n}\n\n//==========================================================================================\n// This should really be called Kites. No such thing as Flying Helplers...\n//==========================================================================================\nvec3 helperScarfMatUVW;\nfloat sdHelperScarf(vec3 pos, vec3 scarfOffset, vec3 originalPos ) \n{\n    vec3 scarfPos = pos - scarfOffset;\n\n    vec3 scale = _FlyingHelperScarfScale;\n\n    // How far are we from pivot of scarf\n    float distanceToPoint = length(scarfPos );\n\n    // Apply some motion\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _FlyingHelperScarfWindDetailParams.x + iTime,1.0) ).xyz * _FlyingHelperScarfWindDetailParams.y * distanceToPoint;\n\n    vec2 wave;\n    wave.x = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.x  );\n    wave.y = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.z  );\n\n    scarfPos.xy += ( wave * _FlyingHelperScarfWindParams.y * distanceToPoint);\n    vec3  pivotOffset = vec3(0.0, 0.0, scale.z);\n    float scarf = sdBox(scarfPos - pivotOffset, scale);\n\n    // Move us along the z-axis because we chop a sphere in the box. Shows borders otherwise\n    vec3 UVWOffset = vec3(0.0, 0.0, 1.0);\n    helperScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos + UVWOffset - pivotOffset.xzy ) / scale);\n\n    // Two scarf on each side of the big'un\n    pivotOffset.z = _FlyingHelperSideScarfScale.z;\n\n\twave.y = originalPos.x > 0.0 ? wave.y * _FlyingScarfSideWindParams.x : wave.y * _FlyingScarfSideWindParams.y;\n\tscarfPos.xy += scarfPos.x > 0.0 ? wave * _FlyingScarfSideWindParams.z : wave * _FlyingScarfSideWindParams.w;\n\n\t// legit mirroring!\n\tscarfPos.x = -abs(scarfPos.x);\n\tfloat sideScarfs = sdBox(scarfPos - pivotOffset + _FlyingHelperSideScarfOffset, _FlyingHelperSideScarfScale);\n\n\t// Just override the helperScarfMatUVW value for side scarfs. Too tired to create another variable and use that, not too tired\n\t// to write this long comment of no value\n    helperScarfMatUVW = scarf < sideScarfs ? helperScarfMatUVW : smoothstep(-1.0, 1.0, ( scarfPos - pivotOffset + _FlyingHelperSideScarfOffset ) / _FlyingHelperSideScarfScale);\n\n    // Combine'em\n    scarf = min( scarf, sideScarfs );\n    return scarf;\n}\n\nvec2 sdFlyingHelpers( vec3 pos )\n{\n\tvec3 originalPos = pos;\n\tfloat flyingHelper = _DrawDistance;\n\n\t// Using pos.x to determine, whether we are rendering left or right scarf.\n\tvec3 helperPos = _FlyingHelperPos;\n\thelperPos = pos.x > 0.0 ? helperPos - _FlyingHelperMovement : helperPos;\n\n\t// Rest is just mirroring\n\tpos.x = abs(pos.x);\n\tpos = pos - helperPos;\n\n\tfloat helperScarf = sdHelperScarf( pos, vec3(0.0, 0.0, 0.0), originalPos);\n\n\t// Main helper is a box with a cutout sphere at back. In-game it is more sophisticated. But\n\t// I am running out of time. Maybe will do a proper one, one day!\n\tfloat helper = sdBox( pos, _FlyingHelperScale );\n\thelper\t= max( helper, -sdSphere( pos - vec3(0.0, 0.0, _FlyingHelperScale.z ), _FlyingHelperScale.z) );\n\n\t// Material and combine scarf with main body\n\tvec2 helperMat = smin_mat( vec2(helper,MAT_FLYING_HELPERS), vec2(helperScarf,MAT_FLYING_HELPER_SCARF), 0.01, 0.1);\n\thelperScarfMatUVW = helper < helperScarf ? smoothstep(-1.0, 1.0, (pos + vec3(0.0,0.0,_FlyingHelperScale.z*0.5)) / _FlyingHelperScale) : helperScarfMatUVW;\n\n\treturn helperMat;\n}\n\n//==========================================================================================\n// The big mountain in the distance. Again, not a pyramid\n//==========================================================================================\nfloat sdBigMountain( in vec3 pos )\n{\n    float scaleMul = min(_PyramidScale.x, min(_PyramidScale.y, _PyramidScale.z));\n    vec3 posPyramid\t= pos - _PyramidPos;\n\n    // Apply noise derivative, then we can use a blocky looking texture to make the mountain\n    // look edgy (for lack of better word)\n    float derNoise\t\t= sin(noised(posPyramid.xz * _PyramidNoisePrams.x).x) * _PyramidNoisePrams.y;\n    posPyramid.x\t\t= posPyramid.x + derNoise;\n\n    posPyramid /= _PyramidScale;\n    float pyramid = sdTriPrism(  posPyramid, _PrismScale.xy ) * scaleMul;\n\n    // The piercing eye. Which is just an inverted pyrmaid on top of main pyramid.\n    float eyeScale = _PyramidScale.x;\n\n    vec3 posEye = pos;\n    posEye.y = _PrismEyeScale.z - pos.y;\n    posEye.x = pos.x * _PrismEyeWidth;\n\n\tfloat eye = sdTriPrism(  (posEye -_PyramidEyeOffset) / eyeScale, _PrismEyeScale.xy ) * eyeScale;\n\treturn max(pyramid, -eye);\n}\n\n//==========================================================================================\n// Main desert shape\n//==========================================================================================\nfloat sdLargeWaves( in vec3 pos )\n{\n\t// The main shape of terrain. Just sin waves, along X and Z axis, with a power\n\t// curve to make the shape more pointy \n\n    // Manipulate the height as we go in the distance\n    // We want terrain to be a specific way closer to character, showing a path, but the path \n    // gets muddier as wo go in the distance.\n\n    float distZ = abs(pos.z - _CameraPos.z);\n    float distX = abs(pos.x - _CameraPos.x);\n    float dist = (distZ ) + (distX * 0.1);\n    dist = dist * dist * 0.01;\n\n    float detailNoise = noised(pos.xz).x * -2.5; \n\tfloat largeWaves = (sin(_LargeWaveOffset.z + pos.z * _LargeWaveDetail.y + pos.z * 0.02)  \n\t\t\t\t\t  * sin((_LargeWaveOffset.x + dist) + (pos.x * _LargeWaveDetail.x) ) * 0.5) + 0.5;\n    largeWaves = -_LargeWaveOffset.y + pow( largeWaves, _LargeWavePowStre.x) *  _LargeWavePowStre.y - detailNoise * 0.1 ;// - (-pos.z*_LargeWavePowStre.z);// \n\n    // Smoothly merge with the bottom plane of terrain\n    largeWaves = smin(largeWaves, _LargeWavePowStre.z, 0.2);\n    largeWaves = (largeWaves - dist);\n    return largeWaves * 0.9;\n}\n\nfloat sdSmallWaves( in vec3 pos )\n{\n\t// The small waves are used for adding detail to the main shape of terrain\n\tfloat distanceToCharacter = length( pos.xz - _CharacterPosition.xz );\n\n    // movement to give feel of wind blowing\n    float detailNoise = noised(pos.xz).x * _SmallWaveDetail.z; \n\tfloat smallWaves = sin(pos.z * _SmallWaveDetail.y + detailNoise + iTime * _WindSpeed.y ) * \n\t\t\t\t\t   sin(pos.x * _SmallWaveDetail.x + detailNoise + iTime * _WindSpeed.x ) * _SmallDetailStrength;// * min(1.0, distanceToCharacter);\n\t\n\treturn smallWaves * 0.9;\n}\n\nfloat sdTerrain( in vec3 pos)\n{\n\tfloat smallWaves = sdSmallWaves( pos );\n\tfloat largeWaves = sdLargeWaves( pos );\n\n    return (smallWaves + largeWaves);\n}\n\nvec2 sdDesert( in vec3 pos, in float terrain )\n{\n    float distanceToPos = length(pos.xz - _CameraPos.xz);\n    if( distanceToPos > _TerrainMaxDistance)\n        return vec2(_DrawDistance, 0.0);\t\n\n   \tfloat mat = 9.0;//length(pos.xyz) > 9.0 ? 10.0 : 40.0;\n    return vec2( pos.y + terrain, MAT_TERRAIN );\n}\n\n//==========================================================================================\n// Character trail in the sand\n//==========================================================================================\nfloat sdCharacterTrail( vec3 pos, in float terrain )\n{\n\tvec3 trailOffset = (_CharacterPosition);\n\ttrailOffset.yz  += (_CharacterTrailOffset).yz;\n    trailOffset.y = -terrain + _CharacterTrailOffset.y; \n\n    vec3 trailPos = pos - trailOffset;\n    float distanceToPoint = length(trailPos);\n    trailPos.x -= _CharacterTrailOffset.x * distanceToPoint;\n\n    // Make it wavy\n    trailPos.x += (SmoothTriangleWave( trailPos.z * _CharacterTrailWave.x  ) * _CharacterTrailWave.z * distanceToPoint);\n\n    float trail = sdBox(trailPos - vec3(0.0, 0.0, _CharacterTrailScale.z) , _CharacterTrailScale);\n    return trail;\n}\n\n//==========================================================================================\n// The tombs\n//==========================================================================================\nfloat sdTombScarf(vec3 pos, vec3 scarfOffset, float t ) \n{ \n\t//  scarfs, done same as other scarfs\n\n    vec3 scarfPos = pos - scarfOffset;\n\n    scarfPos =  (mul(  _TombScarfMat, vec4(scarfPos,1.0) )).xyz;\n\n    vec3 scale = _TombScarfScale;\n    scale.z  += (t + 1.0 ) * 0.2;\n\n    // How far are we from pivot of scarf\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.1);\n\n    // Make the scarf thicker as it goes out\n    scale.x += distanceToPoint * 0.04;\n\n    // Apply some motion\n    scarfPos.x += (sin( pos.z * _TombScarfWindParams.x + iTime) * _TombScarfWindParams.z * distanceToPoint);\n    scarfPos.y += (sin( pos.z * _TombScarfWindParams.y + iTime) * _TombScarfWindParams.z * distanceToPoint);\n\n     vec3 pivotOffset = vec3(0.0, 0.0, scale.z);\n    rX(scarfPos, _TombScarfRot + ((t - 0.5)* 0.15) + SmoothTriangleWave((iTime + 1.45) * 0.1) * 0.3 );\n\n    float scarf = sdBox(scarfPos - pivotOffset , scale);\n    return scarf;\n}\n\nvec2 sdTombs( in vec3 p )\n{\n\tvec2 mainTomb = vec2(_DrawDistance, MAT_TOMB);\n\n\t// We draw two tombs, t goes -1 -> 1 so we can use negative and positive values\n\t// to mainpulate them both individually\n\tfor( float t = -1.0; t <= 1.0; t += 2.0 )\n\t{\n\t\tvec3 tombPos = (_TombPosition + vec3(-0.25 * t, t * 0.05, 0.1 * t ));\n\n\t\tvec3 pos = p - tombPos;\n\t\trZ( pos, 0.1 * t );\n\n\t\tfloat tombScarf = sdTombScarf( pos, _TombScarfOffset, t + 1.0);\n\n\t\tpos.x = abs(pos.x);\n\n\t\t// Taper them beyond a certain height. Rest is just a rounded box\n\t\tpos.x += abs( pos.y > _TombBevelParams.x  ? (pos.y - _TombBevelParams.x) * _TombBevelParams.y: 0.0 );\n\t\tfloat tTomb = sdRoundBox( pos, _TombScale, _TombBevelParams.z);\n\n\t\t// Cut out a sphere at top\n\t\ttTomb = max( tTomb, -sdSphere( pos - vec3(0.0, _TombCutOutScale.x, 0.0), _TombCutOutScale.y ) );\n\n\t\t// create scarfs at cut off points\n\t\tvec2 tTombMat = min_mat( vec2(tTomb, MAT_TOMB), vec2(tombScarf, MAT_TOMB_SCARF));\n\t\tmainTomb = min_mat( mainTomb, tTombMat);\n\t}\n\treturn mainTomb;\n}\n\n//==========================================================================================\n// The main map function\n//==========================================================================================\nvec2 map( in vec3 pos )\n{\n\tvec2 character = sdCharacter(pos);\n\tvec2 res = character;\n\n\t// I am assuming that since character covers a large portion of screen\n\t// This early out should help and same with the terrain. Assumption only, \n\t// need to look into it \n    if( res.x > 0.01 )\n    {\n    \tfloat desert = sdTerrain(pos);\n\t    vec2 terrain   = sdDesert( pos, desert );\n\t    vec2 trail\t   = vec2(-sdCharacterTrail(pos, desert), MAT_TERRAIN_TRAIL );\n\t    terrain.y\t\t= terrain.x > trail.x ? terrain.y : trail.y;\n\t\tterrain.x\t\t= smax( terrain.x, trail.x, 0.05);\n\n\t\tres\t= min_mat( res, terrain); \n        if( terrain.x > 0.01 )\n        {\n\t\t\tvec2 tombs\t   =  sdTombs(pos);\n            res = smin_mat( res, tombs, 0.2, 0.15 );\n\n            vec2 pyramid   = vec2(sdBigMountain(pos), MAT_PYRAMID);\n            res = min_mat( res, pyramid );\n\n            vec2 clouds\t   = sdClouds(pos);\n            res = min_mat( res, clouds );\n\n            vec2 flyingHelpers = sdFlyingHelpers( pos );\n            res = min_mat( res, flyingHelpers );\n        }\n\t}\n    return res;\n}\n\n\n//==========================================================================================\n// Used for generating normals. As it turns out that only the big mountain doesn't need\n// normals. Everything else does. Hey Ho!\n//==========================================================================================\nvec2 mapSimple( in vec3 pos )\n{\n\treturn map( pos );\n\t/*\n    vec2 character = sdCharacter(pos);\n    vec2 flyingHelpers = vec2( sdFlyingHelpers( pos ), 50.0 );\n    vec2 clouds\t   = sdClouds(pos);\n   \tfloat desert   = sdTerrain(pos);\n    vec2 terrain   = sdDesert( pos, desert );\n    terrain.x = smax( terrain.x, -sdCharacterTrail(pos, desert), 0.1 );\n    vec2 tombs\t   =  vec2(sdTombs(pos), 50.0);\n\n    vec2 res = character;\n    min_mat( res, flyingHelpers );\n\tres = min_mat( res, clouds );\n    res\t= min_mat( res, terrain); \n    res\t= min_mat( res, flyingHelpers); \n    res = smin_mat( res, tombs, 0.2, 0.15 );\n    return res;\n    */\n}\n\n//==========================================================================================\n// Raycasting: https://www.shadertoy.com/view/Xds3zN\n//==========================================================================================\nvec3 castRay(vec3 ro, vec3 rd) \n{\n    float tmin = 0.1;\n    float tmax = _DrawDistance;\n   \n    float t = tmin;\n    float m = -1.0;\n    float p = 0.0;\n    float maxSteps = _MaxSteps;\n    float j = 0.0;\n    for( float i = 0.0; i < _MaxSteps; i += 1.0 )\n    {\n        j = i;\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) \n        \tbreak;\n        t += res.x;\n\t    m = res.y;\n    }\n\tp = j / maxSteps;\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m, p );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*mapSimple( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*mapSimple( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*mapSimple( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*mapSimple( pos + e.xxx ).x );\n}\n\n//==========================================================================================\n// Ambient Occlusion, only applied to the Traveller\n//==========================================================================================\nfloat AmbientOcclusion(vec3 p, vec3 N, float stepSize, float k)\n{\n    float r = 0.0;\n    float t = 0.0;\n  \n    for(int i = 0; i < 2; i++)\n    {\n        t += stepSize;\n        r += (1.0 / pow(2.0, t)) * (t - sdCharacter(p + (N * t)).x);\n    }\n    return max(0.0, 1.0 - (k * r));\n}\n\n//==========================================================================================\n// Simplified version of Traveller for shadow casting\n//==========================================================================================\nfloat sdCharacterShadow( vec3 pos )\n{\n    pos -= _CharacterPosition;\n    vec3 scale = _CharacterScale;\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\n    \n    rY(pos, _CharacterRotation);\n\n    pos /= scale;\n\n    float mainCloak = sdMainCloak( pos );\n    float longScarf = sdScarf(pos);\n\n    return min( mainCloak, longScarf) * scaleMul;\n}\n\n//==========================================================================================\n// Only character, flying helpers and tombs cast shadows. Only terrain recieves shadows\n//==========================================================================================\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 100; ++i)\n    {\n        if (t >= maxt) {\n            break;\n        }\n    \tfloat flyingHelpers = sdFlyingHelpers( ro + rd * t).x;\n    \tfloat tombs = sdTombs( ro + rd * t ).x;\n        float h = min( sdCharacterShadow( ro + rd*t), min(flyingHelpers, tombs) );\n        if( h<0.001 )\n            return 0.1;\n        res = min( res, k*h/t );\n        t += h;\n    }\n\treturn res;\n}\n\n//==========================================================================================\n// Hi Hussain!\n// Again, somebody wrote Hi Hussain here. It wasn't me, but hi back atcha!\n// Sky\n//==========================================================================================\nvec3 sky( vec3 ro, vec3 rd )\n{\n    // Sun calculation\n    float sunDistance = length( _SunPosition );\n\n    vec3 delta = _SunPosition.xyz - (ro + rd * sunDistance);\n    float dist \t= length(delta);\n\n    // Turn Sun into a star, because the big mountain has a star like shape\n    // coming from top\n    delta.xy *= _SunStar.xy;\n    float sunDist = length(delta);\n    float spot = 1.0 - smoothstep(0.0, _SunSize, sunDist);\n    vec3 sun = clamp(_SunScale * spot * spot * spot, 0.0, 1.0) * _SunColor.rgb;\n\t\n\t// Changing color on bases of distance from Sun. To get a strong halo around\n\t// the sun\n   \tfloat expDist = clamp((dist - _ExposureOffset)  * _ExposureStrength, 0.0, 1.0);\n   \tfloat expControl = pow(expDist,_ExposurePower);\n\n    // Sky colors\n    float y = rd.y;\n    float zen = 1.0 - pow (min (1.0, 1.0 - y), _ZenithFallOff);\n    vec3 zenithColor\t= _Zenith.rgb  * zen;\n    zenithColor = mix( _SunColor.rgb, zenithColor, expControl );\n\n    float nad = 1.0 - pow (min (1.0, 1.0 + y), _NadirFallOff);\n    vec3 nadirColor\t= _Nadir.rgb * nad;\n\n    float hor = 1.0 - zen - nad;\n    vec3 horizonColor\t= _Horizon.rgb * hor;\n\n    // Add stars for Color Scheme 3\nfloat stars  = 0.0;\n#if COLOR_SCHEME == 3\n    vec3 starPos = ro + ( (rd + vec3(iTime * 0.001, 0.0, 0.0) ) * sunDistance);\n    starPos.xyz += iTime*0.01 + noised(starPos.xy) * 3.0;\n\n    starPos      = mod( starPos, 1.5) - 0.75;\n    stars  \t\t = length(starPos);\n\n\tfloat starsA \t= (step( 0.9, 1.0 - stars) * 1.0 - (stars)) * 2.0;\n\tfloat starsB\t= (step( 0.93, 1.0 - stars) * 1.0 - (stars)) * 1.5;\n\tstars = starsA + starsB;\n\n    stars = stars * pow(zen * expControl, 5.0);\n    stars = step( 0.01, stars) * stars * 2.0;\n#endif\n    return stars + (sun * _SunStar.z + zenithColor + horizonColor + nadirColor);\n}\n\n//==========================================================================================\n// The rendering, based on: https://www.shadertoy.com/view/Xds3zN\n//==========================================================================================\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n\t// res.z contains the iteration count / max iterations. This gives kind of a nice glow\n\t// effect around foreground objects. Looks particularly nice on sky, with clouds in\n\t// front and also on terrain. Gives rim kind of look!\n\tvec3 res\t= castRay(ro,rd);\n\tvec3 skyCol = sky( ro, rd );\n\tvec3 col\t= skyCol;\n\n\t#if defined (DEBUG_PERFORMANCE)\n\treturn (res.z);\n\t#endif\n\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tvec3 pos = ro + t*rd;\n\n\t// Return sky\n\tif( m < 0.0 )\n\t{\n\t\t// Bloom for the background clouds. We want Big Mountain to be engulfed with fog. So just chop out\n\t\t// areas around right and left side of BigMountain for creating fake bloom for background clouds by\n\t\t// using the iteration count needed to generate the distance function\n\t\tfloat rightSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(45.0, -5.0, _SunPosition.z));\n\t\tfloat leftSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(-50.0, -5.0, _SunPosition.z));\n\t\tif( rightSideCloudDist < 40.0 )\n\t\t{\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, rightSideCloudDist / 40.0);\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\n\t\t}\n\t\telse if( leftSideCloudDist < 40.0 )\n\t\t{\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, leftSideCloudDist / 40.0);\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\n\t\t}\n        else\n\t\t\treturn col;\n\t}\n\n\tfloat skyFog = 1.0-exp( _FogMul * t * pow(pos.y, _FogPow) );\n\t#if defined (DEBUG_FOG)\n\treturn (skyFog);\n\t#endif\n\n\t// Render the big mountain. Keep track of it's color, so we can use it for transparency for clouds later\n\tvec3 pyramidCol = vec3(0.0, 0.0, 0.0);\n\tpyramidCol\t\t= mix( _PyramidCol, skyCol, skyFog * 0.5  ); \n\n\tif( TEST_MAT_LESS( m, MAT_PYRAMID) )\n\t{\n\t\t// Height fog, with strong fade to sky \n\t\tfloat nh = (pos.y / _PyramidHeightFog.x);\n\t\tnh = nh*nh*nh*nh*nh;\n\t\tfloat heightFog = pow(clamp(1.0 - (nh), 0.0, 1.0), _PyramidHeightFog.y);\n\t\theightFog\t\t= clamp( heightFog, 0.0, 1.0 );\n\t\tpyramidCol\t\t= mix( pyramidCol, skyCol, heightFog ); \n\t\treturn pyramidCol;       \n\t}\n\n\t// Calculate normal after calculating sky and big mountain\n\tvec3 nor = calcNormal(pos);\n\t// Terrain: https://archive.org/details/GDC2013Edwards\n\tif( TEST_MAT_LESS (m, MAT_TERRAIN_TRAIL ) )\n\t{\n\t\tfloat shadow = softShadow( pos - (rd * 0.01), _LightDir.xyz, _TerrainShadowParams.x, _TerrainShadowParams.y, _TerrainShadowParams.z);\n\t\tshadow\t\t = clamp( shadow + _TerrainShadowParams.w, 0.0, 1.0 );\n\n\t\tvec3 shadowCol = mix( shadow * _TerrainShadowColor, _TerrainDistanceShadowColor, pow(skyFog, _TerrainFogPower * _TerrainDistanceShadowPower) );\n\n\t\t// Strong rim lighting\n\t\tfloat rim\t= (1.0 - saturate(dot( nor , -rd ))); \n\t\trim\t\t\t= saturate(pow( rim, _TerrainRimPower)) *_TerrainRimStrength ; \n\t\tvec3 rimColor\t= rim * _TerrainRimColor;\n\n\t\t// Specular highlights\n\t\tvec3 ref\t\t= reflect(rd, nor);\n\t    vec3 halfDir\t= normalize(_LightDir + rd);\n\n\t    // The strong ocean specular highlight\n\t    float mainSpec = clamp( dot( ref, halfDir ), 0.0, 1.0 );\n\t    if ( TEST_MAT_LESS( m, MAT_TERRAIN ) )\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 2.0 ;\n\t    else\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 4.0;\n\n\t    float textureGlitter  = textureLod(iChannel1,pos.xz * _TerrainGlitterRep, 2.2).x * 1.15;\n\t    textureGlitter\t= pow(textureGlitter , _TerrainGlitterPower);\n\t    mainSpec \t\t*= textureGlitter;\n\n\t\t// The glitter around terrain, looks decent based on rim value\n\t    float rimSpec\t= (pow(rim, _TerrainRimSpecPower)) * textureGlitter;\n\t    vec3 specColor\t= (mainSpec + rimSpec) * _TerrainSpecColor;\n\t\tvec3 terrainCol\t= mix( (rimColor + specColor * shadow) + _TerrainCol, skyCol, pow(skyFog, _TerrainFogPower) ) + res.z * 0.2;  \n\n\t\t// maybe add a fake AO from player, just a sphere should do!\n\t\treturn mix( shadowCol, terrainCol, shadow );\n\t}\n\n\t// Clouds\n\tif( TEST_MAT_LESS (m, MAT_FRONT_CLOUDS ) )\n\t{\n\t\t// Modify the normals so that they create strong specular highlights\n\t\t// towards the top edge of clouds\n\t\tnor\t\t\t\t= normalize( nor + _CloudNormalMod);\n\t\tfloat dotProd\t= dot( nor, vec3(1.0,-3.5,1.0) );\n\n\t\tfloat spec\t\t=  1.0 -  clamp( pow(dotProd, _CloudSpecPower), 0.0, 1.0 );\n\t\tspec \t\t\t*= 2.0;\n\t\tvec3 cloudCol\t= spec * _CloudSpecCol + _CloudCol;\n\n\t\t// Transparency for mountain\n\t\tif( sdBigMountain( pos + (rd * t * _CloudPyramidDistance)) < 0.2 )\n\t \t{\n\t \t\tcloudCol = mix( pyramidCol, cloudCol, _CloudTransparencyMul ); \n\t\t}\n\n\t\t// Mixing for backdrop mountains. Backdrop mountains take more color from Sky. Foreground mountains\n\t\t// retain their own color values, so I can adjust their darkness\n\t\tvec3 inCloudCol = mix(cloudCol, _BackCloudCol + skyCol * 0.5 + spec * _BackCloudSpecCol, MAT_FRONT_CLOUDS - m);\n\t\treturn mix( inCloudCol , skyCol, skyFog * _CloudFogStrength );    \n\t}\n\n\t// Tombs\n\tif( TEST_MAT_LESS(m, MAT_TOMB_SCARF ) )\n\t{\n\t\t// Simple strong diffuse\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.0, 0.0, 1.0);\n\t\tvec3 col\t= mix( _TombMainColor, _TombScarfColor * 2.0, m - MAT_TOMB );\n\t\treturn mix( diff * col, skyCol, skyFog);\n\t}\n\n\t// Flying Helpers\n\tif( TEST_MAT_LESS(m, MAT_FLYING_HELPER_SCARF ) )\n\t{\n\t\tfloat fres\t= pow( clamp(1.0+dot(nor,rd) + 0.75,0.0,1.0), _FlyingHelperFrePower ) * _FlyingHelperFreScale;\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.5,0.0,1.0);\n\t\tvec3 col = _FlyingHelperYellowColor;\n\n\t\t// The main head\n\t\tif ( TEST_MAT_LESS( m, MAT_FLYING_HELPERS ) )\n\t\t{\n\t\t\tcol = _FlyingHelperMainColor;\n\n\t\t\t// Yellow borders\n\t\t\tfloat outerBorder = step( 0.95, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tcol  = mix( col * diff, _FlyingHelperYellowColor,  outerBorder );\n\n\t\t\t// cubes in middle\n\t\t\tfloat rectsY = abs(helperScarfMatUVW.z * 2.0 - 1.0);\n\t\t\tfloat rectsX = abs(helperScarfMatUVW.x * 2.0 - 1.0);\n\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\n\t\t\tcircles = step( 0.5, circles );\n\n\t\t\t// Ideally want to do a separate bass for bloom. maybe one day\n\t\t\tfloat bloomCircle = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1); \n\t\t\tfloat bloom  = max( bloomCircle - 0.5, 0.0);\n\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\n\t\t\trectsX = 1.0 - step( 0.5, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tfloat rects = min(rectsX, rectsY);\n\n\t\t\tfloat symbolsX = fract(rects/(helperScarfMatUVW.z * 20.0) * 20.0);\n\t\t\tfloat symbolsY = fract(rects/(helperScarfMatUVW.x * 2.0) * 2.0);\n\t\t\tfloat symbolsZ = fract(rects/((helperScarfMatUVW.z + 0.1) * 16.0) * 16.0);\n\t\t\tfloat symbolsW = fract(rects/((helperScarfMatUVW.x + 0.1) * 3.0) * 3.0);\n\n\t\t\tfloat symbols = symbolsY;\n\t\t\tsymbols = max( symbols, symbolsZ );\n\t\t\tsymbols = min(symbols , max(symbolsX, symbolsW));\n\t\t\tsymbols = step( 0.5, symbols ); \n\n\t\t\tsymbols = min( symbols, circles );\n\n\t\t\t//  float rects = min(rectsX, max(circles,rectsY));\n\n\t\t\tcol = mix( col, _FlyingHelperYellowColor, circles);\n\t\t\tcol = mix( col, _FlyingHelperWhiteColor * 2.0, symbols)  + bloom  * _FlyingHelperBloomScale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// The scarfs, just have a yellow border\n\t\t\tfloat outerBorder = step( 0.9, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tcol \t= mix( _FlyingHelperMainColor * diff, _FlyingHelperYellowColor,  outerBorder );\n\t\t}\n\t\treturn mix( fres * col, skyCol, skyFog * _FlyingHelperFogScale );\n\t}\n\n\t// Character\n\tif( TEST_MAT_GREATER (m, MAT_CHARACTER_BASE ) )\n\t{\n\t\tfloat diff = _CharacterDiffScale * clamp( dot( nor, _LightDir ), 0.0, 1.0 );\n\n\t\t// Why did I fudge these normals, I can't remember. It does look good though, so keep it :)\n\t\tnor\t\t= normalize( nor + vec3(0.3,-0.1,1.0));\n\t\tnor.y\t*= 0.3;\n\n\t\tfloat fres\t= pow( clamp( 1.0 + dot(nor,rd) + 0.75, 0.0, 1.0), _CharacterFrePower ) * _CharacterFreScale;\n\t\tvec3 col\t= _CharacterMainColor;\n\n\t\t// Just base color\n\t\tif( TEST_MAT_LESS( m, MAT_CHARACTER_BASE) )\n\t\t{\n\t\t\t// Add sand fade to legs. Mixing terrain color at bottom of legs\n\t\t\tfloat heightTerrainMix\t= pow((pos.y / _CharacterHeightTerrainMix.x), _CharacterHeightTerrainMix.y);\n\t\t\theightTerrainMix\t\t= clamp( heightTerrainMix, 0.0, 1.0 );\n\t\t\tcol\t= mix( _CharacterMainColor, _CharacterTerrainCol, heightTerrainMix );\n\t\t}\n\t\t// Main Cloak\n\t\telse if( TEST_MAT_LESS( m,MAT_CHARACTER_MAIN_CLOAK) )\n\t\t{\n\t\t\t// Cone kind of shapes\n\t\t\tfloat rectsX\t= fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 7.0) ;\n\t\t\trectsX\t\t\t= abs(rectsX * 2.0 - 1.0);\n\t\t\tfloat rects\t\t= rectsX;\n\t\t\trects\t\t\t= step( 0.5, rects * (1.0 - mainCloakMatUVW.y*3.5) );\n\t\t\tcol = mix( col, _CharacterCloakDarkColor, rects );\n\n\t\t\t// Yellow borders, two lines\n\t\t\tfloat outerBorder\t\t= step( 0.915, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\t\t\tfloat betweenBorders\t= step( 0.88, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\t\t\tfloat innerBorder\t\t= step( 0.87, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\n\t\t\tinnerBorder = min( innerBorder, 1.0 - betweenBorders );\n\n\t\t\tcol  = mix( col, _CharacterCloakDarkColor,  betweenBorders );\n\t\t\tcol  = mix( col, _CharacterYellowColor,  outerBorder );\n\t\t\tcol  = mix( col, _CharacterYellowColor,  innerBorder);\n\n\t\t\t// The verticle cubes/lines running across the bottom of cloak\n\t\t\tfloat cubes = abs(fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 10.0)  * 2.0 - 1.0);\n\t\t\tcubes\t\t= min(betweenBorders, step( 0.9, cubes) );\n\t\t\tcol\t\t\t= mix( col, _CharacterYellowColor,  cubes);\n\t\t}\n\t\t// headscarf\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_NECK_SCARF) )\n\t\t{\n\t\t\tcol = mix( col, _CharacterYellowColor, step( 0.7, headScarfMatUVW.y) );\n\t\t}\n\t\t// Long Scarf\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_LONG_SCARF) )\n\t\t{\n\t\t\tcol = _CharacterYellowColor;\n\n\t\t\t// Yellow borders, two lines\n\t\t\tfloat outerBorder = step( 0.9, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tfloat innerBorder = step( 0.7, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tinnerBorder = min( innerBorder, 1.0 - step( 0.8, abs(longScarfMatUVW.x * 2.0 - 1.0) ) );\n\n\t\t\t// Mix borders\n\t\t\tcol  = mix( col, _CharacterMainColor,  outerBorder );\n\t\t\tcol  = mix( col, _CharacterMainColor,  innerBorder);\n\n\t\t\t// cubes in middle\n\t\t\tfloat rectsY = abs(fract( longScarfMatUVW.y/ 0.10 ) * 2.0 - 1.0);// - 0.5 * 0.10;\n\t\t\tfloat rectsX = abs(longScarfMatUVW.x * 2.0 - 1.0);\n\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\n\t\t\tcircles = step( 0.5, circles );\n\n\t\t\tfloat bloomCircle\t= 1.0 - (length( vec2(rectsY, rectsX * 0.7) ) - 0.1); \n\t\t\tfloat bloom \t\t= max( bloomCircle - 0.45, 0.0);\n\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\n\t\t\trectsX = 1.0 - step( 0.5, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tfloat rects = min(rectsX, rectsY);\n\n\t\t\t// There are better ways of doing symbols. Spend some time on it, buddy!\n\t\t\tfloat symbolsX = fract(rects/(longScarfMatUVW.y * 0.17) * 10.0);\n\t\t\tfloat symbolsY = fract(rects/(longScarfMatUVW.x * 18.5) * 10.0);\n\n\t\t\tfloat symbols\t= symbolsX;\n\t\t\tsymbols\t\t\t= max( symbols, symbolsY );\n\t\t\tsymbols\t\t\t= step( 0.5, symbols ); \n\n\t\t\tsymbols = min( symbols, circles );\n\n\t\t\t//        float rects = min(rectsX, max(circles,rectsY));\n\t\t\tcol = mix( col, _CharacterMainColor, circles);\n\t\t\tcol = mix( col, _CharacterWhiteColor * 2.0, symbols)  + bloom * _CharacterBloomScale;\n\n\t\t\t// White glow and disintegrating the scarf, showing depleting scarf energy. Needs bloom effect :(\n\t\t\tcol = mix( col, _CharacterMainColor, 1.0 - smoothstep(0.4, 0.6, longScarfMatUVW.y));\n\t\t\tvec3 whiteMiddle = mix( col, _CharacterWhiteColor + bloom * _CharacterBloomScale, step(0.48, longScarfMatUVW.y));\n\t\t\tcol = mix( whiteMiddle, col, step(0.5, longScarfMatUVW.y));\n\t\t}\n\t\t// Face\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_FACE)  )\n\t\t{\n\t\t\tcol = vec3(0,0,0);\n\t\t}\n\t\tfloat ao = AmbientOcclusion(pos - (rd * 0.01), nor, _CharacterAOParams.x, _CharacterAOParams.y); \n\t\treturn ao * mix( (fres + diff) * col, skyCol, skyFog * _CharacterFogScale );\n\t}\n\treturn vec3( clamp(col * 0.0,0.0,1.0) );\n}\n\n\nfloat rand(float n)\n{\n\treturn fract(sin(n) * 43758.5453123);\n}\n\nfloat noise(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n    fc = fc*fc*(3.0-2.0*fc);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Move camera using noise. This is probably quite expensive way of doing it :(\n\tfloat unitNoiseX = (noise(iTime * _CameraMovement.w ) * 2.0)  - 1.0;\n\tfloat unitNoiseY = (noise((iTime * _CameraMovement.w ) + 32.0) * 2.0)  -1.0;\n\tfloat unitNoiseZ = (noise((iTime * _CameraMovement.w ) + 48.0) * 2.0)  -1.0;\n\tvec3 ro = _CameraPos + vec3(unitNoiseX, unitNoiseY, unitNoiseZ) * _CameraMovement.xyz;\n\n\n\tvec3 screenRay\t\t= vec3(fragCoord / iResolution.xy, 1.0);\n\tvec2 screenCoord\t= screenRay.xy * 2.0 - 1.0;\n\n\t// Screen ray frustum aligned\n\tscreenRay.xy = screenCoord * _CameraFOV.xy;\n    screenRay.x\t\t\t*= 1.35;\n\tscreenRay.z  = -_CameraFOV.z;\n\tscreenRay /= abs( _CameraFOV.z); \n\n    // In camera space\n\tvec3 rd = normalize(mul( _CameraInvViewMatrix, vec4(screenRay,0.0))).xyz;\n\n\t// Do the render\n\tvec4 col = vec4(render(ro, rd), 0.0);\n\n\t// No it does not need gamma correct or tone mapping or any other effect that you heard about\n\t// and thought was cool. This is not realistic lighting\n\n\t// vignette\n\tfloat vig = pow(1.0 - 0.4 * dot(screenCoord, screenCoord), 0.6) * 1.25;\n\tvig = min( vig, 1.0);\n\tcol *= vig;\n\n\t// Final color\n\tfragColor =  col;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "A version with fake antialiasing added with post processing\nhttps://www.shadertoy.com/view/tsBGzK\nFeel free to copy the changes over",
        "date": "1549335051",
        "username": "JoshScholar",
        "userpicture": "/img/profile.jpg",
        "id": "MtscR8",
        "hidden": 0
      },
      {
        "text": "I'm trying to move the code to unity, Just finished the terrain and sky render:https://drive.google.com/file/d/1A5NOmlVXD2hx9c0SN-Q2mLtekpAK2vBb/view; Thany for your work",
        "date": "1546315058",
        "username": "tachen",
        "userpicture": "/img/profile.jpg",
        "id": "MsjfzK",
        "hidden": 0
      },
      {
        "text": "If nobody told me, I would think this was from the real ps4 game! Did you get all the data from the actual game files??",
        "date": "1539575608",
        "username": "scratch13764",
        "userpicture": "/media/users/scratch13764/profile.png",
        "id": "lsffWB",
        "hidden": 0
      },
      {
        "text": "Amazinggggg",
        "date": "1532842184",
        "username": "leacasas",
        "userpicture": "/img/profile.jpg",
        "id": "Xd2cDt",
        "hidden": 0
      },
      {
        "text": "Featured in this video :) ! [video]http://www.youtube.com/watch?v=7BB8TkY4Aeg[/video]",
        "date": "1532122581",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "XdScW3",
        "hidden": 0
      },
      {
        "text": "This is poetic.\nNice work",
        "date": "1529563379",
        "username": "FlorianDuf",
        "userpicture": "/media/users/FlorianDuf/profile.jpeg",
        "id": "XsByRV",
        "hidden": 0
      },
      {
        "text": "Thank you very much for the kind comments everybody. Means a LOT! :D",
        "date": "1528120238",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "ldjcW1",
        "hidden": 0
      },
      {
        "text": "holy excrement",
        "date": "1526736131",
        "username": "CLPB",
        "userpicture": "/img/profile.jpg",
        "id": "ls2yzD",
        "hidden": 0
      },
      {
        "text": "I wish i could walk around!! this is amazing ",
        "date": "1525418423",
        "username": "akhgary",
        "userpicture": "/img/profile.jpg",
        "id": "ldScRR",
        "hidden": 0
      },
      {
        "text": "I wish i could walk around!! this is amazing ",
        "date": "1525418400",
        "username": "akhgary",
        "userpicture": "/img/profile.jpg",
        "id": "MsByRR",
        "hidden": 0
      },
      {
        "text": "Great stuff. Excellent tribute!",
        "date": "1510838404",
        "username": "ingagard",
        "userpicture": "/img/profile.jpg",
        "id": "lltXRl",
        "hidden": 0
      },
      {
        "text": "big WOW!",
        "date": "1510126354",
        "username": "jcyuan",
        "userpicture": "/img/profile.jpg",
        "id": "4ltXR2",
        "hidden": 0
      },
      {
        "text": "nice",
        "date": "1505807340",
        "username": "DerrickHall",
        "userpicture": "/media/users/DerrickHall/profile.png",
        "id": "XtG3Dy",
        "hidden": 0
      },
      {
        "text": "fantastic job) ",
        "date": "1505219416",
        "username": "MarioNaybor",
        "userpicture": "/img/profile.jpg",
        "id": "ltVGzK",
        "hidden": 0
      },
      {
        "text": "360 render at [video]https://www.youtube.com/watch?v=opSP3MZxDiU[/video]\n",
        "date": "1504230745",
        "username": "zproxy",
        "userpicture": "/media/users/zproxy/profile.png",
        "id": "Xty3Dm",
        "hidden": 0
      },
      {
        "text": "Cool thanks. I'll use the night preset which is very nice. And I also adapted the shader for 2.35 aspect ratio, and made the camera move forward",
        "date": "1502376826",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "Mty3zD",
        "hidden": 0
      },
      {
        "text": "Hi @ttoinou, yes sure. Feel free. Regards",
        "date": "1502355541",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "lty3RD",
        "hidden": 0
      },
      {
        "text": "Hi I'm doing a shadertoy best of video, could I use your shader in it ? thanks",
        "date": "1502310280",
        "username": "ttoinou",
        "userpicture": "/media/users/ttoinou/profile.jpeg",
        "id": "4ly3zD",
        "hidden": 0
      },
      {
        "text": "Hi @Ruzzyr,\nThat is so nice to hear man. Very sweet of you and I am honestly humbled by your comment. Please feel free to ask any questions. But can I recommend DMing me on twitter @shakemayster and we can have a conversation around what ever you want to know? :)",
        "date": "1501064845",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "Xl3GWj",
        "hidden": 0
      },
      {
        "text": "You have won my heart. I revisit this shader almost daily since the day I saw it a few months back. I am so impressed with this, it brings tears to my eyes. I have a ton of, somewhat silly, questions and if you have a moment to respond I would greatly appreciate it! \nHave you written this entirely on shadertoy website? Have you used any other software? What is your background? I.e. how long have you been writing shaders for, have you done extensive mathematics degree or compsci? Do you have a good book you'd recommend or may be advice for aspiring shader enthusiasts? If you do not feel comfortable answering these I would understand. :)",
        "date": "1500884043",
        "username": "Ruzzyr",
        "userpicture": "/img/profile.jpg",
        "id": "4lcGDS",
        "hidden": 0
      },
      {
        "text": "Thanks, I will try move this shader to unity",
        "date": "1499657647",
        "username": "tachen",
        "userpicture": "/img/profile.jpg",
        "id": "XlcGDN",
        "hidden": 0
      },
      {
        "text": "@huttarl, unfortunately the game is a PS3/PS4 exclusive. But totally worth having a console for IMO :)",
        "date": "1498298335",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "Ml3GR7",
        "hidden": 0
      },
      {
        "text": "I hadn't heard of this game. Now I want to see if it can be played on PC.",
        "date": "1498297830",
        "username": "huttarl",
        "userpicture": "/media/users/huttarl/profile.jpeg",
        "id": "ll3GR7",
        "hidden": 0
      },
      {
        "text": "@salafh, also the code is right here and there are so many cool shaders on this website. So just jump in and start playing around. Some times that is the best way to learn.",
        "date": "1496824409",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "4td3Rn",
        "hidden": 0
      },
      {
        "text": "really thank you.   :)",
        "date": "1496822660",
        "username": "salafh",
        "userpicture": "/img/profile.jpg",
        "id": "Xtd3Rn",
        "hidden": 0
      },
      {
        "text": "Thanks for kind messages every one. @salafh, the best place to learn these kind of shaders would be: \nhttp://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm",
        "date": "1496735412",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MtcGRr",
        "hidden": 0
      },
      {
        "text": "beautiful   .how to learn that...i want to learn too",
        "date": "1496732281",
        "username": "salafh",
        "userpicture": "/img/profile.jpg",
        "id": "Ml3GRr",
        "hidden": 0
      },
      {
        "text": "beautiful :)",
        "date": "1494406653",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "4dVXzd",
        "hidden": 0
      },
      {
        "text": "Wonderful.",
        "date": "1494363757",
        "username": "masterxilo",
        "userpicture": "/img/profile.jpg",
        "id": "XdKXRd",
        "hidden": 0
      },
      {
        "text": "Thanks again for all the lovely comments @zhaolei1458 @rafaccique and @starea :)",
        "date": "1493909356",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "lsySz3",
        "hidden": 0
      },
      {
        "text": "Very Very Very Beautiful\uff0cGood\uff01\uff01\uff01\uff01\uff01\uff01",
        "date": "1493888322",
        "username": "zhaolei1458",
        "userpicture": "/img/profile.jpg",
        "id": "lsyXR3",
        "hidden": 0
      },
      {
        "text": "WOW\uff0cCool",
        "date": "1493888272",
        "username": "zhaolei1458",
        "userpicture": "/img/profile.jpg",
        "id": "MdyXR3",
        "hidden": 0
      },
      {
        "text": "Wow, absolutely amazing! You guys always manage to push the standard higher and higher!",
        "date": "1493813417",
        "username": "rafacacique",
        "userpicture": "/media/users/rafacacique/profile.jpeg",
        "id": "XdyXz3",
        "hidden": 0
      },
      {
        "text": "Beautiful scene! I love it!",
        "date": "1493742817",
        "username": "starea",
        "userpicture": "/media/users/starea/profile.jpeg",
        "id": "lsVSzV",
        "hidden": 0
      },
      {
        "text": "Thank you very much @vgs. So nice to read everybody's kind words. Thanks :)",
        "date": "1492504513",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "XsGSWm",
        "hidden": 0
      },
      {
        "text": "I am in love with this shader. This is just pure beauty! Thank your for all of your hard work! :D\nTruly amazing!",
        "date": "1492227966",
        "username": "vgs",
        "userpicture": "/media/users/vgs/profile.jpeg",
        "id": "XsVXDW",
        "hidden": 0
      },
      {
        "text": "amazing\uff01",
        "date": "1491898656",
        "username": "cexlearning",
        "userpicture": "/img/profile.jpg",
        "id": "lsKSW1",
        "hidden": 0
      },
      {
        "text": "Hi @redpix_, Not sure what is causing that issue. Can you kindly let me know what hardware and web browser you are running and I will do my best to fix. Thanks for dropping by :)",
        "date": "1491841987",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "4sKSD1",
        "hidden": 0
      },
      {
        "text": "why is it completely white? only music is playing :/",
        "date": "1491816221",
        "username": "redpix_",
        "userpicture": "/img/profile.jpg",
        "id": "4sVSWh",
        "hidden": 0
      },
      {
        "text": "Thanks @disorder and @duke for your kind words and indeed it is a beautiful game :D",
        "date": "1490716204",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MsySzm",
        "hidden": 0
      },
      {
        "text": "Super amazing! Love this game too",
        "date": "1490692053",
        "username": "disorder",
        "userpicture": "/img/profile.jpg",
        "id": "MdyXRm",
        "hidden": 0
      },
      {
        "text": "Awesome!",
        "date": "1490550644",
        "username": "Duke",
        "userpicture": "/img/profile.jpg",
        "id": "XsySRm",
        "hidden": 0
      },
      {
        "text": "Thanks Arturo for dropping by and your amazing comment :)",
        "date": "1490295940",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "XsVSzD",
        "hidden": 0
      },
      {
        "text": "Dude, this is amazing! Thanks for sharing and congratulations on the amazing art tribute you just made!",
        "date": "1490238053",
        "username": "ArturoNereu",
        "userpicture": "/img/profile.jpg",
        "id": "XsKSRD",
        "hidden": 0
      },
      {
        "text": "Thanks FabriceNeyret. Have removed the unused functions. My plan was to eventually remove all the rotation functions and just do a mul with pre-calculated matrices. I made a start on it, but then lazyness/work got in the way. one day :)",
        "date": "1490210795",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "4sKSzW",
        "hidden": 0
      },
      {
        "text": "some small remarks:\n\nunused funcs: sdCone, smax_mat, \n\nsmoothcurve is exactly smoothstep !\n\nrot: why not just defining one single 2D rot func returning matrix mat2(cos,-sin,sin,cos) and do p.xy*=rot(a), p.yz*=rot(a), etc ?\n\n",
        "date": "1490134689",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MsyXRD",
        "hidden": 0
      },
      {
        "text": "Ah finally :) Glad to hear that it is working as expected now. Hey, am based in Eurozone too, UK to be precise :D\nAiekick, am not sure what could have caused that, none of the changes were in the function that does the movement of the ruban. But I will inspect it again tonight, to see if I accidentally messed something up. Does it look different or different and bad? :)",
        "date": "1490101580",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MdGSRD",
        "hidden": 0
      },
      {
        "text": "@Shakemayster not sure what you did but now it is running even faster. ",
        "date": "1490091568",
        "username": "EntityBlack",
        "userpicture": "/media/users/EntityBlack/profile.jpeg",
        "id": "ldyXzW",
        "hidden": 0
      },
      {
        "text": "@Shakemayster:  no problemo (Europe time-zone here) :-)\nNow working, both on home and office computers.",
        "date": "1490091183",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MsGXzW",
        "hidden": 0
      },
      {
        "text": "the ruban of the monsters not move like tihe original ? normal ?",
        "date": "1490062593",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "lsGSzW",
        "hidden": 0
      },
      {
        "text": "Added the final, night time color scheme. Hope it all works now.",
        "date": "1490056303",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "ldGSzW",
        "hidden": 0
      },
      {
        "text": "Fixed a couple more silly issues. Thanks FabriceNeyret2 for sharing the compatibility document. Could you kindly give it one more try ( I know you are probably tired of it by now ) But thank you very much for your patience :)",
        "date": "1490050718",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MsyXRW",
        "hidden": 0
      },
      {
        "text": "Thanks for sharing that FabriceNeyret2. I will have a read through that document. Does the shader work for you as expected now? I posted a picture earlier, and would be good to know if it matches the image I shared? Thank and my apologies again.",
        "date": "1490048714",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MsySRW",
        "hidden": 0
      },
      {
        "text": "it's  a classical mistake on Windows (see [url]https://shadertoyunofficial.wordpress.com/2016/07/22/compatibility-issues-in-shadertoy-webglsl/[/url] ) because windows adds many abs() where they shouldn't be. ",
        "date": "1490048409",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "lsySRW",
        "hidden": 0
      },
      {
        "text": "Perhaps you got the clamp parameters in the wrong order but it fell through the instruction with no later consequences. ",
        "date": "1490048285",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MdySRW",
        "hidden": 0
      },
      {
        "text": "But the question is, why does it work on mine? Actually I developed parts of it on four different machines (Three of which ran it at exactly 3.000009 fps ) but none of them complaint about the clamps. I was planning on converting all the clamps to saturate: glad I didn't do that :D",
        "date": "1490047816",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "ldySRW",
        "hidden": 0
      },
      {
        "text": "*on",
        "date": "1490047596",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MsGSRW",
        "hidden": 0
      },
      {
        "text": "LOL - Yup \"Works one mine!\" :D",
        "date": "1490047577",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "lsGSRW",
        "hidden": 0
      },
      {
        "text": "\"it didn't cause any issues for me\" - a phrase coined by many a game developer! :)\n",
        "date": "1490047488",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MdGSRW",
        "hidden": 0
      },
      {
        "text": "Thanks Maurogik, and my apologies that you had to find those issues. I have updated all the clamps to be proper way around, there was one more on line 1366. Surprised that it didn't cause any issues for me, but hopefully will fix the shader for a lot of people. Thank you so much!",
        "date": "1490046128",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "4syXzD",
        "hidden": 0
      },
      {
        "text": "mmm, In the 'I can't believe that ever worked' category : \nl35 = #define saturate(a) clamp( 0.0, 1.0, a )\nl1507  = heightTerrainMix\t\t= clamp( 0.0, 1.0, heightTerrainMix );\nl 1355 = heightFog\t\t= clamp( 0.0, 1.0, heightFog );\nShould be clamp( a, 0.0, 1.0) and similar for the others. There could be more, but those are the one that fixed the issue for me.\n\nBy the way, I can't believe I thought it look nice before that... it's so much better now !",
        "date": "1490043718",
        "username": "Maurogik",
        "userpicture": "/media/users/Maurogik/profile.png",
        "id": "XsGXzD",
        "hidden": 0
      },
      {
        "text": "markusm, if you ever come back, do let us know how you enjoy the game :)",
        "date": "1490035587",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "XdySzD",
        "hidden": 0
      },
      {
        "text": "Seems like it is broken in that case. This is what it is supposed to look like: https://twitter.com/shakemayster/status/842846846972133376\nUnfortunately, I do not have a machine with Ubuntu, but I will try and see if I can install on one and see any issues. Thanks for informing me and apologies for the issue.",
        "date": "1490031941",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "XsGSzD",
        "hidden": 0
      },
      {
        "text": "a volcano like shape was there a few hours ago (on my home laptop), but no longer now (on my office desktop, both ubuntu/chrome/nvidia).",
        "date": "1490023381",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4syXRD",
        "hidden": 0
      },
      {
        "text": "Sorry, the big mountain in the distance,  through which the sun is shinning? Please let me know if you can't see it, in which case I will see if I can fix it. Thanks :)",
        "date": "1490022829",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "XsyXRD",
        "hidden": 0
      },
      {
        "text": "which mountain ?",
        "date": "1490019257",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4dyXRD",
        "hidden": 0
      },
      {
        "text": "Thanks iapafoto :)\nFabriceNeyret2,No specific reason, I started off with the random vectors texture, but liked the look of the font texture more on the big mountain in the back. ",
        "date": "1490017398",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "4sGXRD",
        "hidden": 0
      },
      {
        "text": "what's the idea behind using the font texture rather than the random texture for noise() ?",
        "date": "1490013226",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4sySRD",
        "hidden": 0
      },
      {
        "text": "Best oniric shader of all time! :)",
        "date": "1489999263",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "XsGSRD",
        "hidden": 0
      },
      {
        "text": "wowowowowowowowowow",
        "date": "1489999068",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "4dGSRD",
        "hidden": 0
      },
      {
        "text": "Just bought the game after looking at this shader for some time .... has to be great!",
        "date": "1489984491",
        "username": "markusm",
        "userpicture": "/media/users/markusm/profile.jpeg",
        "id": "XdyXzW",
        "hidden": 0
      },
      {
        "text": "Thanks aiekick. That would be amazing, though the fact that people like yourself think that this shader is cool, is pretty awesome too :)",
        "date": "1489956916",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "4dGXRW",
        "hidden": 0
      },
      {
        "text": "next shader of the week :)",
        "date": "1489949275",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "XdySRW",
        "hidden": 0
      },
      {
        "text": "Thank you for sharing, just beautiful !!!",
        "date": "1489946065",
        "username": "nikosbit",
        "userpicture": "/img/profile.jpg",
        "id": "XdGSRW",
        "hidden": 0
      },
      {
        "text": "Thank you very much Entity Black and really such a compliment. I feel so honoured to be considered next to some of the amazing guys here on Shader Toy. ( I know they are far more awesome )\nOver the last couple of days, I have received a lot of love and positivity around this shader ( on social media especially ) and I can't thank everybody enough for their kind words. Actually there probably is no way I can express my gratitude, except that I am on cloud 9 right now. Thank you all once again! :D",
        "date": "1489935962",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MdVXz1",
        "hidden": 0
      },
      {
        "text": "This is just so beautiful! O.o The color balance... I think we have new magician here on Shadertoy :] ",
        "date": "1489926215",
        "username": "EntityBlack",
        "userpicture": "/media/users/EntityBlack/profile.jpeg",
        "id": "MdKXz1",
        "hidden": 0
      },
      {
        "text": "+1 Amazing.",
        "date": "1489880742",
        "username": "poljere",
        "userpicture": "/media/users/poljere/profile.png",
        "id": "MdVXR1",
        "hidden": 0
      },
      {
        "text": "Dila, you are a legend! Have taken your changes and it all seems fine to me :D - I have to say it would be amazing if other people contribute and it keeps on getting better and better :D",
        "date": "1489879926",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "ldVXR1",
        "hidden": 0
      },
      {
        "text": "+1 superb! (diff with this to see my systems glsl bug fixes http://pastebin.com/xWxDky03)",
        "date": "1489872559",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "ldKXR1",
        "hidden": 0
      },
      {
        "text": "This is absolutely fantastic! ",
        "date": "1489871773",
        "username": "MM",
        "userpicture": "/media/users/MM/profile.jpeg",
        "id": "MsVSR1",
        "hidden": 0
      },
      {
        "text": "Worth a play. Will try as soon as I can get back on a machine, where I can see the detail. Ideally we want it to be faint very close, then go very strong around the traveller and upto first and second dune, and then fade away gently. :)",
        "date": "1489869405",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "ldVSR1",
        "hidden": 0
      },
      {
        "text": "I'm just more than happy to help. I was wondering if you could get rid of the aliasing sand texture in the distance by not forcing a particular texture LOD? i.e...\n[code]float textureGlitter  = texture(iChannel1,pos.xz * _TerrainGlitterRep, -2.).x * 1.15;[/code]\nWhich just uses a little bit of bias.\n...Or other such numbers.\n:)",
        "date": "1489868347",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MsKSR1",
        "hidden": 0
      },
      {
        "text": "I am not sure what the protocol is, but have added you as Other contributors Dave. Hope that is OK? :)",
        "date": "1489867353",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "ldKSR1",
        "hidden": 0
      },
      {
        "text": ":)",
        "date": "1489867210",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MsVXzh",
        "hidden": 0
      },
      {
        "text": "Done!. Thanks Dave. Hope it s better. Can someone confirm please, I am running on my old 10fps laptop :)",
        "date": "1489866429",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MdVXzh",
        "hidden": 0
      },
      {
        "text": "You can smooth the camera transitions as Klems suggested by added a smoothing formula to your noise function:-\n[code]insert[1602]    fc = fc*fc*(3.0-2.0*fc);[/code]\n.. and perhaps reduce _CameraMovement.w a little bit.",
        "date": "1489865637",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MsKXzh",
        "hidden": 0
      },
      {
        "text": "wow - really really good!",
        "date": "1489851581",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "lsKSzh",
        "hidden": 0
      },
      {
        "text": "Thanks Maurogik,\nI am glad you noticed the details. I actually spend most of my time playing with values and getting the details to a point I was comfortable with. Such an amazing feeling to know that it's being noticed. Thanks :)",
        "date": "1489843553",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "MdVXRh",
        "hidden": 0
      },
      {
        "text": "This is amazing, love the attention to detail here, you even got the sand moving in the wind !",
        "date": "1489840673",
        "username": "Maurogik",
        "userpicture": "/media/users/Maurogik/profile.png",
        "id": "ldVXRh",
        "hidden": 0
      },
      {
        "text": "WOW!!!\n:love:",
        "date": "1489835995",
        "username": "coyote",
        "userpicture": "/img/profile.jpg",
        "id": "MdKXRh",
        "hidden": 0
      },
      {
        "text": "Thank you all very much for your love and kind support. Means a LOT, a LOT, a LOT!",
        "date": "1489826339",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "lsVSRh",
        "hidden": 0
      },
      {
        "text": "Really pleasant to look at. The sand trail makes it for me. I love games done in this aesthetic, and you've managed to produce it very well - all within the confines of a shader.",
        "date": "1489814923",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "4sVXz1",
        "hidden": 0
      },
      {
        "text": "Stunning work my friend :)",
        "date": "1489808396",
        "username": "Nimajamin",
        "userpicture": "/media/users/Nimajamin/profile.png",
        "id": "4dVXz1",
        "hidden": 0
      },
      {
        "text": "This is awsome! I think the camera should have smooth movements tho.",
        "date": "1489806578",
        "username": "Klems",
        "userpicture": "/media/users/Klems/profile.png",
        "id": "4sKXz1",
        "hidden": 0
      },
      {
        "text": "oh my god AWESOME :)",
        "date": "1489799851",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "XdVSz1",
        "hidden": 0
      },
      {
        "text": "Thanks iq. Super proud to have the seal of approval of the super Meastro himself! :)",
        "date": "1489794627",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "XsKSz1",
        "hidden": 0
      },
      {
        "text": "Super good job!!!",
        "date": "1489794458",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4dKSz1",
        "hidden": 0
      },
      {
        "text": "Please do dila",
        "date": "1489793516",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "XdKSz1",
        "hidden": 0
      },
      {
        "text": "Hi, sorry there are other errors. I will come back and +1 when I get a system upgrade 8>",
        "date": "1489793210",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "4sVXR1",
        "hidden": 0
      },
      {
        "text": "Thanks BigWings. Appreciate the like :)",
        "date": "1489792385",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "XsVXR1",
        "hidden": 0
      },
      {
        "text": "That is amazing! You really managed to get the look right. Liked!",
        "date": "1489792306",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4dVXR1",
        "hidden": 0
      },
      {
        "text": "Hi Dila, I have removed suffix. Can you kindly try again. Though am not sure if it will work on cards that don't support GLSL ES 3.0",
        "date": "1489788967",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "4sKXR1",
        "hidden": 0
      },
      {
        "text": "I wish I could see this, but I get http://i.imgur.com/rghA4lO.png\nCan someone tell me if my browser or OS is causing this problem because it seems to be just me :(",
        "date": "1489788555",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "XsKXR1",
        "hidden": 0
      },
      {
        "text": "Thanks Dave. Well I have learnt a lot from others who have done some amazing stuff here. Glad you like it :)",
        "date": "1489788440",
        "username": "Shakemayster",
        "userpicture": "/media/users/Shakemayster/profile.jpeg",
        "id": "4dKXR1",
        "hidden": 0
      },
      {
        "text": "Welcome to Shadertoy. First shader? Masterful!!",
        "date": "1489788392",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XdKXR1",
        "hidden": 0
      },
      {
        "text": "Wow!",
        "date": "1489786763",
        "username": "P_Malin",
        "userpicture": "/media/users/P_Malin/profile.jpeg",
        "id": "4sVSR1",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "llK3Dy",
      "date": "1476610551",
      "viewed": 33837,
      "name": "Rhodium liquid carbon",
      "username": "Virgill",
      "description": "Liquid carbon effect from Rhodium 4k Intro\n4kb executable: http://www.pouet.net/prod.php?which=68239\nhttps://www.youtube.com/watch?v=YK7fbtQw3ZU",
      "likes": 465,
      "published": 3,
      "flags": 96,
      "tags": [
        "noise",
        "fire",
        "demoscene",
        "volumetric",
        "spheretracing",
        "twister",
        "liquid"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "Ms2GRw",
            "filepath": "https://soundcloud.com/virgill/4klang-rhodium",
            "previewfilepath": "https://soundcloud.com/virgill/4klang-rhodium",
            "type": "musicstream",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// ***********************************************************\n// Alcatraz / Rhodium 4k Intro liquid carbon\n// by Jochen \"Virgill\" Feldk\u00f6tter\n//\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\n// ***********************************************************\n\n#define time iTime\n#define res iResolution\n\nconst float GA =2.399; \nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\n// \tsimplyfied version of Dave Hoskins blur\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*res.y/res.x,.002),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n\tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),1.);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// ***********************************************************\n// Alcatraz / Rhodium 4k Intro liquid carbon\n// by Jochen \"Virgill\" Feldk\u00f6tter\n//\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\n// ***********************************************************\n\n#define time iTime\n#define res iResolution\n\nfloat bounce;\n\n// signed box\nfloat sdBox(vec3 p,vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\n// rotation\nvoid pR(inout vec2 p,float a) \n{\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat map(vec3 p)\n{\t\n\tp.z-=1.0;\n    p*=0.9;\n    pR(p.yz,bounce*1.+0.4*p.x);\n    return sdBox(p+vec3(0,sin(1.6*time),0),vec3(20.0, 0.05, 1.2))-.4*noise(8.*p+3.*bounce);\n}\n\n//\tnormal calculation\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.0001;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n\n// \tstandard sphere tracing inside and outside\nfloat castRayx(vec3 ro,vec3 rd) \n{\n    float function_sign=(map(ro)<0.)?-1.:1.;\n    float precis=.0001;\n    float h=precis*2.;\n    float t=0.;\n\tfor(int i=0;i<120;i++) \n\t{\n        if(abs(h)<precis||t>12.)break;\n\t\th=function_sign*map(ro+rd*t);\n        t+=h;\n\t}\n    return t;\n}\n\n// \trefraction\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\n{\n    float h=0.;\n    t2=2.;\n\tvec3 dir2=refract(dir,nor,angle);  \n \tfor(int i=0;i<50;i++) \n\t{\n\t\tif(abs(h)>3.) break;\n\t\th=map(pos+dir2*t2);\n\t\tt2-=h;\n\t}\n    nor2=calcNormal(pos+dir2*t2);\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\n}\n\n//\tsoftshadow \nfloat softshadow(vec3 ro,vec3 rd) \n{\n    float sh=1.;\n    float t=.02;\n    float h=.0;\n    for(int i=0;i<22;i++)  \n\t{\n        if(t>20.)continue;\n        h=map(ro+rd*t);\n        sh=min(sh,4.*h/t);\n        t+=h;\n    }\n    return sh;\n}\n\n//\tmain function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{    \n    bounce=abs(fract(0.05*time)-.5)*20.; // triangle function\n    \n\tvec2 uv=gl_FragCoord.xy/res.xy; \n    vec2 p=uv*2.-1.;\n   \n// \tbouncy cam every 10 seconds\n    float wobble=(fract(.1*(time-1.))>=0.9)?fract(-time)*0.1*sin(30.*time):0.;\n    \n//  camera    \n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -res.xy, res.y));\n    vec3 org = vec3(0,2.*wobble,-3.);  \n    \n\n// \tstandard sphere tracing:\n    vec3 color = vec3(0.);\n    vec3 color2 =vec3(0.);\n    float t=castRayx(org,dir);\n\tvec3 pos=org+dir*t;\n\tvec3 nor=calcNormal(pos);\n\n// \tlighting:\n    vec3 lig=normalize(vec3(.2,6.,.5));\n//\tscene depth    \n    float depth=clamp((1.-0.09*t),0.,1.);\n    \n    vec3 pos2 = vec3(0.);\n    vec3 nor2 = vec3(0.);\n    if(t<12.0)\n    {\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\n       \tfloat t2;\n\t\tcolor2.rgb +=refr(pos,lig,dir,nor,0.9, t2, nor2)*depth;\n        color2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\n\n\t}      \n  \n\n    float tmp = 0.;\n    float T = 1.;\n\n//\tanimation of glow intensity    \n    float intensity = 0.1*-sin(.209*time+1.)+0.05; \n\tfor(int i=0; i<128; i++)\n\t{\n        float density = 0.; float nebula = noise(org+bounce);\n        density=intensity-map(org+.5*nor2)*nebula;\n\t\tif(density>0.)\n\t\t{\n\t\t\ttmp = density / 128.;\n            T *= 1. -tmp * 100.;\n\t\t\tif( T <= 0.) break;\n\t\t}\n\t\torg += dir*0.078;\n    }    \n\tvec3 basecol=vec3(1./1. ,  1./4. , 1./16.);\n    T=clamp(T,0.,1.5); \n    color += basecol* exp(4.*(0.5-T) - 0.8);\n    color2*=depth;\n    color2+= (1.-depth)*noise(6.*dir+0.3*time)*.1;\t// subtle mist\n\n    \n//\tscene depth included in alpha channel\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,abs(0.67-depth)*2.+4.*wobble);\n}\n\n\n\n",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "Amazing",
        "date": "1558453716",
        "username": "t4ggno",
        "userpicture": "/img/profile.jpg",
        "id": "4t2czK",
        "hidden": 0
      },
      {
        "text": "echt fett!",
        "date": "1511548647",
        "username": "alysius",
        "userpicture": "/img/profile.jpg",
        "id": "llcSDf",
        "hidden": 0
      },
      {
        "text": "Amazing!",
        "date": "1509806466",
        "username": "chaosink",
        "userpicture": "/img/profile.jpg",
        "id": "MttSzS",
        "hidden": 0
      },
      {
        "text": "yep,that's so cool!I love the color and transparent.",
        "date": "1504263328",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "lly3Ww",
        "hidden": 0
      },
      {
        "text": "Colours and shading are amazing.",
        "date": "1504262788",
        "username": "Osgrot",
        "userpicture": "/media/users/Osgrot/profile.jpeg",
        "id": "lty3Ww",
        "hidden": 0
      },
      {
        "text": "The demoscene is the primordial soup for the universes we think we'll create...",
        "date": "1495267845",
        "username": "dagelf",
        "userpicture": "/img/profile.jpg",
        "id": "lsGSDV",
        "hidden": 0
      },
      {
        "text": "Unity3D CG version of Rhodium Liquid Carbon shader:\n\nhttps://raw.githubusercontent.com/przemyslawzaworski/Unity3D-CG-programming/master/rhodium.shader\n\nIn Unity3D editor, add 3D Object/Quad to   Main Camera, then bind material to the quad. Set quad position at (x=0 ; y=0; z=0.4;). Play :)\n",
        "date": "1485250749",
        "username": "PrzemyslawZaworski",
        "userpicture": "/media/users/PrzemyslawZaworski/profile.png",
        "id": "XddSW7",
        "hidden": 0
      },
      {
        "text": "nice\uff01 but i don't koow what shader i should to learn,because i used unity3d to  program,it support CG/HLGL more better.someone can tell me?",
        "date": "1484986253",
        "username": "huyiyuan",
        "userpicture": "/img/profile.jpg",
        "id": "4d3XWM",
        "hidden": 0
      },
      {
        "text": "jmc, thx! You\u00b4ve got mail ;)",
        "date": "1484592293",
        "username": "Virgill",
        "userpicture": "/media/users/Virgill/profile.png",
        "id": "lddXW8",
        "hidden": 0
      },
      {
        "text": "Hi,\n\nWe are the developers of FL Studio and we are wondering if you would be open to a cooperation where we use your shader to be usable in our ZGameEditor Visualizer ?\n\nThis would allow the shader to be controlled by audio and/or automation and be part of pretty complex video renderings.\n\nIf you're interested just drop me a mail (jmc at image-line dot com) and we'll set you up with our software for free so you can check things out. \n\nHere's a quick demo of other Shadertoy shaders in our Visualizer :\n\nhttps://www.youtube.com/watch?v=KiAfOQgtxO0\n\nRegards,\n\nJean-Marie Cannie\nImage-Line Software",
        "date": "1484586563",
        "username": "jmc",
        "userpicture": "/img/profile.jpg",
        "id": "XsdXDH",
        "hidden": 0
      },
      {
        "text": "holy shit",
        "date": "1479184498",
        "username": "asneakyfatcat",
        "userpicture": "/media/users/asneakyfatcat/profile.jpeg",
        "id": "MsKGzV",
        "hidden": 0
      },
      {
        "text": "Beautiful shader. One of my favourite shaders ever from one of the best 4k intros ever.\nThanks for sharing all your work Virgill.",
        "date": "1477427689",
        "username": "drift",
        "userpicture": "/img/profile.jpg",
        "id": "MdVGWh",
        "hidden": 0
      },
      {
        "text": "This is an awesome shader.",
        "date": "1477285237",
        "username": "bioccular",
        "userpicture": "/img/profile.jpg",
        "id": "lsG3W1",
        "hidden": 0
      },
      {
        "text": "absolutely, amazing. thank you for sharing your work!",
        "date": "1477240956",
        "username": "bostelk",
        "userpicture": "/media/users/bostelk/profile.png",
        "id": "MdyGWh",
        "hidden": 0
      },
      {
        "text": "I love all the art that shows up on here, thanks for promoting such a great community iq! Is there a forum that you all share ideas on? (While typing this comment, just found a bug that doesn't move a word to the next line if there are too many letters in a line.)\n\nhttp://i.imgur.com/k8nIq7v.png",
        "date": "1477117895",
        "username": "reddevild271",
        "userpicture": "/img/profile.jpg",
        "id": "4sG3Dh",
        "hidden": 0
      },
      {
        "text": "i saw the demo. its really nice. congrats",
        "date": "1477084144",
        "username": "dila",
        "userpicture": "/media/users/dila/profile.png",
        "id": "XdG3Wh",
        "hidden": 0
      },
      {
        "text": "Totally stunning!",
        "date": "1477058066",
        "username": "bwestlin",
        "userpicture": "/img/profile.jpg",
        "id": "lsV3Wz",
        "hidden": 0
      },
      {
        "text": "Great tune also.\nAmazing shadertoy can repeat a soundcloud song, while soundcloud has none of that functionality.",
        "date": "1476981623",
        "username": "noonan",
        "userpicture": "/img/profile.jpg",
        "id": "lsVGDR",
        "hidden": 0
      },
      {
        "text": "Insane brilliance",
        "date": "1476870500",
        "username": "CaliCoastReplay",
        "userpicture": "/img/profile.jpg",
        "id": "4dK3Wz",
        "hidden": 0
      },
      {
        "text": "Beautiful, in full screen it looks perfect.",
        "date": "1476808031",
        "username": "public_int_i",
        "userpicture": "/img/profile.jpg",
        "id": "4dKGDR",
        "hidden": 0
      },
      {
        "text": "Magnificent!",
        "date": "1476783201",
        "username": "mlkn",
        "userpicture": "/media/users/mlkn/profile.png",
        "id": "4dK3WR",
        "hidden": 0
      },
      {
        "text": ":love: Fantastic!",
        "date": "1476735906",
        "username": "coyote",
        "userpicture": "/img/profile.jpg",
        "id": "MdG3Dz",
        "hidden": 0
      },
      {
        "text": "fantastic !",
        "date": "1476714858",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "MdGGDz",
        "hidden": 0
      },
      {
        "text": "This is so supernice!",
        "date": "1476703947",
        "username": "_pwd_",
        "userpicture": "/media/users/_pwd_/profile.jpeg",
        "id": "lsy3Wz",
        "hidden": 0
      },
      {
        "text": "Superbe !",
        "date": "1476698694",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "ldy3Wz",
        "hidden": 0
      },
      {
        "text": "Super super nice!!",
        "date": "1476681681",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "lsyGWz",
        "hidden": 0
      },
      {
        "text": ":love: Very nice.",
        "date": "1476663277",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "lsy3DR",
        "hidden": 0
      },
      {
        "text": "Amazing!",
        "date": "1476662688",
        "username": "nimitz",
        "userpicture": "/media/users/nimitz/profile.png",
        "id": "Mdy3DR",
        "hidden": 0
      },
      {
        "text": "Superbe !",
        "date": "1476641939",
        "username": "Unix",
        "userpicture": "/img/profile.jpg",
        "id": "lsyGDR",
        "hidden": 0
      },
      {
        "text": "Beautifully hot!!! And a great use of blurring :)",
        "date": "1476636350",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MsGGDR",
        "hidden": 0
      },
      {
        "text": "wow ",
        "date": "1476621726",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "Msy3WR",
        "hidden": 0
      },
      {
        "text": "wow !",
        "date": "1476621234",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "lsy3WR",
        "hidden": 0
      },
      {
        "text": "nice!",
        "date": "1476616392",
        "username": "834144373",
        "userpicture": "/media/users/834144373/profile.jpeg",
        "id": "ldy3WR",
        "hidden": 0
      },
      {
        "text": "Very cool!",
        "date": "1476615844",
        "username": "Duke",
        "userpicture": "/img/profile.jpg",
        "id": "MsG3WR",
        "hidden": 0
      },
      {
        "text": "wow!",
        "date": "1476615146",
        "username": "kuvkar",
        "userpicture": "/media/users/kuvkar/profile.png",
        "id": "lsG3WR",
        "hidden": 0
      },
      {
        "text": "Amazing",
        "date": "1476614245",
        "username": "decrooks",
        "userpicture": "/img/profile.jpg",
        "id": "MdG3WR",
        "hidden": 0
      },
      {
        "text": "Stunning. Now I'm not sure which part I like best :)",
        "date": "1476613199",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "MsyGWR",
        "hidden": 0
      },
      {
        "text": "Looks very nice, Virgill! :)",
        "date": "1476610736",
        "username": "frankenburgh",
        "userpicture": "/media/users/frankenburgh/profile.jpeg",
        "id": "ldyGWR",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "llcyD2",
      "date": "1534089156",
      "viewed": 13337,
      "name": "A quine",
      "username": "reinder",
      "description": "This is [url=https://www.shadertoy.com/view/Ml3SWj]done[/url] [url=https://www.shadertoy.com/view/Mlj3zR]before[/url] and my code is not the most [url=https://www.shadertoy.com/view/MlGcRz]optimised[/url], but it is nice to write your own quine!",
      "likes": 78,
      "published": 3,
      "flags": 0,
      "tags": [
        "text",
        "font",
        "quine"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "int y;ivec2 d;uint[] c = uint[ 151](0x007a995eu,0x0083f840u,0x009a9c40u,0x006e5840u,0x0043f4dcu,    \n0x006659c0u,0x0066595eu,0x000c5661u,0x006a595au,0x007a9a66u,0x00f14938u,0x0062493fu,0x00924918u,    \n0x00fe4918u,0x00a2cb18u,0x00145f84u,0x3813813cu,0x0003d100u,0x0087f840u,0x0066bb5au,0x0085e000u,    \n0x00330604u,0x00010800u,0x00020000u,0x00624918u,0x00f2081cu,0x00024784u,0x0001e840u,0x0085e100u,    \n0x000047a1u,0x00014800u,0x00894200u,0x00214880u,0x0023e208u,0x00008208u,0x00f2081cu,0x00024784u,    \n0x0087f000u,0x0003f840u,0x00918624u,0x000ccc00u,0x00916724u,0x00a3b9d8u,0x00514514u,0x00310a24u,    \n0x00e0423cu,0x001a9080u,0x00024000u,0x00c766e3u,0x00c8d17fu,0x0052ca00u,0x0083f040u,0x0003f000u,    \n0x0000413cu,0x00000000u,0x00000000u,0x2cd9ab51u,0x0c39545eu,0x1978dd82u,0x2695ab51u,0x36af6336u,    \n0x256ad459u,0x26045076u,0xfefbefd4u,0x2d45979bu,0x1950ed9au,0x0bd9ab51u,0x1a3b571bu,0x0cdadd59u,    \n0x208262e5u,0x299d7354u,0x2c5cd846u,0x019c0a9bu,0x1165d799u,0x145766adu,0x0ad9ab51u,0x366ad456u,    \n0x1ab5158bu,0x1171b3f6u,0x2b4766adu,0x3678a8acu,0x3565a3b5u,0x007d1dadu,0x0b811d34u,0x1902702eu,    \n0x253143afu,0x0f845a11u,0x30460826u,0x00a86a45u,0x1b64f0e7u,0x2d45975eu,0x1b52dd9au,0x366ad45cu,    \n0x038acad1u,0x11ad8586u,0x35782070u,0x2dd5968eu,0x3401f476u,0x01811db4u,0x00b80048u,0x18bd9027u,    \n0x0eb80aebu,0x19027014u,0x2bad8bdbu,0x0050eb81u,0x1b6470a7u,0x01aeb62fu,0x0050eb80u,0x1b6430a7u,    \n0x01aeb62fu,0x0050eb81u,0x1b646067u,0x253143afu,0x26081a11u,0x14da0836u,0x1b622254u,0x2ad9b129u,    \n0x1b64f9c0u,0x1161575eu,0x11290d8du,0x132904adu,0x1a65850eu,0x0430e576u,0x0e5562b6u,0x1b2f608cu,    \n0x2bb172dcu,0x18c8ec51u,0x1845a673u,0x0b8ac5edu,0x2b35eb17u,0x0230e551u,0x2c79b2d4u,0x289d736bu,    \n0x17354845u,0x296c8a2cu,0x3035e189u,0x0c39546bu,0x08585502u,0x15aca79bu,0x0d50430eu,0x34160b17u,    \n0x209d72f4u,0x2e5c0204u,0x2f6409c0u,0x03580515u,0x1b185585u,0x216d4b61u,0x04201515u,0x010c4587u,    \n0x1b6c4196u,0xfefbf75eu);uint e(uint b){return c[b]>>(d.x*6+d.y)&0x1u;}uint v(int a,int b,int f)\n{int i=y-a; return i<0||i>b?0x0u:e(c[i/5+f]>>i%5*6&0x3fu);}uint n(){int i=y-36,o=i%12;return i<0\n|| i>1810?0x0u:o==0?e(0x0u):o==1?e(0x27u):o==10?e(0x23u):o==11?e(0x16u):e(c[i/12] >> ((9-o)*4) &\n0xfu);}void mainImage(out vec4 a,vec2 b){b.y=iResolution.y-b.y;d=ivec2(b);y=d.x/5+(d.y/8)*96;d%=\nivec2(5,8);a=vec4(d.y>5||b.x>480.?0x0u:v(0,35,56)+n()+v(1847,431,64));}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Bravo.",
        "date": "1553052711",
        "username": "xot",
        "userpicture": "/media/users/xot/profile.jpeg",
        "id": "XtfcWB",
        "hidden": 0
      },
      {
        "text": "What the... god alike!",
        "date": "1553052446",
        "username": "starea",
        "userpicture": "/media/users/starea/profile.jpeg",
        "id": "4lXcWB",
        "hidden": 0
      },
      {
        "text": "wow. Love it!",
        "date": "1550082430",
        "username": "Blindleistung",
        "userpicture": "/img/profile.jpg",
        "id": "MtfcDr",
        "hidden": 0
      },
      {
        "text": "bah! you guys are all a bunch of fucking retards.\nj/k",
        "date": "1543948264",
        "username": "Carandiru",
        "userpicture": "/media/users/Carandiru/profile.png",
        "id": "lsjBD1",
        "hidden": 0
      },
      {
        "text": "what are you, a wizard?",
        "date": "1535907774",
        "username": "Metin",
        "userpicture": "/media/users/Metin/profile.png",
        "id": "MsfBWH",
        "hidden": 0
      },
      {
        "text": "amazing!",
        "date": "1535515625",
        "username": "hk_shao",
        "userpicture": "/img/profile.jpg",
        "id": "MssfDn",
        "hidden": 0
      },
      {
        "text": "I [url=https://www.shadertoy.com/view/MlGcRz]created a smaller quine here[/url].",
        "date": "1535265771",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "ldffDr",
        "hidden": 0
      },
      {
        "text": "No font texture, great!",
        "date": "1534961058",
        "username": "ttg",
        "userpicture": "/media/users/ttg/profile.jpeg",
        "id": "4dXfDn",
        "hidden": 0
      },
      {
        "text": "This one is already incredible!",
        "date": "1534852115",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "ldsfz7",
        "hidden": 0
      },
      {
        "text": "Thanks! You can find [url=https://gpfault.net/posts/shader-quine.txt.html]a nice explanation of this shader here[/url].",
        "date": "1534828971",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "MdsBz7",
        "hidden": 0
      },
      {
        "text": "Wow! reminds me of this: https://en.wikipedia.org/wiki/Tupper%27s_self-referential_formula",
        "date": "1534782385",
        "username": "emdeka87",
        "userpicture": "/media/users/emdeka87/profile.png",
        "id": "MdsfzM",
        "hidden": 0
      },
      {
        "text": "This was clever! I've never seen this kind of tricks before so I was baffled for a while, thanks for that! :D",
        "date": "1534532184",
        "username": "Harha",
        "userpicture": "/media/users/Harha/profile.png",
        "id": "MdXfz7",
        "hidden": 0
      },
      {
        "text": "Holy... quines aren't normally impressive because they just take advantage of print formatting and do a single recursion, but this is something else",
        "date": "1534451463",
        "username": "josplode",
        "userpicture": "/img/profile.jpg",
        "id": "MsffzM",
        "hidden": 0
      },
      {
        "text": "That is just amazing! It took me way too long to figure out how it works.",
        "date": "1534106444",
        "username": "slerpy",
        "userpicture": "/media/users/slerpy/profile.png",
        "id": "MslfRN",
        "hidden": 0
      },
      {
        "text": "cool! and clever!\ni took some moments to figure out how it works, nice trick!",
        "date": "1534105552",
        "username": "pellicus",
        "userpicture": "/media/users/pellicus/profile.jpeg",
        "id": "ldlfRN",
        "hidden": 0
      },
      {
        "text": ":O how on earth is that even possible?",
        "date": "1534097360",
        "username": "nicoptere",
        "userpicture": "/img/profile.jpg",
        "id": "lssBRN",
        "hidden": 0
      },
      {
        "text": "FabriceNeyret2, I'm looking forward to see a really compact quine created by you :)",
        "date": "1534090445",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "ldsBRN",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "llt3R4",
      "date": "1468282135",
      "viewed": 80616,
      "name": "Ray Marching: Part 1",
      "username": "jlfwong",
      "description": "Part 1 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/",
      "likes": 105,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/**\n * Part 1 Challenges\n * - Make the circle yellow\n * - Make the circle smaller by decreasing its radius\n * - Make the circle smaller by moving the camera back\n * - Make the size of the circle oscillate using the sin() function and the iTime\n *   uniform provided by shadertoy\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "I think in the rayDirection function, the caculation of z should be mul by 0.5 which should be like this:\nfloat z = size.y * 0.5 / tan(radians(fieldOfView) / 2.0)   since the size.y is the height of the screen.",
        "date": "1560836434",
        "username": "tju_demon",
        "userpicture": "/img/profile.jpg",
        "id": "llScWc",
        "hidden": 0
      },
      {
        "text": "\u770b\u4e86\u60a8\u7684\u4ee3\u7801\uff0c\u6211\u7ec8\u4e8e\u61c2\u4e86\uff0c\u8c22\u8c22",
        "date": "1556893716",
        "username": "Geralt_of_China",
        "userpicture": "/media/users/Geralt_of_China/profile.jpeg",
        "id": "Mt2yD1",
        "hidden": 0
      },
      {
        "text": "Many Chinglish users found : )",
        "date": "1541987738",
        "username": "EricClapton",
        "userpicture": "/media/users/EricClapton/profile.jpeg",
        "id": "lsBBRW",
        "hidden": 0
      },
      {
        "text": "It was pretty fun to do this. Thanks man. I will follow more of your stuff!",
        "date": "1537547876",
        "username": "Yuchen",
        "userpicture": "/img/profile.jpg",
        "id": "lsffRB",
        "hidden": 0
      },
      {
        "text": "thanks for sharing!",
        "date": "1530567307",
        "username": "JohanFlod",
        "userpicture": "/img/profile.jpg",
        "id": "Ms2cRc",
        "hidden": 0
      },
      {
        "text": "Thank you very much andro. I will check them out. I understand everything in there just this part was somehow unclear to me.",
        "date": "1477829737",
        "username": "Hitokage",
        "userpicture": "/img/profile.jpg",
        "id": "MdGGDD",
        "hidden": 0
      },
      {
        "text": "Hi Hikotage, this example doesn't make it very clear to a beginner (though it is a great tut that only focues on the absolute basics), heres a few links to other tuts that helped me out with getting started . https://www.shadertoy.com/view/XllGW4    https://www.shadertoy.com/view/XlBGDW",
        "date": "1477829515",
        "username": "andro",
        "userpicture": "/media/users/andro/profile.png",
        "id": "ldGGDD",
        "hidden": 0
      },
      {
        "text": "Hello, can anyone please explain me the rayDirection function? I understand that the first line moves the values so the 0,0 is the center of the plane but what does the float z equation?",
        "date": "1477764713",
        "username": "Hitokage",
        "userpicture": "/img/profile.jpg",
        "id": "MsG3DW",
        "hidden": 0
      },
      {
        "text": "Thanks a lot. Thats a good way to start",
        "date": "1468700501",
        "username": "flexelektro",
        "userpicture": "/img/profile.jpg",
        "id": "4dt3R4",
        "hidden": 0
      },
      {
        "text": "If possible in the future I'd love to see an example of how to add a texture to a sphere. This is something thats difficult to find a clear example of (as people approach the technique in so many different ways), keep up the good work !\n",
        "date": "1468397346",
        "username": "andro",
        "userpicture": "/media/users/andro/profile.png",
        "id": "ldtGzH",
        "hidden": 0
      },
      {
        "text": "This is part 1 of many. Later steps will have lighting, affine transformation, and CSG. The many parts will be tied together as part of a blog post :)",
        "date": "1468363318",
        "username": "jlfwong",
        "userpicture": "/img/profile.jpg",
        "id": "Msd3z8",
        "hidden": 0
      },
      {
        "text": "for who is aimed this tutorial ?\nWouldn't some shading make it looking more like a ray-traced sphere ? ;-)",
        "date": "1468362914",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "ldd3z8",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "lt33z7",
      "date": "1468393135",
      "viewed": 79129,
      "name": "Ray Marching: Part 2",
      "username": "jlfwong",
      "description": "Part 2 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/",
      "likes": 65,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Tracer loves you :octopusballoon:",
        "date": "1541991498",
        "username": "EricClapton",
        "userpicture": "/media/users/EricClapton/profile.jpeg",
        "id": "ldSfRW",
        "hidden": 0
      },
      {
        "text": "you're a good man, jamie.",
        "date": "1511537179",
        "username": "laserdog",
        "userpicture": "/media/users/laserdog/profile.jpeg",
        "id": "MlcXWf",
        "hidden": 0
      },
      {
        "text": "Thanks, best raymarching tutorial out there by far ! :D",
        "date": "1494961995",
        "username": "Vizalkar",
        "userpicture": "/img/profile.jpg",
        "id": "MdVXDG",
        "hidden": 0
      },
      {
        "text": "This tutorial is great :)",
        "date": "1488730673",
        "username": "benzrf",
        "userpicture": "/img/profile.jpg",
        "id": "Ms3SDs",
        "hidden": 0
      },
      {
        "text": "Massive Gratitude :)",
        "date": "1486475271",
        "username": "metta",
        "userpicture": "/img/profile.jpg",
        "id": "MddXRj",
        "hidden": 0
      },
      {
        "text": "Thank you very much for this.",
        "date": "1477855321",
        "username": "Hitokage",
        "userpicture": "/img/profile.jpg",
        "id": "Mdy3DD",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "tl23Rm",
      "date": "1559573266",
      "viewed": 809,
      "name": "Ray Tracing - Primitives",
      "username": "reinder",
      "description": "This is a collection of ray-primitive intersection routines ([url=http://iquilezles.org/www/articles/intersectors/intersectors.htm]by \u00cd\u00f1igo Qu\u00edlez[/url]).\n\nUse your mouse to change the camera viewpoint.",
      "likes": 44,
      "published": 3,
      "flags": 32,
      "tags": [
        "3d",
        "raytracer",
        "ray",
        "intersection",
        "dof",
        "primitives",
        "field",
        "tracing",
        "depth",
        "path",
        "of"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tl23Rm\n//\n// I wanted to create a reference shader similar to \"Raymarching - Primitives\" \n// (https://www.shadertoy.com/view/Xds3zN), but with ray-primitive intersection \n// routines instead of sdf routines.\n// \n// As usual, I ended up mostly just copy-pasting code from \u00cd\u00f1igo Qu\u00edlez: \n// \n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\n// \n// Please let me know if there are other routines that I should add to this shader.\n// \n// You can find all intersection routines in the Common tab. The routines have a similar \n// signature: a routine returns the distance to the first hit inside the \n// [distBound.x, distBound.y] interval and will set the normal if an intersection is found.\n// If no intersection is found, the routine will return MAX_DIST.\n//\n// I made a simple ray tracer (Buffer A) to visualize a scene with all primitives.\n//\n// Use your mouse to change the camera viewpoint.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb / data.w;\n    \n    // gamma correction\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tl23Rm\n//\n// I wanted to create a reference shader similar to \"Raymarching - Primitives\" \n// (https://www.shadertoy.com/view/Xds3zN), but with ray-primitive intersection \n// routines instead of sdf routines.\n// \n// As usual, I ended up mostly just copy-pasting code from \u00cd\u00f1igo Qu\u00edlez: \n// \n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\n// \n// Please let me know if there are other routines that I should add to this shader.\n// \n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n//\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n//\n\n#define MAX_DIST 1e10\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Plane \nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Box:             https://www.shadertoy.com/view/ld23DV\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 pa, in vec3 pb, float ra ) {\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    \n    if (h < 0.) return MAX_DIST;\n    \n    h = sqrt(h);\n    float d = (-b-h)/a;\n\n    float y = caoc + d*card;\n    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc+d*rd-ca*y/caca)/ra;\n        return d;\n    }\n\n    d = ((y < 0. ? 0. : caca) - caoc)/card;\n    \n    if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\n        normal = normalize(ca*sign(y)/caca);\n        return d;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Torus:           https://www.shadertoy.com/view/4sBGDy\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec2 torus ) {\n    // bounding sphere\n    vec3 tmpnormal;\n    if (iSphere(ro, rd, distBound, tmpnormal, torus.y+torus.x) > distBound.y) {\n        return MAX_DIST;\n    }\n    \n    float po = 1.0;\n    \n\tfloat Ra2 = torus.x*torus.x;\n\tfloat ra2 = torus.y*torus.y;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\n#if 1\n\tfloat k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n\tfloat k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n#else\n\tfloat k = (m - Ra2 - ra2)/2.0;\n\tfloat k3 = n;\n\tfloat k2 = n*n + Ra2*rd.z*rd.z + k;\n\tfloat k1 = k*n + Ra2*ro.z*rd.z;\n\tfloat k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n#endif\n    \n#if 1\n    // prevent |c1| from being too close to zero\n    if (abs(k3*(k3*k3-k2)+k1) < 0.01) {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n#endif\n    \n    // reduced cubic\n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    \n    float h = R*R - Q*Q*Q;\n    \n    if (h>=0.0) {\n        // 2 intersections\n        h = sqrt(h);\n        \n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n    \n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        \n        if (t >= distBound.x && t <= distBound.y) {\n            vec3 pos = ro + rd*t;\n            normal = normalize( pos*(dot(pos,pos) - torus.y*torus.y - torus.x*torus.x*vec3(1,1,-1)));\n            return t;\n        } else {\n            return MAX_DIST;\n        }\n    }\n    \n    // 4 intersections\n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n\n    float d2 = -(w+c2); if( d2<0.0 ) return MAX_DIST;\n    float d1 = sqrt(d2);\n\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n\n\tif (t >= distBound.x && t <= distBound.y) {\n        vec3 pos = ro + rd*t;\n        normal = normalize( pos*(dot(pos,pos) - torus.y*torus.y - torus.x*torus.x*vec3(1,1,-1)));\n        return t;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in vec3 pa, in vec3 pb, in float r ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if (h >= 0.) {\n        float t = (-b-sqrt(h))/a;\n        float d = MAX_DIST;\n        \n        float y = baoa + t*bard;\n        \n        // body\n        if (y > 0. && y < baba) {\n            d = t;\n        } else {\n            // caps\n            vec3 oc = (y <= 0.) ? oa : ro - pb;\n            b = dot(rd,oc);\n            c = dot(oc,oc) - r*r;\n            h = b*b - c;\n            if( h>0.0 ) {\n                d = -b - sqrt(h);\n            }\n        }\n        if (d >= distBound.x && d <= distBound.y) {\n            vec3  pa = ro + rd * d - pa;\n            float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n            normal = (pa - h*ba)/r;\n            return d;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\nfloat iCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n             in vec3  pa, in vec3  pb, in float ra, in float rb ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n    if (m1 < 0.) { \n        if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) {\n            float d = -m1/m3;\n            if (d >= distBound.x && d <= distBound.y) {\n                normal = -ba*inversesqrt(m0);\n                return d;\n            }\n        }\n    }\n    else if (m2 > 0.) { \n        if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) {\n            float d = -m2/m3;\n            if (d >= distBound.x && d <= distBound.y) {\n                normal = ba*inversesqrt(m0);\n                return d;\n            }\n        }\n    }\n                       \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h < 0. ) return MAX_DIST;\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {\n        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);\n        return t;\n    } else {   \n\t    return MAX_DIST;\n    }\n}\n\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\nfloat iEllipsoid( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                  in vec3 rad ) {\n    vec3 ocn = ro / rad;\n    vec3 rdn = rd / rad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.);\n    \n    if (h < 0.) {\n        return MAX_DIST;\n    }\n    \n\tfloat d = (-b - sqrt(h))/a;\n    \n    if (d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = normalize((ro + d*rd)/rad);\n    \treturn d;\n    }\n}\n\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\nfloat iRoundedCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                    in vec3  pa, in vec3  pb, in float ra, in float rb ) {\n    vec3  ba = pb - pa;\n\tvec3  oa = ro - pa;\n\tvec3  ob = ro - pb;\n    float rr = ra - rb;\n    float m0 = dot(ba,ba);\n    float m1 = dot(ba,oa);\n    float m2 = dot(ba,rd);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n\tfloat m6 = dot(ob,rd);\n    float m7 = dot(ob,ob);\n    \n    float d2 = m0-rr*rr;\n    \n\tfloat k2 = d2    - m2*m2;\n    float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2. - m0*ra*ra;\n    \n\tfloat h = k1*k1 - k0*k2;\n    if (h < 0.0) {\n        return MAX_DIST;\n    }\n    \n    float t = (-sqrt(h)-k1)/k2;\n    \n    float y = m1 - ra*rr + t*m2;\n    if (y>0.0 && y<d2) {\n        if (t >= distBound.x && t <= distBound.y) {\n        \tnormal = normalize( d2*(oa + t*rd)-ba*y );\n            return t;\n        } else {\n            return MAX_DIST;\n        }\n    } else {\n        float h1 = m3*m3 - m5 + ra*ra;\n        float h2 = m6*m6 - m7 + rb*rb;\n\n        if (max(h1,h2)<0.0) {\n            return MAX_DIST;\n        }\n\n        vec3 n = vec3(0);\n        float r = MAX_DIST;\n\n        if (h1 > 0.) {        \n            r = -m3 - sqrt( h1 );\n            n = (oa+r*rd)/ra;\n        }\n        if (h2 > 0.) {\n            t = -m6 - sqrt( h2 );\n            if( t<r ) {\n                n = (ob+t*rd)/rb;\n                r = t;\n            }\n        }\n        if (r >= distBound.x && r <= distBound.y) {\n            normal = n;\n            return r;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 v0, in vec3 v1, in vec3 v2 ) {\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0. || v<0. || (u+v)>1. || t<distBound.x || t>distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = normalize(-n);\n        return t;\n    }\n}\n\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\nfloat iSphere4( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in float ra ) {\n    // -----------------------------\n    // solve quartic equation\n    // -----------------------------\n    \n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k0 = ka* dot(ro,d3);\n    float k1 = ka* dot(o2,d2);\n    float k2 = ka* dot(o3,rd);\n    float k3 = ka*(dot(o2,o2) - r2*r2);\n\n    // -----------------------------\n    // solve cubic\n    // -----------------------------\n\n    float c0 = k1 - k0*k0;\n    float c1 = k2 + 2.0*k0*(k0*k0 - (3.0/2.0)*k1);\n    float c2 = k3 - 3.0*k0*(k0*(k0*k0 - 2.0*k1) + (4.0/3.0)*k2);\n\n    float p = c0*c0*3.0 + c2;\n    float q = c0*c0*c0 - c0*c2 + c1*c1;\n    float h = q*q - p*p*p*(1.0/27.0);\n\n    // -----------------------------\n    // skip the case of 3 real solutions for the cubic, which involves \n    // 4 complex solutions for the quartic, since we know this objcet is \n    // convex\n    // -----------------------------\n    if (h<0.0) {\n        return MAX_DIST;\n    }\n    \n    // one real solution, two complex (conjugated)\n    h = sqrt(h);\n\n    float s = sign(q+h)*pow(abs(q+h),1.0/3.0); // cuberoot\n    float t = sign(q-h)*pow(abs(q-h),1.0/3.0); // cuberoot\n\n    vec2 v = vec2( (s+t)+c0*4.0, (s-t)*sqrt(3.0) )*0.5;\n    \n    // -----------------------------\n    // the quartic will have two real solutions and two complex solutions.\n    // we only want the real ones\n    // -----------------------------\n    \n    float r = length(v);\n\tfloat d = -abs(v.y)/sqrt(r+v.x) - c1/r - k0;\n\n    if (d >= distBound.x && d <= distBound.y) {\n\t    vec3 pos = ro + rd * d;\n\t    normal = normalize( pos*pos*pos );\n\t    return d;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\nfloat cuberoot( float x ) { return sign(x)*pow(abs(x),1.0/3.0); }\n\nfloat iGoursat( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in float ra, float rb ) {\n// hole: x4 + y4 + z4 - (r2^2)\u00b7(x2 + y2 + z2) + r1^4 = 0;\n    float ra2 = ra*ra;\n    float rb2 = rb*rb;\n    \n    vec3 rd2 = rd*rd; vec3 rd3 = rd2*rd;\n    vec3 ro2 = ro*ro; vec3 ro3 = ro2*ro;\n\n    float ka = 1.0/dot(rd2,rd2);\n\n    float k3 = ka*(dot(ro ,rd3));\n    float k2 = ka*(dot(ro2,rd2) - rb2/6.0);\n    float k1 = ka*(dot(ro3,rd ) - rb2*dot(rd,ro)/2.0  );\n    float k0 = ka*(dot(ro2,ro2) + ra2*ra2 - rb2*dot(ro,ro) );\n\n    float c2 = k2 - k3*(k3);\n    float c1 = k1 + k3*(2.0*k3*k3-3.0*k2);\n    float c0 = k0 + k3*(k3*(c2+k2)*3.0-4.0*k1);\n\n    c0 /= 3.0;\n\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c0*c2 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    \n    // 2 intersections\n    if (h>0.0) {\n        h = sqrt(h);\n\n        float s = cuberoot( R + h );\n        float u = cuberoot( R - h );\n        \n        float x = s+u+4.0*c2;\n        float y = s-u;\n        \n        float k2 = x*x + y*y*3.0;\n  \n        float k = sqrt(k2);\n\n\t\tfloat d = -0.5*abs(y)*sqrt(6.0/(k+x)) \n                  -2.0*c1*(k+x)/(k2+x*k) \n                  -k3;\n        \n        if (d >= distBound.x && d <= distBound.y) {\n            vec3 pos = ro + rd * d;\n            normal = normalize( 4.0*pos*pos*pos - 2.0*pos*rb*rb );\n            return d;\n        } else {\n            return MAX_DIST;\n        }\n    } else {\t\n        // 4 intersections\n        float sQ = sqrt(Q);\n        float z = c2 - 2.0*sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n\n        float d1 = z   - 3.0*c2;\n        float d2 = z*z - 3.0*c0;\n\n        if (abs(d1)<1.0e-4) {  \n            if( d2<0.0) return MAX_DIST;\n            d2 = sqrt(d2);\n        } else {\n            if (d1<0.0) return MAX_DIST;\n            d1 = sqrt( d1/2.0 );\n            d2 = c1/d1;\n        }\n\n        //----------------------------------\n\n        float h1 = sqrt(d1*d1 - z + d2);\n        float h2 = sqrt(d1*d1 - z - d2);\n        float t1 = -d1 - h1 - k3;\n        float t2 = -d1 + h1 - k3;\n        float t3 =  d1 - h2 - k3;\n        float t4 =  d1 + h2 - k3;\n\n        if (t2<0.0 && t4<0.0) return MAX_DIST;\n\n        float result = 1e20;\n             if( t1>0.0 ) result=t1;\n        else if( t2>0.0 ) result=t2;\n             if( t3>0.0 ) result=min(result,t3);\n        else if( t4>0.0 ) result=min(result,t4);\n\n        if (result >= distBound.x && result <= distBound.y) {\n            vec3 pos = ro + rd * result;\n            normal = normalize( 4.0*pos*pos*pos - 2.0*pos*rb*rb );\n            return result;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n",
        "name": "Common",
        "description": "",
        "type": "common"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tl23Rm\n//\n// I have combined different intersection routines in one shader (similar \n// to \"Raymarching - Primitives\": https://www.shadertoy.com/view/Xds3zN) and\n// added a simple ray tracer to visualize a scene with all primitives.\n//\n\n#define PATH_LENGTH 12\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray tracer helper functions\n//\n\nfloat FresnelSchlickRoughness( float cosTheta, float F0, float roughness ) {\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\n}\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nbool modifiedRefract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \n                     out vec3 refracted) {\n    float dt = dot(v, n);\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\n    if (discriminant > 0.) {\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\n        return true;\n    } else { \n        return false;\n    }\n}\n\nvec3 modifyDirectionWithRoughness( const vec3 normal, const vec3 n, const float roughness, inout float seed ) {\n    vec2 r = hash2(seed);\n    \n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\t\n    float a = roughness*roughness;\n    \n\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\n\tfloat ra = sqrt(abs(1.-rz*rz));\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    \n    vec3 ret = normalize(rr);\n    return dot(ret,normal) > 0. ? ret : n;\n}\n\nvec2 randomInUnitDisk( inout float seed ) {\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Scene description\n//\n\nvec3 rotateY( const in vec3 p, const in float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nvec3 opU( vec3 d, float iResult, float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n\nfloat iMesh( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal) {\n\tconst vec3 tri0 = vec3(-2./3. * 0.43301270189, 0, 0);\n\tconst vec3 tri1 = vec3( 1./3. * 0.43301270189, 0, .25);\n\tconst vec3 tri2 = vec3( 1./3. * 0.43301270189, 0,-.25);\n\tconst vec3 tri3 = vec3( 0, 0.41079191812, 0);\n    \n    vec2 d = distBound;\n\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri0, tri1, tri2));   \n\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri0, tri3, tri1));  \n\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri2, tri3, tri0));   \n\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri1, tri3, tri2));\n    \n    return d.y < distBound.y ? d.y : MAX_DIST;\n}\n         \nvec3 worldhit( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal ) {\n    vec3 tmp0, tmp1, d = vec3(dist, 0.);\n    \n    d = opU(d, iPlane      (ro,                  rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    d = opU(d, iBox        (ro-vec3( 1,.250, 0), rd, d.xy, normal, vec3(.25)), 2.);\n    d = opU(d, iSphere     (ro-vec3( 0,.250, 0), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iCylinder   (ro,                  rd, d.xy, normal, vec3(2.1,.1,-2), vec3(1.9,.5,-1.9), .08 ), 4.);\n    d = opU(d, iCylinder   (ro-vec3( 1,.100,-2), rd, d.xy, normal, vec3(0,0,0), vec3(0,.4,0), .1 ), 5.);\n    d = opU(d, iTorus      (ro-vec3( 0,.250, 1), rd, d.xy, normal, vec2(.2,.05)), 6.);\n    d = opU(d, iCapsule    (ro-vec3( 1,.000,-1), rd, d.xy, normal, vec3(-.1,.1,-.1), vec3(.2,.4,.2), .1), 7.);\n    d = opU(d, iCone       (ro-vec3( 2,.200, 0), rd, d.xy, normal, vec3(.1,0,0), vec3(-.1,.3,.1), .15, .05), 8.);\n    d = opU(d, iCone       (ro-vec3( 0,.200,-2), rd, d.xy, normal, vec3(0,0,0), vec3(0,0.3,0), .2, .1), 9.);\n    d = opU(d, iGoursat    (ro-vec3( 1,.275, 1), rd, d.xy, normal, .16, .2), 10.);\n    d = opU(d, iEllipsoid  (ro-vec3(-1,.300, 0), rd, d.xy, normal, vec3(.2,.25, .05)), 11.);\n    d = opU(d, iRoundedCone(ro-vec3( 2,.200,-1), rd, d.xy, normal, vec3(.1,0,0), vec3(-.1,.3,.1), 0.15, 0.05), 12.);\n    d = opU(d, iRoundedCone(ro-vec3(-1,.200,-2), rd, d.xy, normal, vec3(0,.3,0), vec3(0,0,0), .1, .2), 13.);\n    d = opU(d, iMesh       (ro-vec3( 2,.090, 1), rd, d.xy, normal), 14.);\n    d = opU(d, iSphere4    (ro-vec3(-1,.275,-1), rd, d.xy, normal, .225), 15.);\n    \n    tmp1 = opU(d, iBox     (rotateY(ro-vec3(0,.25,-1), 0.78539816339), rotateY(rd, 0.78539816339), d.xy, tmp0, vec3(.1,.2,.1)), 16.);\n    if (tmp1.y < d.y) {\n        d = tmp1;\n        normal = rotateY(tmp0, -0.78539816339);\n    }\n    \n    return d;\n}\n\n//\n// Palette by \u00cd\u00f1igo Qu\u00edlez: \n// https://www.shadertoy.com/view/ll2GD3\n//\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos(6.28318530718*(c*t+d));\n}\n\nfloat checkerBoard( vec2 p ) {\n   return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nvec3 getSkyColor( vec3 rd ) {\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\n    float sun = clamp(dot(normalize(vec3(-.4,.7,-.6)),rd), 0., 1.);\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,32.));\n    return col;\n}\n\n#define LAMBERTIAN 0.\n#define METAL 1.\n#define DIELECTRIC 2.\n\nfloat gpuIndepentHash(float p) {\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid getMaterialProperties(in vec3 pos, in float mat, \n                           out vec3 albedo, out float type, out float roughness) {\n    albedo = pal(mat*.59996323+.5, vec3(.5),vec3(.5),vec3(1),vec3(0,.1,.2));\n\n    if( mat < 1.5 ) {            \n        albedo = vec3(.25 + .25*checkerBoard(pos.xz * 5.));\n        roughness = .75 * albedo.x - .15;\n        type = METAL;\n    } else {\n        type = floor(gpuIndepentHash(mat+.3) * 3.);\n        roughness = (1.-type*.475) * gpuIndepentHash(mat);\n    }\n}\n\n//\n// Simple ray tracer\n//\n\nfloat schlick(float cosine, float r0) {\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\nvec3 render( in vec3 ro, in vec3 rd, inout float seed ) {\n    vec3 albedo, normal, col = vec3(1.); \n    float roughness, type;\n    \n    for (int i=0; i<PATH_LENGTH; ++i) {    \n    \tvec3 res = worldhit( ro, rd, vec2(.0001, 100), normal );\n\t\tif (res.z > 0.) {\n\t\t\tro += rd * res.y;\n       \t\t\n            getMaterialProperties(ro, res.z, albedo, type, roughness);\n            \n            if (type < LAMBERTIAN+.5) { // Added/hacked a reflection term\n                float F = FresnelSchlickRoughness(max(0.,-dot(normal, rd)), .04, roughness);\n                if (F > hash1(seed)) {\n                    rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);\n                } else {\n                    col *= albedo;\n\t\t\t        rd = cosWeightedRandomHemisphereDirection(normal, seed);\n                }\n            } else if (type < METAL+.5) {\n                col *= albedo;\n                rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);            \n            } else { // DIELECTRIC\n                vec3 normalOut, refracted;\n                float ni_over_nt, cosine, reflectProb = 1.;\n                if (dot(rd, normal) > 0.) {\n                    normalOut = -normal;\n            \t\tni_over_nt = 1.4;\n                    cosine = dot(rd, normal);\n                    cosine = sqrt(1.-(1.4*1.4)-(1.4*1.4)*cosine*cosine);\n                } else {\n                    normalOut = normal;\n                    ni_over_nt = 1./1.4;\n                    cosine = -dot(rd, normal);\n                }\n                \n                if (modifiedRefract(rd, normalOut, ni_over_nt, refracted)) {\n                \tfloat r0 = (1.-ni_over_nt)/(1.+ni_over_nt);\n\t        \t\treflectProb = FresnelSchlickRoughness(cosine, r0*r0, roughness);\n                }\n                \n                rd = hash1(seed) <= reflectProb ? reflect(rd,normal) : refracted;\n                rd = modifyDirectionWithRoughness(-normalOut, rd, roughness, seed);            \n            }\n        } else {\n            col *= getSkyColor(rd);\n\t\t\treturn col;\n        }\n    }  \n    return vec3(0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool reset = iFrame == 0;\n            \n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n        \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n    \n    vec3 ro = vec3(.5+2.5*cos(1.5+6.*mo.x), 1.+2.*mo.y, -.5+2.5*sin(1.5+6.*mo.x));\n    vec3 ta = vec3(.5, -.4, -.5);\n    mat3 ca = setCamera(ro, ta, 0.);    \n    vec3 normal;\n    \n    float fpd = data.x;\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        // Calculate focus plane.\n        float nfpd = worldhit(ro, normalize(vec3(.5,0,-.5)-ro), vec2(0, 100), normal).y;\n\t\tfragColor = vec4(nfpd, mo*iResolution.xy, iResolution.x);\n    } else { \n        vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n\n        // AA\n        p += 2.*hash2(seed)/iResolution.y;\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \n\n        // DOF\n        vec3 fp = ro + rd * fpd;\n        ro = ro + ca * vec3(randomInUnitDisk(seed), 0.)*.02;\n        rd = normalize(fp - ro);\n\n        vec3 col = render(ro, rd, seed);\n\n        if (reset) {\n           fragColor = vec4(col, 1);\n        } else {\n           fragColor = vec4(col, 1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "@iq and @Shane: I really like your quartic surface shaders! Thanks. I have added the Goursat intersection routine of iq to this shader and added/hacked (probably incorrect) support for dielectric materials to the ray tracer.",
        "date": "1559728136",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "4lSyDy",
        "hidden": 0
      },
      {
        "text": "Neat. ",
        "date": "1559725315",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "4tSyDy",
        "hidden": 0
      },
      {
        "text": "@Shane, yeah, I made that one yesterday: [url]https://www.shadertoy.com/view/3lj3DW[/url]. But I think I have a  bug, for some parameter values I have a discontinuity.",
        "date": "1559693382",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XtScDG",
        "hidden": 0
      },
      {
        "text": "Fantastic reference, and really aesthetically pleasing. I raytraced a [url=https://www.shadertoy.com/view/XsGyDh]generalized quartic surface[/url] on Shadertoy a while back, just for fun. Unfortunately, it'd be a little messy to include here. For specific quartic surfaces (like a Goursat tooth surface, for instance), a lot of the coefficients would be zero, which would trim it right back.",
        "date": "1559690809",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "4lByDG",
        "hidden": 0
      },
      {
        "text": "@iq Thanks! I have added the quartic sphere.",
        "date": "1559653309",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "XlByWG",
        "hidden": 0
      },
      {
        "text": "You can add the quartic sphere: [url]https://www.shadertoy.com/view/3tj3DW[/url]",
        "date": "1559648610",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4lSyWG",
        "hidden": 0
      },
      {
        "text": "WOW!!!!",
        "date": "1559611517",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "Mljyzd",
        "hidden": 0
      },
      {
        "text": "@iapafoto Thanks! I have added the Triangle (as a simple mesh) and will have a look at the Frustum intersection code.",
        "date": "1559586418",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "lt2yRd",
        "hidden": 0
      },
      {
        "text": "And [url=https://www.shadertoy.com/view/MlGcDz]Triangle[/url] by iq :)",
        "date": "1559576173",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "Ml2yzt",
        "hidden": 0
      },
      {
        "text": "Nice reference shader. \nQuite exotic but there is also [url=https://www.shadertoy.com/view/4s23DR]Frustum[/url] by robertcupisz",
        "date": "1559575435",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "Mt2yzt",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "tlB3WG",
      "date": "1560951455",
      "viewed": 37,
      "name": "Moon Flyby",
      "username": "SSHantaram",
      "description": "Raymarched plane with procedural noise perturbations.",
      "likes": 1,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching",
        "bump"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float BUMP_FACTOR = 0.5;\n\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    // interpolate between hashes of adjacent grid points\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// 3D noise layered in several octaves\nfloat layeredNoise(in vec3 x) {\n    return 0.7*noise(x) + 0.2*noise(x*4.0) + 0.07*noise(x*8.0) + 0.02*noise(x*16.0) + 0.01*noise(x*32.0);\n}\n\n// singed distance function of the y=0 plane\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\n// singed distanc function of plane with noise bump map\nfloat bumpPlaneSDF(vec3 p) {\n    // get distance to plane as usual\n    float d = planeSDF(p);\n    \n    vec3 normal;\n    float bump = 0.0;\n    \n  \t// only consider bumps if close to plane\n    if(d < BUMP_FACTOR*1.5)\n\t{\t\n\t\tnormal = vec3(0.0, 1.0, 0.0);\n\t\tbump = layeredNoise(p)*BUMP_FACTOR;\n\t}\n    return d - bump;\n}\n\n// singed distance function to enire scene\nfloat sceneSDF(vec3 samplePoint) {\n    return bumpPlaneSDF(samplePoint);\n}\n\n// returns the distanse to the scene along this ray\n// by raymarching using the sceneSDF\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    //raymarching loop\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // get distance to scene\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        // exit if close enough\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        // step closer\n        depth += dist;\n        // exit if too far\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// estimate normal by aproximatind the first deriviative of the sceneSDF\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// generate camera transform\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n// lambert shading coefficient with raymarched shadows\nfloat lambertShading(vec3 p, vec3 lightDir) {\n    vec3 n = estimateNormal(p);\n    \n    // lambert shading coefficient\n    float brightness = max(0.0, dot(-lightDir, n));\n    \n    // trace ray from surface point in direction of the light source\n    // offset in direction of the normal to avoid self intersection\n    float distToLight = shortestDistanceToSurface(p + n * EPSILON * 100.0, -lightDir, MIN_DIST, MAX_DIST);\n    \n    // in shadow\n    if (distToLight + 10.0 * EPSILON < MAX_DIST) {\n        return 0.0;\n    }\n    \n    return brightness;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n   \tvec3 eye = vec3(2.0*sin(iTime*0.3 - 3.0), 3.0, iTime);\n    mat3 viewToWorld = viewMatrix(eye, eye + vec3(2.0*sin(iTime*0.3), -3.0, 8.0), vec3(0.2*sin((iTime-1.0)*0.3), 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 lightDir = normalize(vec3(-1.0, -1.0, -3.0));\n    \n    vec3 ambientLight = vec3(0.01, 0.01, 0.005);\n    vec3 diffuseColor = vec3(0.8, 0.8, 0.8);\n    \n    vec3 color = ambientLight;\n    \n    color += diffuseColor*lambertShading(p, lightDir);\n    \n    fragColor = vec4(color, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "tlBGWG",
      "date": "1560884064",
      "viewed": 39,
      "name": "Flamethrower Flat",
      "username": "GabrieleGiuseppini",
      "description": "Experiments for the Flamethrower tool.\n\nNote: the noise is discontinuous at theta=1 because the shader requires a noise resolution lower than the one provided.\n\nTo be used in Floating Sandbox (https://gamejolt.com/games/floating-sandbox/353572).",
      "likes": 3,
      "published": 1,
      "flags": 0,
      "tags": [
        "fire"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4sf3Rn",
            "filepath": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
            "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define PI 3.14159265358979323844\n\nfloat GetNoise(vec2 uv) // -> (0.25, 0.75)\n{\n    float n = (texture(iChannel0, uv).r - 0.5) * 0.5;\n    n += (texture(iChannel0, uv * 2.0).r - 0.5) * 0.5 * 0.5;\n    //n += (texture(iChannel0, uv * 3.0).r - 0.5) * 0.5 * 0.5;\n    \n    return n + 0.5;\n}\n\n// -----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5); // (x=[-0.5, 0.5], y=[-0.5, 0.5])\n    uv.y /= (iResolution.x / iResolution.y); // obey aspect ratio\n    \n    float paramTime = iTime;\n    \n    ////////////////////////////////////////\n    \n    //\n    // Transform to polar coordinates\n    //\n    \n    // (r, a) (r=[0.0, 1.0], a=[0.0, 1.0 CCW from W])\n    uv = vec2(\n        length(uv) / sqrt(0.5), \n        (atan(uv.y, uv.x) / (2.0 * PI) + 0.5));\n    \n    // Scale radius to better fit in quad\n    uv.x *= 1.2;\n    \n    \n    //\n    // Flame time\n    //\n    \n    #define FlameSpeed 0.2\n    float flameTime = paramTime * FlameSpeed;\n    \n    \n    //\n    // Get noise for this fragment (in polar coordinates) and time\n    //\n    \n    #define NoiseResolution 0.5\n    float fragmentNoise = GetNoise(uv * vec2(NoiseResolution / 2.0, NoiseResolution) + vec2(-flameTime, 0.0));\n        \n    \n    //\n    // Randomize radius based on noise and radius\n    //\n    \n    float variationR = (fragmentNoise - 0.5);\n\n    // Straighten the flame at the center and make full turbulence outside\n    variationR *= smoothstep(0.05, 0.4, uv.x);\n    \n    // Scale variation\n    variationR *= 0.65;\n    \n    // Randomize!\n    uv.x += variationR;\n    \n    \n    \n    //\n    // Calculate brightness\n    //\n    \n    float radius1 = uv.x;\n    \n    // Focus (compress dynamics)\n    float radius2 = smoothstep(0.2, 0.35, radius1);\n    \n    float brightness = 1.0 - radius2;\n\n    \n    //\n    // Emit\n    //\n    \n    vec3 col1 = mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.6), smoothstep(0.1, 0.2, radius1));\n    col1 = mix(col1, vec3(1.0, 0.4, 0.1), smoothstep(0.18, 0.25, radius1));\n\n    // Blend with background\n    float alpha = brightness;\n    \n    fragColor = mix(vec4(1.0), vec4(col1, 1.0), alpha);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "tlSGWy",
      "date": "1560900956",
      "viewed": 36,
      "name": "Julia sets test - 19/06/2019",
      "username": "clepirelli",
      "description": "Simple julia sets test\n\nMouse controlled sets can be enabled in the top of the code\n\n",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "fractal",
        "julia"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "//uncomment this to enable mouse controlled set picking \n//#define MOUSE_CONTROLLED\n\nconst int MAX_ITER = 80;\n\nvec3 BASE_COLOR = vec3(205.0,100.0, 128.0) / 255.0;\n\n\n\nstruct complexNumber\n{\n    float real;\n    float imaginary;\n};\n\ncomplexNumber multiplyComplex(complexNumber a, complexNumber b)\n{\n\t//(x + yi) * (u + vi) = (xu - yv) + (xv + yu)i\n    \n    return complexNumber\n        (\n        \ta.real*b.real - a.imaginary*b.imaginary,\n            a.real*b.imaginary + b.real*a.imaginary\n        );\n}\n\ncomplexNumber toComplex(vec2 a)\n{\n\treturn complexNumber(a.x, a.y);\n}\n\ncomplexNumber addComplex(complexNumber a, complexNumber b)\n{\n\treturn complexNumber(a.real + b.real, a.imaginary + b.imaginary);\n}\n\nfloat modulusComplex(complexNumber a)\n{\n\treturn sqrt(a.real*a.real + a.imaginary*a.imaginary);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nconst float Epsilon = 1e-10;\n \nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + Epsilon) + Q.z);\n\treturn vec3(H, C, Q.x);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + Epsilon);\n    return vec3(HCV.x, S, HCV.z);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HUEtoRGB(in float H)\n{\n\tfloat R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B), .0, 1.);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv *= 3.0;\n    #ifdef MOUSE_CONTROLLED\n\tcomplexNumber C = toComplex((iMouse.xy / iResolution.xy - vec2(.5))*3.0);\n\t#else\n    complexNumber C = toComplex(vec2(cos(iTime), sin(iTime))*.5);\n    #endif\n    \n    complexNumber Z = toComplex(uv);\n    int itn = 0;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        Z =  addComplex(multiplyComplex(Z,Z), C);\n        \n        if(modulusComplex(Z) >= 2.0) \n        {\n        \titn = i;\n            break;\n        }\n    }\n    \n    float itRatio = float(itn) / float(MAX_ITER);\n    \n    vec3 col = BASE_COLOR;\n    col = RGBtoHSV(col);\n    col.x *= itRatio;\n    col = HSVtoRGB(col);\n\n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "tlSGzd",
      "date": "1560710377",
      "viewed": 109,
      "name": "Fun Fractal",
      "username": "wyatt",
      "description": "Playing with a thing I made the the other day",
      "likes": 1,
      "published": 3,
      "flags": 0,
      "tags": [
        "fractal",
        "complexnumbers"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "vec2 mul(vec2 a, vec2 b) {\n\treturn  mat2(a,-a.y,a.x) * b;\n}\nvec2 e (vec2 a) {\n\treturn exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\nvec2 ln (vec2 a) {\n\treturn vec2(log(length(a)),atan(a.y,a.x));\n}\nvec2 pw (vec2 a, vec2 b) {\n\treturn e(mul(ln(a),b));\n}\nvec2 pw (vec2 a, float n) {\n\tfloat f = n * atan(a.y,a.x);\n    return pow(length(a),n) * vec2(cos(f),sin(f));\n}\nvec4 col (vec2 U) {\n\t#define R iResolution.xy\n    float t = iTime*sqrt(iTime)/50.;\n    U = (U-0.5*R)/R.y;\n    U *= 1.+4./(1.-U.y);\n    float c = cos(.3*iTime), s = sin(.3*iTime);\n    U *= (.5+.25*sin(.11*iTime))*mat2(c,-s,s,c);\n    U.x += .367878;\n    vec2 z = U;\n    float o = mod(floor(t),5.);\n    float n = 20.*sin(.1*iTime);\n    float a = 0.;\n    for (float i = 0.; i < 15.; i++) {\n        if (length(z)>1e4) z *= -1.;\n        if (length(z)<1e-3) z *=2.;\n        z = ln(z);\n        z = pw(z,2.+sin(.09*iTime));\n        z = mix(e(z),z,0.1+0.1*sin(.1*iTime));\n        \n        a += exp(-dot(z,z));\n    }\n   \treturn .5+.5*(sin(2.*a*(1.+.1*vec4(1,2,3,4))));\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 \n    \te=col(U+vec2(.5,0)),\n        n=col(U+vec2(0,.5)),\n        w=col(U-vec2(.5,0)),\n        s=col(U-vec2(0,.5));\n    vec3 g = normalize(vec3(length(e)-length(w),length(n)-length(s),.1));\n    Q = g.z*((0.5+g.x+g.y)+length(g.xy))*0.25*(n+e+s+w)*exp(-.5*length(U-0.5*R)/R.y);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "tljGDh",
      "date": "1559696215",
      "viewed": 619,
      "name": "Shadertoy Discord server",
      "username": "nimitz",
      "description": "Come join us: https://discord.gg/XtmMN6E",
      "likes": 14,
      "published": 1,
      "flags": 0,
      "tags": [
        "discord",
        "community",
        "chat"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Procedural Discord logo\n// by nimitz 2019 (twitter: @stormoid)\n// the Discord logo is a property of Discord inc.\n\n/*\n\tShadertoy now has a discord server!\n\n\tCome join iq, poljere, fizzer, paniq, P_Malin, mmalex, mattz, reinder, rez and nimitz (me)\n\tand many more of us (and even more as they join) to discuss shader development and\n\treal-time rendering related topics, share resources, advancements and your own work.\n\t\n\tLink: https://discord.gg/XtmMN6E\n\tLink also on the shadertoy about page: https://www.shadertoy.com/about\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = gl_FragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float rx = abs(p.x);\n    float rx2 = rx*rx, rx3 = rx*rx*rx;\n    float rx4 = rx2*rx2;\n    float pds = p.y + 0.2;\n    float logo = abs(pds*pds)*2.0 + rx*3.6 - 1.2; //sides\n    logo = max(logo, rx3*8. + p.y*4.04 + - 0.75); // topmost\n    logo = max(logo, rx*rx4*24. - p.y*4.0 - 0.84); // bottommost\n    logo = max(logo, 0.72 - clamp(rx-0.19,-0.01,3.)*4. - p.y*3.2 + rx*0.4 -1.2); // chin\n    logo = max(logo, 0.8 - clamp(rx-0.1, 0., 3.)*4. + p.y*3.2 - 1.2); // forehead\n    logo = max(logo, (.5-abs(p.y*6.7 + 1.8 - 7.*rx2))*0.5 - rx*rx4*16. + 0.21); // mouth\n    logo = max(logo, (.5 - abs(p.y*7. - 1.85 + 6.5*rx2))*0.5 - rx*rx4*17.5 + 0.21); // brow\n    logo = 1.-min(1.-logo, 4.*length(vec2(abs(p.x*1.14)-0.16, p.y+.05))+.24); //eyes\n    vec3 col = mix(vec3(0.97), vec3(0.435, 0.521, 0.831), smoothstep(0.4, 0.41 + 1.5/iResolution.y, logo));\n    col *= pow(30.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.5 + 0.5;\n    fragColor = vec4(col, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "tljGWG",
      "date": "1560984668",
      "viewed": 3,
      "name": "Feedback Tunnel",
      "username": "TekF",
      "description": "Unwinding after some stress by making something simple and trippy.",
      "likes": 0,
      "published": 3,
      "flags": 32,
      "tags": [
        "feedback",
        "psychadelic"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "void mainImage( out vec4 o, in vec2 i )\n{\n\to = texelFetch(iChannel0,ivec2(i),0);\n\n    // linear -> gamma\n    o.rgb = pow( o.rgb, vec3(1./2.2) );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "void mainImage( out vec4 o, in vec2 i )\n{\n    // read previous frame with a perspective twist\n    vec2 aspect = iResolution.xy/sqrt(iResolution.x*iResolution.y);\n    vec2 uv = (i/iResolution.xy-.5)*aspect;\n    \n    // ray trace a plane at z=0, and map uv on that\n    // this way I can move the camera to control the feedback shape\n    // without adding redundant params for controlling the plane\n    vec3 ray = normalize(vec3(uv,1));\n\n    // adjust camera rotation\n    vec3 rot = .02*sin(iTime*vec3(1.618,1.,.382)*.3);\n    vec2 s = vec2(-1,1);\n    ray.xy = ray.xy*cos(rot.z)+ray.yx*s*sin(rot.z);\n    ray.yz = ray.yz*cos(rot.x)+ray.zy*s*sin(rot.x);\n    ray.zx = ray.zx*cos(rot.y)+ray.xz*s*sin(rot.y);\n\n\t// position camera (position of <0,0,-1> and 0 rotation = direct image)\n    vec3 camPos = vec3(rot.yx*vec2(-1.1,1.1),-1.01);\n    float t = (0.-camPos.z)/ray.z;\n    vec3 pos = camPos + ray*t;\n    uv = pos.xy;\n    \n    o = texture(iChannel0,uv/aspect+.5);\n    \n    // draw things on top\n    o.rgb = mix( o.rgb, step(0.,sin(iTime*vec3(16.18,20,1.618*.618*10.))), smoothstep(.02,.015,abs(max(abs(uv.x)-.5*aspect.x,abs(uv.y)-.5*aspect.y))) );\n\n    o.rgb = mix( o.rgb, sin(iTime*vec3(10))*.5+.5, smoothstep(.03,.025,length( uv-vec2(.5)*aspect*mix(sin(iTime*vec2(.618,1.382)),sin(iTime*vec2(1.618,2.)),.3) )) );\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "tsBSWD",
      "date": "1554044046",
      "viewed": 5063,
      "name": "Colored lines",
      "username": "hamtarodeluxe",
      "description": "2d IFS fractal evolving with time and along up axis.",
      "likes": 156,
      "published": 1,
      "flags": 32,
      "tags": [
        "lines",
        "color",
        "ifs"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "//bloom and DOF. Check buffer's #define to tweak the shape\nfloat [] blurWeights = float[](0.002216,\n   0.008764,\n   0.026995,\n   0.064759,\n   0.120985,\n   0.176033,\n   0.199471,\n   0.176033,\n   0.120985,\n   0.064759,\n   0.026995,\n   0.008764,\n   0.002216);\n\nvec4 blur (vec2 uv)\n{\n    vec4 res;\n\tfor (int x = - 6; x < 6; x ++)\n    {\n    \tfor (int y = -6 ; y < 6; y ++)\n        {\n            res += blurWeights[x+6]*blurWeights[y+6] * texture( iChannel0, ( uv * iResolution.xy + vec2 (x,y) ) / iResolution.xy);\n        }\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n   \tvec4 buf = texture( iChannel0, ( uv));\n    vec3 blr = blur(uv).rgb;\n    float near =3.; float mid = 9.; float far = 15.;\n    float curve = smoothstep(0.,near,buf.w)* smoothstep(far,mid,buf.w);\n    vec3 col = mix (blr,buf.rgb,curve);\n    col.rgb += 0.5*blr;\n\n    fragColor = vec4 (col,1.);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "//Marching parameters\n#define MAXSTEPS 50\n#define HITTHRESHOLD 0.009\n#define FAR 25.\n//AA : change to 1 to turn it off\n#define AA 2\n//IFS iterations : try 2 or 3\n#define NIFS 6\n//scale and translate for the IFS in-loop transformation\n#define SCALE 2.3\n#define TRANSLATE 3.5\n\nmat2x2 rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2x2(c, -s,\n\t\t\t\t  s, c);\n}\n\nvec4 sd2d(vec2 p, float o)\n{\n    float time = 0.2*o+0.6*iTime;\n \tfloat s =0.5;\n    p*= s;\n    float RADIUS =(1.+sin(iTime));\n    int i;\n    vec3 col;  \n    p = p*rot(-0.4*time);// twist\n\n    for ( i = 0; i<NIFS; i++)\n    {        \n        if (p.x<0.) {p.x = -p.x;col.r++;}\n\t\tp = p*rot(0.9*sin(time));\n        if (p.y<0.) {p.y = -p.y;col.g++; }\n        if (p.x-p.y<0.){ p.xy = p.yx;col.b++;}        \n      \tp = p*SCALE-TRANSLATE;\n        p = p*rot(0.3*(iTime));\n    }\n    \n    float d = 0.425*(length(p)-RADIUS) * pow(SCALE, float(-i))/s;\n    col/=float(NIFS);\n    vec3 oc = mix(vec3(0.7,col.g,0.2),vec3(0.2,col.r,0.7), col.b);\n    \n    return vec4(oc,d);\n}\n\nvec4 map (vec3 p)\n{\n\treturn sd2d(p.xz,p.y);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float h = 0.;\n    float k =3.5;//shadowSmooth\n    float res = 1.;\n    float t = 0.2; //bias\n    for (int i = 0; t < 15.; i++) // t < shadowMaxDist\n    {\n        h = map(ro + rd * t).w;\n\t\tres = min(res, k*h / t);\n        if (h < HITTHRESHOLD)\n        {\n           break;\n        }\n        t = t + h;\n    }\n    return clamp(res+0.05,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    //camera\n    float height = -0.4;\n    float rot=iTime*0.1;\n    float dist= 9.+1.*sin(0.5*iTime);\n    vec3 ro = dist * vec3(cos(rot),height,sin(rot));\n   \tvec3 lookAt = vec3 (0.,0.,0.);\n    vec3 fw = normalize(lookAt-ro);\n    //tilting camera for a \"weirder\" feel when rotating around Y axis\n    vec3 right = normalize(cross(vec3(0.,1.,1.0), fw));\n    vec3 up = normalize(cross (fw, right));\n    right = normalize(cross(up,fw));\n    \n    //light\n    rot+=sin(iTime)*0.2;\n    vec3 lightPos =  dist * vec3(cos(rot),height,sin(rot));\n    \n    //raymarch\n    vec3 pos, closest;\n    float t;\n    float smallest;\n    int i;\n    vec3 sdfCol; \n    vec3 col;\n    \n    for (int x=0; x<AA;x++)\n    for (int y=0; y<AA;y++)\n    {\n        t = 0.; smallest = 500.;\n        vec2 o = vec2(float(x),float(y)) / float(AA) - 0.5;\n        vec2 uv = (fragCoord+o)/iResolution.xy;\n        uv -= 0.5;\n        uv.x *= iResolution.x/iResolution.y; \n        vec3 rd = normalize( fw *0.5 + right * uv.x + up * uv.y);  \n        \n        for ( i=0; i<MAXSTEPS; i++)\n        {\n            pos = ro + rd *t;   \n            vec4 mr = map(pos);\n            float d = mr.w;\n            if (d < smallest) smallest = d; closest = pos; sdfCol = mr.rgb;\n            if (abs(d)<HITTHRESHOLD || t> FAR) {break;}\n            t +=d;\n        }   \n        pos = closest;\n        vec3 c;\n        if (t<FAR)\n        { \n            c = sdfCol; \n            vec3 toLight = normalize(lightPos-pos);\n            float s = shadow(pos,toLight);\n            c*=s; \n          \tc = mix(c, 1.5*c,1.-s);\n        }\n        else \n        {\n            c = vec3(0.);                \n        }     \n        col += c;\n    }\n    col/=float(AA*AA);\n    \n    fragColor = vec4 (col,t);\n}\n",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "That's in some fantastically unusual dimension",
        "date": "1557036941",
        "username": "gambhiro",
        "userpicture": "/img/profile.jpg",
        "id": "ltScWD",
        "hidden": 0
      },
      {
        "text": "Next Apple wallpapers! That's amazing",
        "date": "1554758799",
        "username": "Jackaru",
        "userpicture": "/media/users/Jackaru/profile.png",
        "id": "XlSczR",
        "hidden": 0
      },
      {
        "text": "Beautiful",
        "date": "1554676412",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "MtlcDl",
        "hidden": 0
      },
      {
        "text": "Beauty!",
        "date": "1554340946",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4tXyWl",
        "hidden": 0
      },
      {
        "text": "I like that the understated title doesn't prepare you for this gem :)\n",
        "date": "1554322682",
        "username": "mrange",
        "userpicture": "/img/profile.jpg",
        "id": "MlsyDf",
        "hidden": 0
      },
      {
        "text": "omg :)\n",
        "date": "1554322617",
        "username": "mrange",
        "userpicture": "/img/profile.jpg",
        "id": "llsyDf",
        "hidden": 0
      },
      {
        "text": "yeah, that looks great. nice choice of colors too.",
        "date": "1554310890",
        "username": "otaviogood",
        "userpicture": "/media/users/otaviogood/profile.jpeg",
        "id": "ltlyDf",
        "hidden": 0
      },
      {
        "text": "Woow thank you ! \n@xfg You might also increase AA then :-)",
        "date": "1554306693",
        "username": "hamtarodeluxe",
        "userpicture": "/img/profile.jpg",
        "id": "llscWf",
        "hidden": 0
      },
      {
        "text": "Yes shader of the week! Well deserved!\n@xfg or buy wallpaper engine and use the html tag for a live wallpaper.",
        "date": "1554302541",
        "username": "felipunkerito",
        "userpicture": "/img/profile.jpg",
        "id": "MllcWf",
        "hidden": 0
      },
      {
        "text": "pause, toggle fullscreen, take screenshot, then you have a wonderful wallpaper.\nReally love it, thanks!",
        "date": "1554299061",
        "username": "xfg",
        "userpicture": "/img/profile.jpg",
        "id": "ltlcWf",
        "hidden": 0
      },
      {
        "text": "pause, toggle fullscreen, take screenshot, then you have a wonderful wallpaper.\nReally love it, thanks!",
        "date": "1554299044",
        "username": "xfg",
        "userpicture": "/img/profile.jpg",
        "id": "MlsyWf",
        "hidden": 0
      },
      {
        "text": "I could watch this for hours!",
        "date": "1554273995",
        "username": "MacSlow",
        "userpicture": "/media/users/MacSlow/profile.jpeg",
        "id": "ltscDX",
        "hidden": 0
      },
      {
        "text": "great!!!!",
        "date": "1554272690",
        "username": "kiyamada96",
        "userpicture": "/img/profile.jpg",
        "id": "MtlcDX",
        "hidden": 0
      },
      {
        "text": "Cool!\nIt's like the splash screen of unity.",
        "date": "1554265698",
        "username": "kaneta",
        "userpicture": "/media/users/kaneta/profile.png",
        "id": "ltsyDX",
        "hidden": 0
      },
      {
        "text": ":love: marvelous :love:",
        "date": "1554202374",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "4llcWf",
        "hidden": 0
      },
      {
        "text": "Thank you ! I'm really glad you like it :-)",
        "date": "1554115839",
        "username": "hamtarodeluxe",
        "userpicture": "/img/profile.jpg",
        "id": "4llyWX",
        "hidden": 0
      },
      {
        "text": ":love:",
        "date": "1554086461",
        "username": "felipunkerito",
        "userpicture": "/img/profile.jpg",
        "id": "MtfyDf",
        "hidden": 0
      },
      {
        "text": "This is awesome.",
        "date": "1554083013",
        "username": "bignobody",
        "userpicture": "/media/users/bignobody/profile.jpeg",
        "id": "ltfyDf",
        "hidden": 0
      },
      {
        "text": "Truly beautiful!",
        "date": "1554069338",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MtfcWf",
        "hidden": 0
      },
      {
        "text": "Gorgeous!!",
        "date": "1554060503",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "MlXyWf",
        "hidden": 0
      },
      {
        "text": "relaxing",
        "date": "1554050104",
        "username": "balkhan",
        "userpicture": "/img/profile.jpg",
        "id": "ltfyDX",
        "hidden": 0
      },
      {
        "text": "mesmerizing!",
        "date": "1554045177",
        "username": "spleenooname",
        "userpicture": "/media/users/spleenooname/profile.jpeg",
        "id": "llfcWX",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ttB3RV",
      "date": "1560442092",
      "viewed": 321,
      "name": "cables",
      "username": "yuntaRobo",
      "description": "Inspired by various torus implementations, I tried this.",
      "likes": 28,
      "published": 3,
      "flags": 0,
      "tags": [
        "torus"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "const float PI = 3.1415926;\nconst float E = 0.003;\n\n\nmat2 rotate2D(float r)\n{\n    return mat2(cos(r), -sin(r), sin(r), cos(r));\n}\n\nvec2 de(vec3 p)\n{\n    vec2 o = vec2(100.0, 0.0);\n    vec3 p_ = p;\n    \n    // trasition\n    float trasition = smoothstep(0.0, 1.0, mod((iTime - 3.0), 4.0)) + floor((iTime - 3.0) * 0.25);\n    trasition *= PI * 0.5;\n    p.xy *= rotate2D(trasition * 2.0);\n    p.yz *= rotate2D(trasition);\n    p.xz *= rotate2D(iTime * 0.35);\n\n    // y-axis repetition\n    p.y += atan(p.z, p.x) * 0.5 * 4.0;\n    p.y = mod(p.y, PI) - PI * 0.5;\n\n    // many torus !\n    float r = atan(p.x, p.z) * 4.0;\n    const int ite = 23;\n    for (int i = 0; i < ite; i++)\n    {\n        r += 1.0 / float(ite) * PI * 2.0;\n        float s = 0.5 + sin(float(i) * 1.618 * PI * 2.0) * 0.25;\n        s += sin(iTime + float(i)) * 0.2;\n\n        vec2 q = vec2(length(p.xz) + cos(r) * s - 3.0, p.y + sin(r) * s);\n        float d = length(q) - 0.06;\n        \n        if (d < o.x)\n        {\n            o.x = d;\n            o.y = float(i);\n        }\n    }\n\n    return o;\n}\n\n// iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal(vec3 p)\n{\n    float h = E;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n            k.xyy * de(p + k.xyy * h).x + \n            k.yyx * de(p + k.yyx * h).x + \n            k.yxy * de(p + k.yxy * h).x + \n            k.xxx * de(p + k.xxx * h).x\n        );\n}\n\nvoid trace(vec3 ro, vec3 rd, inout vec3 color)\n{\n    vec3 ro_ = ro;\n    \n    float ad = 0.0;\n    for (int i = 0; i < 128; i++)\n    {\n        vec2 res = de(ro) * 0.5;\n        ro += rd * res.x;\n        ad += res.x;\n        \n        if (res.x < E)\n        {\n            // light direction\n            vec3 ld = normalize(vec3(1.0, 1.0, 0.5));\n            \n            // normal\n            vec3 n = normal(ro);\n            \n            // albedo\n            color = mix(vec3(1.0, 0.5, 0.2), vec3(0.2, 0.6, 1.0) * 2.5, fract(res.y * 1.618));\n            color = mix(color, vec3(10.0, 0.0, 0.0), pow(fract((res.y + 10.5) * 1.618), 10.0));\n            \n            // diffuse\n            color *= pow(dot(n, ld) * 0.5 + 0.5, 3.0);\n            \n            // specular\n            vec3 h = normalize(ld + normalize(ro_ - ro));\n            color += pow(max(dot(h, n), 0.0), 20.0) * 2.5;\n            \n            // ao\n            float rim = float(i) / (128.0 - 1.0);\n            color *= exp(-rim * rim * 30.0) * 0.5;\n            \n            // fog\n            color *= exp(-ad * ad * 0.01);\n\n            return;\n        }\n        else if (ad > 25.0)\n        {\n            break;\n        }\n    }\n    \n    // background\n//    color = vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // ray\n    vec3 ro = vec3(0.0, 0.0, 8.5);\n    vec3 rd = normalize(vec3(p, -1.5));\n\n    // ray marching\n    trace(ro, rd, color);\n    \n    // gamma correction\n    color = pow(color, vec3(0.454545));\n    \n    fragColor = vec4(color, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "really pretty!",
        "date": "1560618970",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "XlScW3",
        "hidden": 0
      },
      {
        "text": "Thanks for comments !",
        "date": "1560562089",
        "username": "yuntaRobo",
        "userpicture": "/media/users/yuntaRobo/profile.jpeg",
        "id": "MtjcDV",
        "hidden": 0
      },
      {
        "text": "Nice",
        "date": "1560470517",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MtjyDK",
        "hidden": 0
      },
      {
        "text": "Very nice, and compact.",
        "date": "1560465616",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "lt2cWK",
        "hidden": 0
      },
      {
        "text": "Dope!",
        "date": "1560464844",
        "username": "Yusef28",
        "userpicture": "/img/profile.jpg",
        "id": "lljcWK",
        "hidden": 0
      },
      {
        "text": "A nice wiring loom!",
        "date": "1560444243",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Xt2cDV",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ttB3Rt",
      "date": "1560686113",
      "viewed": 297,
      "name": "Waving particle surface",
      "username": "jaszunio15",
      "description": "Common: Blur and useful functions\nA:  Main particle system\nB,C,D and Image: Blur\n\nEnjoy :)",
      "likes": 25,
      "published": 1,
      "flags": 32,
      "tags": [
        "waves",
        "vfx",
        "particles"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "//Bluring the D Buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = blur(iChannel0, fragCoord, iResolution.xy);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "//1/512\n#define FREQ_STEP (0.001953125 * 3.0)\n\n#define PI 3.1415927\n#define TWO_PI 6.283185\n\n//Postprocess setting\n#define BLUR_STRENGTH 1.0\n#define BLUR_RANGE 2.5\n\nfloat pow3(in float x)\n{\n \treturn x*x*x;   \n}\n\nfloat hash1_2(in vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);   \n}\n\nvec2 hash2_3(in vec3 x)\n{\n    return fract(sin(x * mat2x3(20.5283, 24.1994, 70.2913, \n                                89.9132, 57.1454, 45.1211)) * 492.194);\n}\n\n                 \n//Simple interpolated noise\nvec2 noise2_3(vec3 coord)\n{\n    //vec3 f = fract(coord);\n    vec3 f = smoothstep(0.0, 1.0, fract(coord));\n \t\n    vec3 uv000 = floor(coord);\n    vec3 uv001 = uv000 + vec3(0,0,1);\n    vec3 uv010 = uv000 + vec3(0,1,0);\n    vec3 uv011 = uv000 + vec3(0,1,1);\n    vec3 uv100 = uv000 + vec3(1,0,0);\n    vec3 uv101 = uv000 + vec3(1,0,1);\n    vec3 uv110 = uv000 + vec3(1,1,0);\n    vec3 uv111 = uv000 + vec3(1,1,1);\n    \n    vec2 v000 = hash2_3(uv000);\n    vec2 v001 = hash2_3(uv001);\n    vec2 v010 = hash2_3(uv010);\n    vec2 v011 = hash2_3(uv011);\n    vec2 v100 = hash2_3(uv100);\n    vec2 v101 = hash2_3(uv101);\n    vec2 v110 = hash2_3(uv110);\n    vec2 v111 = hash2_3(uv111);\n    \n    vec2 v00 = mix(v000, v001, f.z);\n    vec2 v01 = mix(v010, v011, f.z);\n    vec2 v10 = mix(v100, v101, f.z);\n    vec2 v11 = mix(v110, v111, f.z);\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n//Simple interpolated noise\nfloat noise1_2(in vec2 uv)\n{\n    vec2 f = fract(uv);\n    //vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    \n    float v00 = hash1_2(uv00);\n    float v01 = hash1_2(uv01);\n    float v10 = hash1_2(uv10);\n    float v11 = hash1_2(uv11);\n    \n    float v0 = mix(v00, v01, f.y);\n    float v1 = mix(v10, v11, f.y);\n    float v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n//Blur function\nvec4 blur(in sampler2D sampler, in vec2 fragCoord, in vec2 resolution)\n{\n    vec2 uv = fragCoord / resolution;\n    float blurStrength = distance(uv, vec2(0.5));\n    blurStrength = pow(blurStrength, BLUR_RANGE) * (resolution.x / 100.0) * BLUR_STRENGTH;\n    vec4 sum = vec4(0.0);\n    vec2 pixelSize = vec2(1.0) / resolution;\n\tfor (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n     \tfor (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            sum += texture(sampler, uv + vec2(x, y) * pixelSize * blurStrength);\n        }\n    }\n\n    return sum / 9.0;\n}",
        "name": "Common",
        "description": "",
        "type": "common"
      },
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "/*\n\tMain particle system.\n\tQuite hard to make it realtime efficient. \t\n*/\n\n//Comment to make all particles have the same size\n#define RANDOMIZED_SIZE\n\n//More iterations = bigger distortion. You can increase the number of iteratons if you have better PC.\n#define PARTICLE_ITERATIONS 6.0\n\n//Particle settings\n#define PARTICLE_RADIUS 0.15\n#define PARTICLE_RADIUS2 0.3\n#define PARTICLE_SIZE_VARIATION 0.2\n#define PARTICLE_COLOR vec3(0.3, 0.9, 0.9) * 1.0\n#define BRIGHTNESS 0.45\n\n//Calculates particle movement\nvec2 cellPointFromRootUV(vec2 rootUV, vec2 originalUV, out float len)\n{\n    vec2 displacement = (noise2_3(vec3(rootUV * 0.07 + iTime * 0.3, 0.5 * (iTime + 0.1) * 1.0 + noise1_2(originalUV * 0.04))) - 0.5);\n \tlen = dot(displacement, displacement);\n    return displacement * 3.0 * (PARTICLE_ITERATIONS) + 0.5 + rootUV;   \n}\n\n//Calculates particle size\nfloat particleFromUVAndPoint(in vec2 uv, in vec2 point, in vec2 rootUV, in float pixelSize)\n{\n\tfloat dist = distance(uv, point);\n#ifdef RANDOMIZED_SIZE\n    dist += (hash1_2(rootUV * 10.0) - 0.5) * PARTICLE_SIZE_VARIATION;\n#endif\n    float particle = 1.0 - smoothstep(PARTICLE_RADIUS - dist * 0.05, PARTICLE_RADIUS2 - dist * 0.05 + pixelSize, dist);\n    return particle * particle;\n}\n\n//Particle system\nvec3 surfaceParticles(in vec2 uv, in float pixelSize)\n{\n    vec3 particles = vec3(0.0);\n \tvec2 rootUV = floor(uv);\n    \n   \tvec2 tempRootUV;\n    vec2 pointUV;\n    float dist;\n    vec3 color;\n    for (float x = -PARTICLE_ITERATIONS; x <= PARTICLE_ITERATIONS; x += 1.0)\n    {\n        for (float y = -PARTICLE_ITERATIONS; y <= PARTICLE_ITERATIONS; y += 1.0)\n        {\n            tempRootUV = rootUV + vec2(x, y);\n            pointUV = cellPointFromRootUV(tempRootUV, uv, dist);\n          \tcolor = mix(vec3(0), PARTICLE_COLOR, pow(smoothstep(0.3, 0.0, dist), 4.0));\n            particles += particleFromUVAndPoint(uv, pointUV, tempRootUV, pixelSize) * color;\n        }\n    }\n    \n    return particles;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    float vignette = 1.0 - smoothstep(0.5, 1.3, length(uv* vec2(1.0, iResolution.x / iResolution.y)));\n    \n    //for antialiasing\n    float pixelSize = 1.5 / iResolution.x;\t\n    \n    uv *= 70.0;\n    pixelSize *= 70.0;\n    \n    vec3 particles = surfaceParticles(uv, pixelSize) * BRIGHTNESS;\n    \n    //postprocess\n    particles = smoothstep(-0.2, 0.8, particles * vignette);\n    \n    fragColor = vec4(particles, 1.0);\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XsXGR8",
            "channel": 0
          }
        ],
        "code": "//Bluring the A Buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = blur(iChannel0, fragCoord, iResolution.xy);\n}",
        "name": "Buffer B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4sXGR8",
            "channel": 0
          }
        ],
        "code": "//Bluring the B Buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = blur(iChannel0, fragCoord, iResolution.xy);\n}",
        "name": "Buffer C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XdfGR8",
            "channel": 0
          }
        ],
        "code": "//Bluring the C Buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = blur(iChannel0, fragCoord, iResolution.xy);\n}",
        "name": "Buffer D",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "you know the sense of quality picture",
        "date": "1560760022",
        "username": "avin",
        "userpicture": "/media/users/avin/profile.png",
        "id": "MlByW3",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ttfGWl",
      "date": "1558007349",
      "viewed": 1195,
      "name": "Triangle - closest",
      "username": "iq",
      "description": "Closest point on triangle. The blue sphere is the evaluation point. The orange sphere marks the point in the triangle closest to the blue sphere.",
      "likes": 25,
      "published": 3,
      "flags": 0,
      "tags": [
        "3d",
        "triangle",
        "closest"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Closest point on triangle. The blue sphere is the evaluation\n// point.The orange sphere marks the point on the triangle\n// closest to the blue sphere.\n\n// Other triangle functions:\n//\n// Occlusion:    https://www.shadertoy.com/view/XdjSDy\n// Distance:     https://www.shadertoy.com/view/4sXXRN\n// Intersection: https://www.shadertoy.com/view/MlGcDz\n// Closest:      https://www.shadertoy.com/view/ttfGWl\n\n\n\n\n#define AA 5\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat maxcomp( in vec2 v ) { return max(v.x,v.y); }\n\nvec3 closestTriangle( in vec3 v0, in vec3 v1, in vec3 v2, in vec3 p )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross( v10, v02 );\n\n#if 0\n    // method 1, in 3D space\n    if( dot(cross(v10,nor),p0)<0.0 ) return v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    if( dot(cross(v21,nor),p1)<0.0 ) return v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    if( dot(cross(v02,nor),p2)<0.0 ) return v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    return p - nor*dot(nor,p0)/dot2(nor);\n    \n#else    \n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0/dot2(nor);\n    float u = d*dot( q, v02 );\n    float v = d*dot( q, v10 );\n    float w = 1.0-u-v;\n    \n         if( u<0.0 ) { w = clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 ); u = 0.0; v = 1.0-w; }\n    else if( v<0.0 ) { u = clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 ); v = 0.0; w = 1.0-u; }\n\telse if( w<0.0 ) { v = clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 ); w = 0.0; u = 1.0-v; }\n    \n    return u*v1 + v*v2 + w*v0;\n#endif    \n}\n\n//==================================================================\n\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return t;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in float h )\n{\n    return (h-ro.y)/rd.y;\n}\n\n\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                 in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    return -1.0;\n}\n\nvec3 nPlane( void )\n{\n    return vec3(0.0,1.0,0.0);\n}\n\nvec3 nTriangle( in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    \n    return normalize( cross( v1v0, v2v0 ) );\n}\n\nvec3 nCylinder( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\nvec3 nSphere( in vec3 pos, in vec4 sph )\n{\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat oTriangle( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = normalize( v0 - pos );\n    vec3 b = normalize( v1 - pos );\n    vec3 c = normalize( v2 - pos );\n    \n    float s = sign(dot(v0-pos,cross(v1-v0,v2-v1))); // side of the triangle\n\n    return s*(dot( nor, normalize( cross(a,b)) ) * acos( dot(a,b) ) +\n              dot( nor, normalize( cross(b,c)) ) * acos( dot(b,c) ) +\n              dot( nor, normalize( cross(c,a)) ) * acos( dot(c,a) ) ) / 6.2831;\n}\n\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  di = sph.xyz - pos;\n    float l  = length(di);\n    float nl = dot(nor,di/l);\n    float h  = l/sph.w;\n    float h2 = h*h;\n    float k2 = 1.0 - h2*nl*nl;\n\n    float res = max(0.0,nl)/h2;\n    if( k2 > 0.0 ) \n        res = pow( clamp(0.5*(nl*h+1.0)/h2,0.0,1.0), 1.5 );\n\n    return res;\n}\n\n//=====================================================\n\nstruct Scene\n{\n    vec3 v1;\n\tvec3 v2;\n\tvec3 v3;\n    vec3 pA;\n    vec3 pB;\n};\n    \n\n\nvec2 intersect( in vec3 ro, in vec3 rd, in Scene scn )\n{\n    vec2 res = vec2(1e10,-1.0);\n    \n    float t = iPlane(ro,rd,-1.0);\n    if( t>0.0 ) res = vec2( t, 1.0 );\n    \n    t = iTriangle( ro, rd, scn.v1, scn.v2, scn.v3 );\n    if( t>0.0 ) res = vec2( t, 2.0 );\n    \n    t = iSphere( ro, rd, vec4(scn.pA,0.07) );\n    if( t>0.0 && t<res.x ) res = vec2( t, 3.0 );\n    \n    t = iSphere( ro, rd, vec4(scn.pB,0.07) );\n    if( t>0.0 && t<res.x ) res = vec2( t, 4.0 );\n                \n\tt = iCylinder( ro, rd, scn.pA, scn.pB, 0.02 );\n    if( t>0.0 && t<res.x ) res = vec2( t, 5.0 );\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float objID, in Scene scn )\n{\n    if( objID<1.5 ) return nPlane();\n    if( objID<2.5 ) return nTriangle( scn.v1, scn.v2, scn.v3 );\n    if( objID<3.5 ) return nSphere( pos, vec4(scn.pA,0.07) );\n    if( objID<4.5 ) return nSphere( pos, vec4(scn.pB,0.07) );\n    if( objID<5.5 ) return nCylinder( pos, scn.pA, scn.pB, 0.02 );\n    return vec3(0.0,1.0,0.0);\n}\n\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float objID, in Scene scn )\n{\n    float occ = 1.0;\n\n    occ *= clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    occ *= 1.0-oSphere( pos, nor, vec4(scn.pA,0.07) );\n    occ *= 1.0-oSphere( pos, nor, vec4(scn.pB,0.07) );\n\n    if( abs(objID-2.0)>0.5 ) occ *= 1.0-oTriangle( pos, nor, scn.v1, scn.v2, scn.v3 );\n    \n    return occ;\n}\n\nconst vec3 lig = normalize(vec3(1.0,0.9,0.7));\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec4 tot = vec4(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // 2 pixel wide triangular kernel\n        vec2 o = 2.0*vec2(float(m),float(n)) / float(AA-1) - 1.0;\n        float r = maxcomp(abs(o)); o = r*normalize(o*(2.0+abs(o))+0.000001); // square to circle\n        float w = 1.0 - r*0.75;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float t = iTime - (1.0/30.0)*float(m*AA+n)/float(AA*AA-1);\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float t = iTime;\n        float w = 1.0;\n#endif\n\n        Scene scn;\n        scn.v1 = 1.8*vec3(1.0,0.5,1.0)*cos( 0.1*t + vec3(0.0,1.0,1.0) + 0.0 );\n        scn.v2 = 1.8*vec3(1.0,0.5,1.0)*cos( 0.1*t + vec3(0.0,2.0,3.0) + 2.0 );\n        scn.v3 = 1.8*vec3(1.0,0.5,1.0)*cos( 0.1*t + vec3(0.0,3.0,5.0) + 4.0 );\n        scn.pA = vec3(1.1*cos(1.5*t+1.0),0.8+0.4*cos(t*1.1),1.1*cos(1.3*t+3.0));\n        scn.pB = closestTriangle( scn.v1, scn.v2, scn.v3, scn.pA );\n\n        \n        vec3 ro = vec3(0.0, 0.25, 4.0 );\n        vec3 rd = normalize( vec3(p,-2.0) );\n\n        vec3 col = vec3(0.0);\n\n        vec2 tm = intersect( ro, rd, scn );\n        if( tm.y>0.0 )\n        {\n            float t = tm.x;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, tm.y, scn);\n            nor *= -sign(dot(nor,rd));\n            float occ = calcOcclusion( pos, nor, tm.y, scn );\n            col += vec3(1.4)*occ;\n            col *= 0.55+0.45*cos(tm.y*3.5+vec3(0.0,1.0,1.5));\n            col *= exp( -0.05*t );\n        }\n\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\n        tot += w*vec4(col,1.0);\n#if AA>1\n    }\n    tot.xyz /= tot.w;\n#endif\n\n    \n    fragColor = vec4( tot.xyz, 1.0 );\n}\n\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "i made a fork, with slightly improved barycentric-space structure. (and with optional mix(step()) version:\nhttps://www.shadertoy.com/view/WlB3zW\n\nred dot does not reach triangle corners often enough, those are the trickier dual-cases.\n\n3d space method should swap [if()] for [else if() ], dot(cross)) as condition is a bit expensive.\nthen again, the cross() is too expensive to be within a condition, which is why barycentric approach is superior, with only 1 initial cross() that may as well be a precalculated buffer, and better parallelization.\n\nDo you care enough to extend  into the woderous world of Cartesian 3d shadows of 4d objects with barycenters of a simplex?\nthe 4d equivalent to the roundedBox has useful 3d shadows, a lot of them are quite triangular, and then you just make the box very thin along one of 4 domains.",
        "date": "1558607830",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "XtBcR3",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ttjGzd",
      "date": "1560820490",
      "viewed": 66,
      "name": "Wavy hexagon",
      "username": "edo_m18",
      "description": "Wavy animation hexagon.",
      "likes": 7,
      "published": 1,
      "flags": 0,
      "tags": [
        "wavy",
        "animation",
        "hexagon"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "float hexDist(vec2 p)\n{\n    p = abs(p);\n    float d = dot(p, normalize(vec2(1.0, 1.73)));\n\treturn max(p.x, d);\n}\n\nvec4 hexCoords(vec2 uv)\n{\n    vec2 r = vec2(1.0, 1.73);\n    vec2 h = 0.5 * r;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n    \n    vec2 gv = length(a) < length(b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = 0.5 - hexDist(gv);\n    vec2 id = uv - gv;\n    \n    return vec4(x, y, id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    uv *= 10.0;\n\n    vec3 col = vec3(0);\n    vec4 hc = hexCoords(uv);\n\n    float time = iTime * 0.5;\n    float wavy = pow(sin(length(hc.zw) - time), 4.0) + 0.1;\n    \n\tfloat c = smoothstep(0., 15./iResolution.y, hc.y);    \n    \n    col = vec3(c * wavy);\n    \n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "@FabriceNeyret2 Thanks! I modified it!",
        "date": "1560865959",
        "username": "edo_m18",
        "userpicture": "/media/users/edo_m18/profile.jpeg",
        "id": "MtBcDc",
        "hidden": 0
      },
      {
        "text": "nice !\n\nNB: for antialiasing to work at any resolution, use true pixel width rather than magic number 0.02: \nc = smoothstep(0., 15./iResolution.y, hc.y);\n-> ",
        "date": "1560856944",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "llByDc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "ttlGWj",
      "date": "1560935170",
      "viewed": 30,
      "name": "Voxel tiles",
      "username": "tyomalu",
      "description": "attempt to render voxel tiles",
      "likes": 3,
      "published": 1,
      "flags": 0,
      "tags": [
        "voxel"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "const float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst int tileWidth = 5;\nconst int tileHeight = 5;\nconst int tileDepth = 5;\n    \nint tile[] = int[](\n    0,0,0,0,0,\n    0,0,0,0,0,\n    0,0,1,0,0,\n    0,0,0,0,0,    \n    0,0,0,0,0,        \n    \n    0,0,0,0,0,\n    0,0,0,0,0,\n    0,0,1,0,0,\n    0,0,0,0,0,    \n    0,0,0,0,0,        \n\n    0,0,0,0,0,\n    0,0,1,0,0,\n    0,1,1,1,0,\n    0,0,1,0,0,    \n    0,0,0,0,0,        \n\n    0,0,0,0,0,\n    0,1,1,1,0,\n    0,1,1,1,0,\n    0,1,1,1,0,    \n    0,0,0,0,0,        \n\n    0,0,1,0,0,\n    0,1,1,1,0,\n    1,1,1,1,1,\n    0,1,1,1,0,    \n    0,0,1,0,0\n);\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Plane {\n    vec3 position;\n    vec3 normal;\n};    \n \nstruct Intersection{\n\tfloat t;\n\tfloat hit;\n\tvec3  hitPoint;\n\tvec3  normal;\n};\n    \nint voxelAt(ivec3 pos) {\n    return tile[(pos.z % tileDepth) * tileHeight * tileWidth + (pos.y % tileHeight) * tileWidth + (pos.x % tileWidth)];\n}\n\nIntersection intersectPlane(Ray ray, Plane p){\n    Intersection i;\n    i.t = 1.0e+30;\n\ti.hit = 0.0;\n\ti.hitPoint = vec3(0.0);\n    i.normal = vec3(0.0); \n    \n\tfloat d = -dot(p.position, p.normal);\n\tfloat v = dot(ray.direction, p.normal);\n\tfloat t = -(dot(ray.origin, p.normal) + d) / v;\n\tif(t > 0.0 && t < i.t){\n\t\ti.t = t;\n\t\ti.hit = 1.0;\n\t\ti.hitPoint = vec3(\n\t\t\tray.origin.x + t * ray.direction.x,\n\t\t\tray.origin.y + t * ray.direction.y,\n\t\t\tray.origin.z + t * ray.direction.z\n\t\t);\n\t\ti.normal = p.normal;\n\t}\n    return i;\n}\n\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n    \n    Ray ray = Ray(vec3(-1.5, 16.5 + sin(iTime) * 10.0, 12.0), rot3xy(vec2(-DEG_TO_RAD * 34.0, sin(iTime*2.0)/10.0)) * normalize(vec3(uv.x, uv.y, -1.0)));\n    \n    Plane tileTopPlane = Plane(\n    \tvec3(0.0, tileDepth, 0.0), \n    \tvec3(0.0, 1.0, 0.0)\n    );\n\n    \n    Intersection iTop = intersectPlane(ray, tileTopPlane);\n    \n    Plane dp = tileTopPlane;\n\n    fragColor = vec4(vec3(0.4, 0.0, 0.0), 1.0);\n    \n    for (int z=0; z < tileDepth; z++, dp.position.y -= 1.0) {\n        Intersection it = intersectPlane(ray, dp);\n        \n        if(it.hit > 0.0) {\n            ivec2 tileCoord = ivec2(\n                ceil(it.hitPoint.x / float(tileWidth)), \n                ceil(it.hitPoint.z / float(tileHeight))\n            );\n            \n            ivec2 voxelCoord = ivec2(\n                ceil(float(tileWidth) - (float(tileCoord.x * tileWidth) - it.hitPoint.x + 1.0)),\n                ceil(float(tileHeight) - (float(tileCoord.y * tileHeight) - it.hitPoint.z + 1.0))\n            );\n\n            //if (tileCoord.x >= -2 && tileCoord.y >= -4 && tileCoord.x <= 2 && tileCoord.y <= 1) {\n                if (voxelAt(ivec3(voxelCoord, z)) == 1) {\n\t             \tfragColor = vec4(vec3(float(z) / float(tileDepth)), 1.0);\n                    break;\n                }\n                //else\n                //\tfragColor += vec4(vec3(0.1), 1.0);\n            //}\n            \n        } \n    }\n\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wdBGWD",
      "date": "1548860481",
      "viewed": 4804,
      "name": "Mist by Ohno! - part2",
      "username": "lsdlive",
      "description": "This is my part for \"Mist\" by Ohno, a 4 kilobytes demo released at the Cookie 2018.\n\npouet: http://www.pouet.net/prod.php?which=79350\nyoutube: https://www.youtube.com/watch?v=UUtU3WVB144\n\nCode/Graphics: Flopine\nCode/Graphics: Lsdlive\nMusic: Triace",
      "likes": 99,
      "published": 3,
      "flags": 64,
      "tags": [
        "tunnel",
        "raymarch",
        "4k",
        "demoscene"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "MtfGD8",
            "filepath": "https://soundcloud.com/deejay-arvy/mist-4k-intro-by-ohno",
            "previewfilepath": "https://soundcloud.com/deejay-arvy/mist-4k-intro-by-ohno",
            "type": "musicstream",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 0
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n\n@lsdlive\nCC-BY-NC-SA\n\nThis is my part for \"Mist\" by Ohno, a 4 kilobytes demo released at the Cookie 2018.\n\npouet: http://www.pouet.net/prod.php?which=79350\nyoutube: https://www.youtube.com/watch?v=UUtU3WVB144\n\nCode/Graphics: Flopine\nCode/Graphics: Lsdlive\nMusic: Triace from Desire\n\nPart1 from Flopine here: https://www.shadertoy.com/view/tdBGWD\n\nInformation about my process for making this demo here:\nhttps://twitter.com/lsdlive/status/1090627411379716096\n\n*/\n\nfloat time = 0.;\n\nfloat random(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(12.2544, 35.1571))) * 5418.548416);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\t// Explained here why you still get an anti-clockwise rotation with this matrix:\n\t// https://www.shadertoy.com/view/wdB3DW\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 re(vec3 p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\nvoid amod2(inout vec2 p, float d) {\n\t// should be atan(p.y, p.x) but I had this function for a while\n\t// and putting parameters like this add a PI/6 rotation.\n\tfloat a = re(vec3(atan(p.x, p.y)), d).x; \n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp = abs(p) - d;\n\tif (p.y > p.x)p = p.yx;\n}\n\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\n\n\t//vec3 right = normalize(vec3(-fwd.z, 0, fwd.x));\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\n}\n\n// signed cube\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat cube(vec3 p, vec3 b) {\n\tb = abs(p) - b;\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\n}\n\n// iq's signed cross sc() - http://iquilezles.org/www/articles/menger/menger.htm\nfloat sc(vec3 p, float d) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - d;\n}\n\n\n////////////////////////// SHADER LSDLIVE //////////////////////////\n\nfloat prim(vec3 p) {\n\n\tp.xy *= r2d(3.14 * .5 + p.z * .1); // .1\n\n\tamod2(p.xy, 6.28 / 3.); // 3.\n\tp.x = abs(p.x) - 9.; // 9.\n\n\tp.xy *= r2d(p.z * .2); // .2\n\n\tamod2(p.xy, 6.28 /\n\t\tmix(\n\t\t\tmix(10., 5., smoothstep(59.5, 61.5, time)), // T4\n\t\t\t3.,\n\t\t\tsmoothstep(77.5, 77.75, time)) // T8\n\t); // 3.\n\tmo(p.xy, vec2(2.)); // 2.\n\n\tp.x = abs(p.x) - .6; // .6\n\treturn length(p.xy) - .2;//- smoothstep(80., 87., time)*(.5+.5*sin(time)); // .2\n}\n\nfloat g = 0.; // glow\nfloat de(vec3 p) {\n\n\tif (time > 109.2) {\n\t\tmo(p.xy, vec2(.2));\n\t\tp.x -= 10.;\n\t}\n\n\tif (time > 101.4) {\n\t\tp.xy *= r2d(time*.2);\n\t}\n\n\tif (time > 106.5) {\n\t\tmo(p.xy, vec2(5. + sin(time)*3.*cos(time*.5), 0.));\n\t}\n\n\tif (time > 104.) {\n\t\tamod2(p.xy, 6.28 / 3.);\n\t\tp.x += 5.;\n\t}\n\n\tif (time > 101.4) {\n\t\tmo(p.xy, vec2(2. + sin(time)*3.*cos(time*.5), 0.));\n\t}\n\n\tp.xy *= r2d(time * .05); // .05\n\n\tp.xy *= r2d(p.z *\n\t\tmix(.05, .002, step(89.5, time)) // P2 - T11\n\t); // .05 & .002\n\n\tp.x += sin(time) * smoothstep(77., 82., time);\n\n\tamod2(p.xy, 6.28 /\n\t\tmix(\n\t\t\tmix(1., 2., smoothstep(63.5, 68.5, time)), // T6\n\t\t\t5.,\n\t\t\tsmoothstep(72., 73.5, time)) // T7\n\t); // 5.\n\tp.x -= 21.; // 21.\n\n\tvec3 q = p;\n\n\tp.xy *= r2d(p.z * .1); // .1\n\n\tamod2(p.xy, 6.28 / 3.); // 3.\n\tp.x = abs(p.x) -\n\t\tmix(20., 5., smoothstep(49.5, 55., time)) // T2\n\t\t; // 5.\n\n\tp.xy *= r2d(p.z *\n\t\tmix(1., .2, smoothstep(77.5, 77.75, time)) // T8b\n\t); // .2\n\n\tp.z = re(p.zzz, 3.).x; // 3.\n\n\tp.x = abs(p.x);\n\tamod2(p.xy, 6.28 /\n\t\tmix(6., 3., smoothstep(77.75, 78.5, time)) // T10\n\t); // 3.\n\tfloat sc1 = sc(p,\n\t\tmix(8., 1., smoothstep(45.5, 51., time)) // T1\n\t); // 1.\n\n\tamod2(p.xz, 6.28 /\n\t\tmix(3., 8., smoothstep(61.5, 65.5, time)) // T5\n\t); // 8.\n\tmo(p.xz, vec2(.1)); // .1\n\n\tp.x = abs(p.x) - 1.;// 1.\n\n\tfloat d = cube(p, vec3(.2, 10, 1)); // fractal primitive: cube substracted by a signed cross\n\td = max(d, -sc1) -\n\t\tmix(.01, 2., smoothstep(56., 58.5, time)) // T3\n\t\t; // 2.\n\n\n\tg += .006 / (.01 + d * d); // first layer of glow\n\n\td = min(d, prim(q)); // add twisted cylinders\n\n\tg += .004 / (.013 + d * d); // second layer of glow (after the union of two geometries)\n\n\treturn d;\n}\n\n\n////////////////////////// RAYMARCHING FUNCTIONS //////////////////////////\n\n\nvec3 raymarch_lsdlive(vec3 ro, vec3 rd, vec2 uv) {\n\tvec3 p;\n\tfloat t = 0., ri;\n\n\tfloat dither = random(uv);\n\n\tfor (float i = 0.; i < 1.; i += .02) {// 50 iterations to keep it \"fast\"\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\td *= 1. + dither * .05; // avoid banding & add a nice \"artistic\" little noise to the rendering (leon gave us this trick)\n\t\td = max(abs(d), .002); // phantom mode trick from aiekick https://www.shadertoy.com/view/MtScWW\n\t\tt += d * .5;\n\t}\n\n\t// Shading: uv, iteration & glow:\n\tvec3 c = mix(vec3(.9, .8, .6), vec3(.1, .1, .2), length(uv) + ri);\n\tc.r += sin(p.z * .1) * .2;\n\tc += g * .035; // glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\n\n\treturn c;\n}\n\n// borrowed from (mmerchante) : https://www.shadertoy.com/view/MltcWs\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\n{\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\n\n\t// glitch pixellate\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\n\n\tint seedX = int(gl_FragCoord.x + time) / 32;\n\tint seedY = int(gl_FragCoord.y + time) / 32;\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\n\n\n\t// glitch splitter\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\n\t\t* random(vec2(seed))\n\t\t* step(start_time_stamp, time)\n\t\t* (1. - step(end_time_stamp, time));\n}\n\n////////////////////////// MAIN FUNCTION //////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n\n\t/* just code for the shadertoy port */\n\ttime = mod(iTime, 43. + 10.4);\n\ttime = time + 45.;\n\tif (time > 88. && time <= 98.6) // 98.\n\t\ttime += 10.6;\n\n\n\t// added glitch\n\tglitch(uv, 0., 2.);\n\n\tglitch(uv, 98., 99.);\n\t// lsdlive 2nd part\n\tglitch(uv, 100.5, 101.5);\n\tglitch(uv, 103., 104.);\n\tglitch(uv, 105.5, 106.5);\n\n\tvec3 lsd_ro = vec3(0, 0, -4. + time * 8.);\n\tvec3 lsd_target = vec3(0., 0., time * 8.);\n\tvec3 lsd_cam = get_cam(lsd_ro, lsd_target, uv);\n\n\tvec3 col = vec3(0.);\n\n\tif (time > 45. && time <= 88.) // 43 seconds\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\n\n\tif (time > 98.6 && time <= 109.) // 10.4 seconds\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\n\n\n\t// vignetting (iq)\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\n\n\t// fading out - end of the demo\n\t//col *= 1. - smoothstep(120., 125., time);\n\n\tfragColor = vec4(col, 1.);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Thanks guys !\n\n@FMS_Cat: The glitch effect is strongly inspired from this shader https://www.shadertoy.com/view/MltcWs we just simplified it a bit, and added time parametrization.\n\n@Dave_Hoskins: thanks ! didn't know about that.",
        "date": "1550055777",
        "username": "lsdlive",
        "userpicture": "/media/users/lsdlive/profile.png",
        "id": "MtXyDn",
        "hidden": 0
      },
      {
        "text": "quality glitchy posteffects!",
        "date": "1549291492",
        "username": "FMS_Cat",
        "userpicture": "/media/users/FMS_Cat/profile.png",
        "id": "Xtsyz8",
        "hidden": 0
      },
      {
        "text": "You can set 'time' to the media position at the top of 'mainImage' by [code]time = iChannelTime[0];[/code]  :)",
        "date": "1549271973",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Xllyz8",
        "hidden": 0
      },
      {
        "text": "Supercool",
        "date": "1549268301",
        "username": "Orquesm",
        "userpicture": "/img/profile.jpg",
        "id": "Xtlyz8",
        "hidden": 0
      },
      {
        "text": "marvelous",
        "date": "1549243407",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "4llcR8",
        "hidden": 0
      },
      {
        "text": "Soundtrack added!\nNormally the shader should be sync on the music at 45 seconds.",
        "date": "1549232249",
        "username": "lsdlive",
        "userpicture": "/media/users/lsdlive/profile.png",
        "id": "4tsyR8",
        "hidden": 0
      },
      {
        "text": "? No music ? Looks nice though.",
        "date": "1549189651",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "MtXyzH",
        "hidden": 0
      },
      {
        "text": "Thanks a lot guys !\n\nWe're going to see with Triace, the musician, to put the soundcloud on our shadertoys. Notice that it will be out of sync, because this shader is split into two scenes and cut with this other scene: https://www.shadertoy.com/view/tdBGWD (my part starts at 45 seconds & shows up again 98 seconds).\n\n@FabriceNeyret2 : yep totally on purpose, you should see a very dark blood stain.",
        "date": "1549010601",
        "username": "lsdlive",
        "userpicture": "/media/users/lsdlive/profile.png",
        "id": "ltsyzr",
        "hidden": 0
      },
      {
        "text": "Needs music COOL",
        "date": "1548907050",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "XtscRn",
        "hidden": 0
      },
      {
        "text": "WOW!!!!!!!!!",
        "date": "1548897663",
        "username": "DBBH",
        "userpicture": "/img/profile.jpg",
        "id": "4tlcRn",
        "hidden": 0
      },
      {
        "text": "That's pretty!",
        "date": "1548895112",
        "username": "cbrpnk",
        "userpicture": "/media/users/cbrpnk/profile.jpeg",
        "id": "XlsyRn",
        "hidden": 0
      },
      {
        "text": "Nice nice nice!!! Put sound(cloud) to it!",
        "date": "1548893202",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XllyRn",
        "hidden": 0
      },
      {
        "text": "cool",
        "date": "1548871681",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "llXyzr",
        "hidden": 0
      },
      {
        "text": "cool !\nNB: almost totally dark up to t=5s . is it expected ?",
        "date": "1548866006",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MtfcRr",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wl2GRG",
      "date": "1560347608",
      "viewed": 240,
      "name": " Double Sided Quad Truchet",
      "username": "Shane",
      "description": "Recreating BigWIngs's double arc quad Truchet weave pattern, with some minor changes thrown in.",
      "likes": 17,
      "published": 3,
      "flags": 0,
      "tags": [
        "bezier",
        "square",
        "truchet",
        "pattern",
        "quad",
        "weave"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\n\n\t Double Sided Quad Truchet\n\t--------------------------\n\n\tBigWIngs posted a really interesting weave pattern the other day that I wanted to\n    recreate for my own amusement. I like it because the premise is incredibly simple, \n\tbut\tit leads to visually entertaining results -- In fact, I'm amazed at just how\n    much variation it provides. The link to his orginal example is below.\n\n\tThe idea is very simple: Instead of rendering two sets of arcs connecting the\n    midpoints of the grid cell boundaries (like with a standard Truchet arc pattern), \n\tdouble the connecting points on each edge, then connect four arc-like segments\n    between them -- Bezier curves are a good option, but not mandatory. The four \n\tcurve segments each connect random pairs of entry and exit points, which result \n\tin the crazy spaghetti pattern you see. :)\n\n\tBigWIngs rendered some presets and left the overall random pattern rendering as \n\tan exercise to the reader, so I gave it a go. I had to think about it for a while, \n\tbut then realized all that was required was to shuffle an array of 8 points, \n\tthen render the shuffled pairs. It seems to work, but I'm open to suggestion, if \n\tthere's a better way.\n\n    I also went out of my way to append smooth Bezier curves, which look fine, but my \n\tmethodology was a bit hacky, so I'm hoping BigWIngs, or someone else, will come up \n\twith something more robust.\n\n\tI didn't spend a great deal of time prettying this up, so I'm not sure what style\n\tthis is rendered in. Art deco grunge? :) I might bump map it later to make it pop\n\tout a bit more, or make a 3D version. By the way, if you wanted to produce a 3D \n\textruded version, you'd probably have to replace the Bezier curves with a mixture \n\tof arcs and lines, which would be much faster.\n\n\n\tBased On:\n\n\tCube-mapped Double Quad Truchet - BigWIngs\n\thttps://www.shadertoy.com/view/wlSGDD\n\n\n*/\n\n// The textured version. Without it, the look is cleaner, which makes the pattern\n// a little easier to discern. Sometimes, I prefer it.\n#define USE_TEXTURE\n\n// This will change the spacing of the boundary connecting points to loosen the weave \n// a little. I like it more, but I left the standard look as the default.\n//#define LOOSE_WEAVE\n\n// Grid outlines, which allows the viewer to see the individual tiles... and spoils\n// the illusion. :)\n//#define SHOW_GRID\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Standard vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.917, 57.543)))*43758.5453); }\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n// The grungey texture -- Kind of modelled off of the metallic Shadertoy texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(vec2 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n2D(p*3.)*.57 + n2D(p*7.)*.28 + n2D(p*15.)*.15;\n    \n    \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.35, .5, .65), vec3(.25, .1, .02), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n2D(p*vec2(150., 350.))*.5 + .5; \n    \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.2), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n2D(p*8. + .5)*.7 + n2D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worse coding ever. :D\n    float l = length(b.xy - a.xy)*(1.4142 - 1.)/1.4142;\n    // Segments between edge points need to be refactored. Comment this out to\n    // see why it's necessary.\n    if(abs(length(b.xy - a.xy) - r*2.)<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to from the smooth Bezier arc from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :D\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\nvec4 DoubleQuadTruchet(vec2 p){\n    \n    vec2 ip = floor(p); // Cell ID.\n    p -= ip + .5; // Cell's local position. Range [vec2(-.5), vec2(.5)].\n    \n    \n    \n    // Positioning the connecting points around the square grid cell. \"r\" is an offset\n    // from the mid point, which controls the tightness of the pattern. The value\n    // \".25\" gives the most even spread, whereas something like \".175\" will give\n    // a tighter looking loop pattern.\n    //\n    // The first two entries of the vec4 represent the positions, and the remaining\n    // two are their edge normals, which, by the way, would be easy enough to \n    // calculate, but I thought hardcoding them in would be easier.\n    //\n    // Only range values between .18 and .32 will work with this configuration. Larger ranges\n    // would work, but you'd have to render surrounding cells also to account for neighboring\n    // cell infringement.\n    float r = .25; \n    #ifdef LOOSE_WEAVE\n    r = .2;\n    #endif\n    vec4[8] pnt = vec4[8](vec4(-r, .5, 0, -1), vec4(r, .5, 0, -1), vec4(.5, r, -1, 0), vec4(.5, -r, -1, 0),\n                         vec4(r, -.5, 0, 1), vec4(-r, -.5, 0, 1), vec4(-.5, -r, 1, 0), vec4(-.5, r, 1, 0));\n    \n     \n    // Shuffling the 8 array points and normals. Afterward, the four array pairs should\n    // be rendered randomly. This also means the rendering order should be randomized,\n    // which is an added bonus. I think this is the Fisher\u2013Yates method, but it's been \n    // a while since I've used a shuffling algorithm, so if there are inconsistancies, \n    // etc, feel free to let me know.\n    //\n    // There'd be some combinations, like four corner arcs, etc, that would be rendered \n    // more often, since lack of overlap would mean that different rendering orders would\n    // result in the same tile combination. However, as a general rule, this method works\n    // well enough. I mean, you could start including weighted distribution for certain \n    // arrangements... but who wants the extra headache? :)\n    //\n    for(int i = 7; i>0; i--){\n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        float rs = hash21(ip + fi/8.); // Random number.\n        //int j = int(floor(mod(rs*8e5, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n         \n    }\n    \n    // Render all four connecting arc segments.\n    vec4 d;\n    \n    d.x = doSeg(p, pnt[0], pnt[1], r);\n    d.y = doSeg(p, pnt[2], pnt[3], r);\n    d.z = doSeg(p, pnt[4], pnt[5], r);\n    d.w = doSeg(p, pnt[6], pnt[7], r);\n    \n    return d; // The Truchet tile distance field value.\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(iResolution.y, 800.);\n    \n    // Scaling and translation.\n    const float gSc = 8.;\n    \n    // Smoothing factor.\n    float sf = 2./iResolution.y*gSc;\n    \n    // Scaling and translation.\n    vec2 p = uv*gSc + vec2(1, 0)*iTime;\n \n    // Grid fields: Square and diamond.\n    vec2 grid;\n    vec2 p2 = abs(fract(p) - .5);\n    grid.x = abs(max(abs(p2.x), abs(p2.y)) - .5); // Square grid.\n    grid.y = abs((abs(p2.x) +  abs(p2.y)) - .5*.7071); // Diamond background.\n    \n    \n    // The pattern itself.\n    vec4 d = DoubleQuadTruchet(p);\n    d -= .155; // Give the pattern some width.\n \n    // Background, line and edge colors. \n    vec3 col = vec3(1, .8, .6);\n    vec3 lCol = vec3(1, .95, .9);\n    vec3 eCol = vec3(1, .8, .6);\n    \n    // Subtle coloring, based on pixel height. I was going for an oxidized copper\n    // tone, so that kind of does it. :)\n    lCol = mix(lCol, lCol.yxz, -uv.y*.35 + .35);\n    eCol = mix(eCol, eCol.yxz, -uv.y*.2 + .2); \n    col = mix(col, col.yxz, -uv.y*.35 + .35);    \n    \n\t// Concentric diamond background pattern.\n    float pat = clamp(cos(grid.y*6.2831*8.), 0., 1.);\n    col *= 1. -  pat*.9;\n    \n    #ifdef USE_TEXTURE\n        \n        // Applying the pattern to the line element. Comment it out to give a\n        // a cleaner pattern look.\n        lCol *= vec3(.3, .45, .55) +  pat;\n        \n        // Home made texture algorithm... Sufficient for this example,\n        // but not my best work. :)\n        vec3 tx = GrungeTex(p/gSc);\n        vec3 tx2 = GrungeTex(p/gSc + 6.5);\n\n        // Apply the texture.\n        col *= min(tx2*4., 1.);\n        lCol *= min(tx*1.5, 1.);\n        eCol *= min(tx2*6., 1.);\n\n        float sAlpha = .75; // Darker texture shadowing.\n    #else\n \n        float sAlpha = .5; // Lighter shadowing when not using a texture.\n    #endif\n    \n\n    // Render the four arcs. Layers include shadowing, strokes, inner strokes,\n    // coloring, etc.\n    for(int i = 0; i<4; i++){\n       \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., d[i] - .01))*sAlpha);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d[i]))*.9);\n        col = mix(col, eCol, 1. - smoothstep(0., sf, d[i] + .03));\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d[i] + .09))*.9);\n        col = mix(col, lCol, 1. - smoothstep(0., sf, d[i] + .12));\n    }\n    \n    \n    // Displaying the grid.\n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., grid.x - .025))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid.x - .025))*.9);\n    col = mix(col, vec3(1, .9, .8)*1.2, (1. - smoothstep(0., sf, grid.x - .005))*.9);\n    #endif\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.xzy, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625));\n  \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}\n\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "@reinder\nThat site is awesome. There are so many visually striking examples on there that's it's hard to pick a favorite. When I get time, I'd like to take a proper look. As for this example, it's interesting in the sense that it shows it's possible to produce a lot of variation on something as simple as a square grid, and the execution is simple enough that someone like yourself could code it in your sleep, if you got really bored and felt like porting a variation. By the way, feel free to use anything I put up. Most of it is just a rehash of early 90s demo code anyway. :)\n\n@fizzer\nI quickly put together a rough means by which the random overlapping segment combinations could be created. The quick shuffling formula I hacked in favors non-overlapping combinations, but still gives the sense of evenly distributed random tiles. Anyway, I figured something along those lines would be applicable when creating the weaved version of your \"4.8^2 Truchet\" example. Your semi-regular version with BigWings's double segment notion would produce a pretty intense pattern, but what I'd really like to see is a Wang tile hybrid. A pattern like that would have gaps, which would break things up and make it more interesting.",
        "date": "1560740674",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "ltSyW3",
        "hidden": 0
      },
      {
        "text": "(Maybe you can create something similar on [url=https://turtletoy.net/turtle/browse/love/]Turtletoy[/url]? ;) )",
        "date": "1560683021",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "4lBcD3",
        "hidden": 0
      },
      {
        "text": "Beautiful! I like this kind of 'pattern-shaders'.",
        "date": "1560682824",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "XlBcD3",
        "hidden": 0
      },
      {
        "text": "wow! a world full of highway junctions...",
        "date": "1560618634",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "4lByW3",
        "hidden": 0
      },
      {
        "text": "Awesome!",
        "date": "1560425742",
        "username": "fizzer",
        "userpicture": "/media/users/fizzer/profile.jpeg",
        "id": "Xt2yDV",
        "hidden": 0
      },
      {
        "text": "I guess the naming would consist of:\n1) the type of tiling (triangle, square, hexagon)\n2) the number of connections per edge (single, double, triple?)\n\nI published the triangle doodle. Its super rough code but it shows the idea.\n\nAnd I like the shuffle code. I'm sure I'll use that in the future!",
        "date": "1560397640",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "XljyDV",
        "hidden": 0
      },
      {
        "text": "@BigWIngs\nIf there's a standardized nomenclature for Truchet patterns out there, I haven't come across it, so I guess it wouldn't hurt to try. I have a math background, so I'd be willing to bet there'd be some kind of totally unhelpful esoteric abstract description already in place. :) From my perspective, the pattern is differentiated from the usual grid patterns due to the double pairings of connecting points per side, so double sided Truchet pattern would be enough for me. Either way, I couldn't find any instances where someone's tried it on a standard square grid (I've seen it in other situations), and Google already views it as your premise, so I'm calling it a BigWIngs Spaghetti Pattern. :D\n\nAs for extensions on the concept, I have so many -- two of which would be pretty interesting. However, I'd have to take a deep breath before I begin coding them. I wanted to code the triangular equivalent, just to see how it compared to the single-sided hexagonal weave, so I, for one, would be interested to see what you've come up with.\n\nBy the way, I put some shuffling logic in there that might save you writing out arrays of presets, which means it would be convenient in that sense, but I'm not sure if it'd be fast enough for 3D versions without some tweaking.",
        "date": "1560390865",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "4ljcWV",
        "hidden": 0
      },
      {
        "text": "Nice!",
        "date": "1560366254",
        "username": "Duke",
        "userpicture": "/img/profile.jpg",
        "id": "Xl2yWV",
        "hidden": 0
      },
      {
        "text": "Thats a beatiful rendition! I love what you did with the background too.\n\nWhile we are coming up with new truchet patterns perhaps we should keep the naming consistent? I'm not sure what you would call the simplest truchet with two arcs on a square grid but I called it 'quad truchet' because it is a tiling of quads. This new truchet pattern uses the same quads, but has double connections per edge, hence 'double quad truchet'. Or I guess we could call it double square truchet?  Anyways, I'm open to suggestions, I just think it would be good to come up with something consistent.\n\nI also have a double triangle truchet doodle lying around that I guess I should make public.",
        "date": "1560354729",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "Xl2cDK",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wl2Gzc",
      "date": "1560623291",
      "viewed": 163,
      "name": "Sparks from fire",
      "username": "jaszunio15",
      "description": "I challenged myself to save 169 \u20ac by recreating this:\nhttps://www.shutterstock.com/pl/video/clip-1009164515-burning-red-hot-sparks-rise-large-fire\n\nEnjoy :)",
      "likes": 23,
      "published": 1,
      "flags": 0,
      "tags": [
        "voronoi",
        "burn",
        "fire",
        "particles",
        "sparks"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define PI 3.1415927\n#define TWO_PI 6.283185\n\n#define ANIMATION_SPEED 1.5\n#define MOVEMENT_SPEED 1.0\n#define MOVEMENT_DIRECTION vec2(0.7, -1.0)\n\n#define PARTICLE_SIZE 0.009\n\n#define PARTICLE_SCALE (vec2(0.5, 1.6))\n#define PARTICLE_SCALE_VAR (vec2(0.25, 0.2))\n\n#define PARTICLE_BLOOM_SCALE (vec2(0.5, 0.8))\n#define PARTICLE_BLOOM_SCALE_VAR (vec2(0.3, 0.1))\n\n#define SPARK_COLOR vec3(1.0, 0.4, 0.05) * 1.5\n#define BLOOM_COLOR vec3(1.0, 0.4, 0.05) * 0.8\n#define SMOKE_COLOR vec3(1.0, 0.43, 0.1) * 0.8\n\nfloat hash1_2(in vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);   \n}\n\nvec2 hash2_2(in vec2 x)\n{\n    return fract(sin(x * mat2x2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\n}\n\n//Simple interpolated noise\nvec2 noise2_2(vec2 uv)\n{\n    //vec2 f = fract(uv);\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    vec2 v00 = hash2_2(uv00);\n    vec2 v01 = hash2_2(uv01);\n    vec2 v10 = hash2_2(uv10);\n    vec2 v11 = hash2_2(uv11);\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n//Simple interpolated noise\nfloat noise1_2(in vec2 uv)\n{\n    vec2 f = fract(uv);\n    //vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    \n    float v00 = hash1_2(uv00);\n    float v01 = hash1_2(uv01);\n    float v10 = hash1_2(uv10);\n    float v11 = hash1_2(uv11);\n    \n    float v0 = mix(v00, v01, f.y);\n    float v1 = mix(v10, v11, f.y);\n    float v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\nfloat layeredNoise1_2(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float animation)\n{\n \tfloat noise = 0.0;\n    float alpha = 1.0;\n    float size = 1.0;\n    vec2 offset;\n    for (int i = 0; i < layers; i++)\n    {\n        offset += hash2_2(vec2(alpha, size)) * 10.0;\n        \n        //Adding noise with movement\n     \tnoise += noise1_2(uv * size + iTime * animation * 8.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED + offset) * alpha;\n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    noise *= (1.0 - alphaMod)/(1.0 - pow(alphaMod, float(layers)));\n    return noise;\n}\n\n//Rotates point around 0,0\nvec2 rotate(in vec2 point, in float deg)\n{\n \tfloat s = sin(deg);\n    float c = cos(deg);\n    return mat2x2(s, c, -c, s) * point;\n}\n\n//Cell center from point on the grid\nvec2 voronoiPointFromRoot(in vec2 root, in float deg)\n{\n  \tvec2 point = hash2_2(root) - 0.5;\n    float s = sin(deg);\n    float c = cos(deg);\n    point = mat2x2(s, c, -c, s) * point * 0.66;\n    point += root + 0.5;\n    return point;\n}\n\n//Voronoi cell point rotation degrees\nfloat degFromRootUV(in vec2 uv)\n{\n \treturn iTime * ANIMATION_SPEED * (hash1_2(uv) - 0.5) * 2.0;   \n}\n\nvec2 randomAround2_2(in vec2 point, in vec2 range, in vec2 uv)\n{\n \treturn point + (hash2_2(uv) - 0.5) * range;\n}\n\n\nvec3 fireParticles(in vec2 uv, in vec2 originalUV)\n{\n    vec3 particles = vec3(0.0);\n    vec2 rootUV = floor(uv);\n    float deg = degFromRootUV(rootUV);\n    vec2 pointUV = voronoiPointFromRoot(rootUV, deg);\n    float dist = 2.0;\n    float distBloom = 0.0;\n   \n   \t//UV manipulation for the faster particle movement\n    vec2 tempUV = uv + (noise2_2(uv * 2.0) - 0.5) * 0.1;\n    tempUV += -(noise2_2(uv * 3.0 + iTime) - 0.5) * 0.07;\n\n    //Sparks sdf\n    dist = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_SCALE, PARTICLE_SCALE_VAR, rootUV));\n    \n    //Bloom sdf\n    distBloom = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_BLOOM_SCALE, PARTICLE_BLOOM_SCALE_VAR, rootUV));\n\n    //Add sparks\n    particles += (1.0 - smoothstep(PARTICLE_SIZE * 0.6, PARTICLE_SIZE * 3.0, dist)) * SPARK_COLOR;\n    \n    //Add bloom\n    particles += pow((1.0 - smoothstep(0.0, PARTICLE_SIZE * 6.0, distBloom)) * 1.0, 3.0) * BLOOM_COLOR;\n\n    //Upper disappear curve randomization\n    float border = (hash1_2(rootUV) - 0.5) * 2.0;\n \tfloat disappear = 1.0 - smoothstep(border, border + 0.5, originalUV.y);\n\t\n    //Lower appear curve randomization\n    border = (hash1_2(rootUV + 0.214) - 1.8) * 0.7;\n    float appear = smoothstep(border, border + 0.4, originalUV.y);\n    \n    return particles * disappear * appear;\n}\n\n\n//Layering particles to imitate 3D view\nvec3 layeredParticles(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float smoke) \n{ \n    vec3 particles = vec3(0);\n    float size = 1.0;\n    float alpha = 1.0;\n    vec2 offset = vec2(0.0);\n    vec2 noiseOffset;\n    vec2 bokehUV;\n    \n    for (int i = 0; i < layers; i++)\n    {\n        //Particle noise movement\n        noiseOffset = (noise2_2(uv * size * 2.0 + 0.5) - 0.5) * 0.15;\n        \n        //UV with applied movement\n        bokehUV = (uv * size + iTime * MOVEMENT_DIRECTION * MOVEMENT_SPEED) + offset + noiseOffset; \n        \n        //Adding particles\t\t\t\t\t\t\t\tif there is more smoke, remove smaller particles\n\t\tparticles += fireParticles(bokehUV, uv) * alpha * (1.0 - smoothstep(0.0, 1.0, smoke) * (float(i) / float(layers)));\n        \n        //Moving uv origin to avoid generating the same particles\n        offset += hash2_2(vec2(alpha, alpha)) * 10.0;\n        \n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    return particles;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    float vignette = 1.0 - smoothstep(0.4, 1.4, length(uv + vec2(0.0, 0.3)));\n    \n    uv *= 1.8;\n    \n    float smokeIntensity = layeredNoise1_2(uv * 10.0 + iTime * 4.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.7, 0.7, 6, 0.2);\n    smokeIntensity *= pow(1.0 - smoothstep(-1.0, 1.6, uv.y), 2.0); \n    vec3 smoke = smokeIntensity * SMOKE_COLOR * 0.8 * vignette;\n    \n    //Cutting holes in smoke\n    smoke *= pow(layeredNoise1_2(uv * 4.0 + iTime * 0.5 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.8, 0.5, 3, 0.2), 2.0) * 1.5;\n    \n    vec3 particles = layeredParticles(uv, 1.05, 0.9, 15, smokeIntensity);\n    \n    vec3 col = particles + smoke + SMOKE_COLOR * 0.02;\n\tcol *= vignette;\n    \n    col = smoothstep(-0.08, 1.0, col);\n\n    fragColor = vec4(col, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Thanks! I'm glad you like it! :love:",
        "date": "1560704465",
        "username": "jaszunio15",
        "userpicture": "/img/profile.jpg",
        "id": "4tBcWc",
        "hidden": 0
      },
      {
        "text": "I like it",
        "date": "1560683918",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XtSyWc",
        "hidden": 0
      },
      {
        "text": "Beautiful! Very nice.",
        "date": "1560682629",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "4tBcD3",
        "hidden": 0
      },
      {
        "text": "woow, nice job ",
        "date": "1560668605",
        "username": "jeyko",
        "userpicture": "/media/users/jeyko/profile.jpeg",
        "id": "4lByD3",
        "hidden": 0
      },
      {
        "text": "nice !",
        "date": "1560667465",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "XlByD3",
        "hidden": 0
      },
      {
        "text": "Nicely done.",
        "date": "1560648553",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "XlSyD3",
        "hidden": 0
      },
      {
        "text": "Very cool, it's just like the shutterstock example. This can't be all you get for \u00a390 is it? \ud83d\ude44",
        "date": "1560629779",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XtBcW3",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wlB3Wy",
      "date": "1560943728",
      "viewed": 34,
      "name": "study3_3dSample_clock",
      "username": "firegump",
      "description": "just leaning  Clock~~~~",
      "likes": 1,
      "published": 1,
      "flags": 0,
      "tags": [
        "studycubedraw"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define sat(x) clamp(x,0.,1.)\nfloat DistLine(vec3 ro, vec3 rd, vec3 p){\n\treturn length(cross((p - ro),rd))/length(rd);\n}\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p){\n\tfloat d = DistLine(ro,rd,p);\n    d = smoothstep(.012,.01, d);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float t = iTime*.5;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(2.+sin(t)*.5,sin(-t)*.5,cos(t)*.9);//camera point\n    \n    \n\n    float zoom = 1.;\n    const float a = 1.;\n\tfloat b = 0.;\n    float A = sin(t*7.);\n    float B = cos(t*7.);\n    float C = sin(t*1.)*.7;\n    float D = cos(t*1.)*.7;\n    \n    vec3 lookat = vec3(a*.5);//rect center point\n        \n    vec3 f = normalize(lookat - ro);\n    vec3 r = cross(vec3(0.,1.,0.),f);\n    vec3 u = cross(r,f);\n    \n    vec3 c = ro + f*zoom;\n    \n    vec3 i =  c + uv.x*r + uv.y*u; //c = ro + f*2.0\n    vec3 rd = i -  ro;//ray direction\n    \n   \n    \n    float d = 0.;\n    \n   \n\n    for(float i = 0.;i < a*10.+.01;i += 0.1){\n    \t\n        d += DrawPoint(ro, rd, vec3(a,a,i));\n        d += DrawPoint(ro, rd, vec3(a,a,i*.1));\n        d += DrawPoint(ro, rd, vec3(b,b,i*.1));\n        d += DrawPoint(ro, rd, vec3(a,b,i*.1));\n        d += DrawPoint(ro, rd, vec3(b,a,i*.1));\n        d += DrawPoint(ro, rd, vec3(i*.1,a,a));\n        d += DrawPoint(ro, rd, vec3(i*.1,b,b));\n        d += DrawPoint(ro, rd, vec3(i*.1,b,a));\n        d += DrawPoint(ro, rd, vec3(i*.1,a,b));\n        d += DrawPoint(ro, rd, vec3(a,i*.1,a))*.1;\n        d += DrawPoint(ro, rd, vec3(a,i*.1,b))*.1;\n        d += DrawPoint(ro, rd, vec3(b,i*.1,a))*.1;\n        d += DrawPoint(ro, rd, vec3(b,i*.1,b))*.1;\n        //d += DrawPoint(ro, rd, vec3(i*abs(sin(t*42.))*.014,a*.5,a*.5));\n        d += DrawPoint(ro, rd, vec3(b+a ,i*B*.05+a*.5, A*i*.05 +a*.5));//quick pointer\n        d += DrawPoint(ro, rd, vec3(b+a,i*D*.05+a*.5, C*i*.05 +a*.5));//slow pointer\n        \n        d += (DrawPoint(ro, rd, vec3(b+a ,i*cos(i*7.)*.05+a*.5, sin(i*7.)*i*.05 +a*.5)))*(sin(i*.5)*.5+0.6);\n        \n        \n    }\n    vec4 col = vec4 ((0.5 + 0.5*cos(t + uv.xyx + vec3(0,2,4))),1.);\n    col *= d;\n    \n    // Output to screen\n    fragColor = col;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wlBGRd",
      "date": "1560764254",
      "viewed": 98,
      "name": "Kpl for VS - pic003",
      "username": "kipol",
      "description": "shader from cppn",
      "likes": 3,
      "published": 3,
      "flags": 0,
      "tags": [
        "abstractpainting"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "\n#define N_HIDDEN 16\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.035022326, -0.02029945, 0.018505778, 0.012906424) + mat4(vec4(0.05392581969499588, -0.06193741038441658, -1.1496435403823853, -0.13049328327178955), vec4(0.4170045852661133, 0.24073562026023865, 0.570548951625824, 0.8341407179832458), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[1] = vec4(-0.020696174, 0.01385696, 0.026241628, -0.0067616403) + mat4(vec4(0.5619710087776184, 1.042479395866394, -0.8263165354728699, -0.7207739949226379), vec4(-0.8230406641960144, -1.207921028137207, 0.6806169152259827, -0.41663238406181335), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[2] = vec4(-0.0053295377, 0.02197065, 0.0048876614, 0.0005899789) + mat4(vec4(0.05554826557636261, 0.34079623222351074, 0.3709535598754883, 0.5395087599754333), vec4(0.36088061332702637, -0.6958171129226685, 0.18204621970653534, -0.6743152141571045), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[3] = vec4(-0.008644993, 0.007726745, 0.02242221, -0.014627838) + mat4(vec4(0.5104420781135559, -0.3727065324783325, -1.0545977354049683, -0.10491696745157242), vec4(1.2406706809997559, 0.561448872089386, -0.9851856827735901, -0.16126567125320435), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(-0.007247362, 0.012622283, -0.019720739, 0.011773883) + mat4(vec4(0.06966425, -0.0012040122, -0.025521372, -0.12516569), vec4(-0.3381293, 0.012631387, -0.27746472, -0.06554171), vec4(-0.032917544, 0.06844392, 0.123151936, -0.102095895), vec4(-0.052147247, 0.028811751, -0.06843417, -0.29784077)) * bufB[0] + mat4(vec4(-0.09015242, 0.0615919, -0.022696791, -0.30480966), vec4(0.15610561, -0.005024175, -0.011832519, 0.184015), vec4(-0.08307784, -0.046518333, 0.10022456, 0.23117636), vec4(0.13829437, 0.08318428, -0.26868567, 0.13323952)) * bufB[1] + mat4(vec4(0.039565522, -0.032624077, 0.058952555, -0.15231487), vec4(-0.41566014, 0.13312668, 0.019703224, 0.07282753), vec4(0.031147778, 0.006148456, 0.30463007, -0.25047156), vec4(0.008613561, 0.05921119, -0.13342209, 0.26413482)) * bufB[2] + mat4(vec4(0.071540736, -0.14249952, 0.14174163, 0.062436257), vec4(-0.03321534, 0.10969266, -0.07840334, -0.541212), vec4(0.22945553, 0.062921025, -0.22334665, 0.17814787), vec4(0.32972935, 0.15878965, -0.16461177, 0.039970662)) * bufB[3] + mat4(vec4(-0.07641739, -0.30857807, 0.1258147, 0.39333934), vec4(-0.10262366, -0.098083064, -0.2912149, -0.20098038), vec4(-0.034448113, -0.16473004, -0.057463717, 0.23785518), vec4(-0.029662883, -0.28255934, -0.18816389, -0.24314518)) * bufB[4] + mat4(vec4(0.022512669, -0.2569233, -0.055807665, -0.16851768), vec4(-0.3210917, 0.06421914, 0.21113896, 0.14224073), vec4(-0.2649646, -0.068255745, -0.10079774, 0.19466509), vec4(0.123564, 0.14742169, 0.26554993, 0.0864629)) * bufB[5] + mat4(vec4(0.36861688, 0.0068259016, -0.18843073, 0.21423793), vec4(-0.40665212, -0.09753877, -0.05981735, 0.02636262), vec4(-0.19727838, 0.13647856, -0.13922752, 0.02912041), vec4(-0.014155782, 0.2698377, -0.115161195, 0.019997288)) * bufB[6] + mat4(vec4(0.081352726, -0.34743264, -0.1589021, -0.051750056), vec4(0.06587133, -0.0007466777, 0.016626704, 0.13913468), vec4(-0.11469093, -0.13122052, 0.07207088, -0.1031781), vec4(-0.09235611, 0.00017997451, 0.0071550887, 0.049754985)) * bufB[7];\nbufA[1] = vec4(0.030201923, -0.00967173, -0.02110268, 0.00695758) + mat4(vec4(0.1306984, -0.087288216, -0.21257515, 0.19114013), vec4(-0.18554823, 0.043527886, 0.0035406316, 0.103892386), vec4(-0.19419272, -0.089526914, 0.03345922, -0.025755886), vec4(-0.091265514, 0.17757908, 0.14633292, 0.56659347)) * bufB[0] + mat4(vec4(-0.04692455, -0.21622795, 0.086245455, -0.14893286), vec4(-0.2735357, 0.16177818, 0.09531667, 0.2694951), vec4(0.3339596, 0.1645638, 0.47427154, 0.094424725), vec4(0.078508325, 0.13651454, 0.033451382, 0.24305485)) * bufB[1] + mat4(vec4(-0.08266229, -0.23123638, 0.01318958, -0.0035924441), vec4(0.17620404, 0.13716248, 0.0035669922, 0.013860318), vec4(0.13144043, 0.18490058, -0.09724929, -0.09845527), vec4(-0.029824179, -0.11189098, -0.022227257, -0.07742282)) * bufB[2] + mat4(vec4(-0.097029, 0.34879005, 0.020646881, 0.2342826), vec4(-0.052276302, 0.103065416, -0.19271195, -0.025967536), vec4(0.2568858, -0.11760176, -0.32796335, 0.104997136), vec4(-0.106608264, -0.007309273, 0.3773588, 0.1096893)) * bufB[3] + mat4(vec4(-0.18554223, 0.2664043, 0.025777522, -0.116956025), vec4(0.10047355, 0.31516948, -0.084578015, 0.13131186), vec4(-0.025204541, -0.20210506, 0.060159944, 0.18834905), vec4(-0.07815044, -0.030376196, 0.10742265, -0.138959)) * bufB[4] + mat4(vec4(0.039150152, 0.22397216, 0.23127276, -0.2056446), vec4(0.08383801, 0.003165334, 0.14063483, 0.076965995), vec4(-0.098417476, -0.28967816, -0.027819756, -0.1290214), vec4(-0.03151819, 0.035782382, -0.19253162, -0.13054769)) * bufB[5] + mat4(vec4(-0.05035413, 0.08366375, 0.27027875, 0.0050622406), vec4(-0.10975114, 0.0040614624, 0.052506305, 0.267535), vec4(-0.3333833, -0.25832576, -0.015299467, 0.13634793), vec4(0.015757343, 0.011852452, -0.039323617, 0.21063177)) * bufB[6] + mat4(vec4(-0.105627194, 0.269618, 0.06604509, -0.17198728), vec4(0.20484151, -0.21050945, 0.12776496, -0.016729664), vec4(-0.08196898, -0.06145329, 0.3002203, 0.009630574), vec4(0.038303856, -0.03653167, -0.14484493, -0.31948572)) * bufB[7];\nbufA[2] = vec4(0.0012412892, 0.0038912944, 0.01211715, 0.0021933469) + mat4(vec4(-0.06478712, -0.08730999, 0.018730357, 0.14271909), vec4(-0.25912866, 0.106726095, -0.098368116, -0.4003152), vec4(0.2574547, 0.10141634, 0.15556473, 0.057950217), vec4(-0.19662978, 0.049875807, -0.30501664, -0.0849829)) * bufB[0] + mat4(vec4(-0.33176088, 0.10264731, -0.014363458, -0.25147563), vec4(-0.0153300725, -0.08400886, -0.10443716, 0.009120944), vec4(-0.15537126, 0.08256444, -0.06651629, 0.07316714), vec4(0.08081599, -0.0527877, -0.2986712, -0.10165975)) * bufB[1] + mat4(vec4(0.28628597, -0.23890357, -0.064063, -0.12685429), vec4(0.1216516, 0.2068959, -0.0046442514, -0.110076435), vec4(-0.107520245, -0.12678076, 0.19399796, -0.04452621), vec4(-0.09013378, -0.07808741, -0.03518435, -0.30675507)) * bufB[2] + mat4(vec4(0.47310042, 0.013269688, -0.21303484, 0.050646856), vec4(0.26143897, -0.020139663, 0.43201852, 0.17253342), vec4(0.1373907, -0.036909115, -0.17717516, 0.17021097), vec4(0.07803966, 0.3139184, 0.05683599, 0.15823396)) * bufB[3] + mat4(vec4(-0.08979131, 0.075833015, -0.25630993, -0.11390319), vec4(-0.07851753, -0.0505656, 0.102362074, -0.089536905), vec4(-0.05478443, 0.29987594, 0.016403845, 0.16241996), vec4(0.2428636, -0.14616865, -0.15479313, 0.20549506)) * bufB[4] + mat4(vec4(0.26591095, 0.03450501, -0.20094049, -0.25209376), vec4(0.089944884, 0.23409544, -0.33547595, -0.032648597), vec4(0.23819755, 0.011613911, -0.121998586, -0.10612968), vec4(-0.030816235, -0.041716527, 0.20255755, 0.25542203)) * bufB[5] + mat4(vec4(-0.31253055, -0.037475746, -0.027678123, -0.1831562), vec4(0.20685345, -0.06070872, -0.12961797, 0.13345565), vec4(0.22287527, 0.30632752, -0.06675815, -0.08680724), vec4(-0.07875384, -0.16636115, -0.21806274, -0.3767924)) * bufB[6] + mat4(vec4(-0.16000372, 0.013599232, -0.36736408, -0.19194205), vec4(-0.08817099, -0.047419704, 0.060244914, 0.26931828), vec4(-0.040732443, -0.1645503, -0.05190961, -0.17373468), vec4(-0.07734054, 0.27316326, 0.2040507, -0.1723326)) * bufB[7];\nbufA[3] = vec4(-0.0030992469, -0.011184195, 7.71535e-05, 0.0025829247) + mat4(vec4(0.006938933, -0.4829302, 0.22013108, 0.17538616), vec4(0.11726952, -0.20521669, 0.12588736, -0.17531398), vec4(-0.031044729, 0.2175083, -0.24628168, -0.006086408), vec4(0.19189171, -0.16200952, -0.061495103, -0.11166556)) * bufB[0] + mat4(vec4(0.0742415, -0.06310822, 0.032758936, -0.07994149), vec4(-0.11311298, 0.22465213, 0.277356, 0.17876789), vec4(0.07453088, 0.08764454, 0.16842866, -0.123438984), vec4(-0.13300258, 0.25727955, -0.2554967, 0.056494348)) * bufB[1] + mat4(vec4(0.033347152, 0.26488164, -0.021232817, -0.13024843), vec4(0.25906122, 0.009492315, -0.122901835, 0.10377672), vec4(0.21701196, -0.16394185, -0.052983407, 0.27189156), vec4(-0.05498598, 0.102262385, -0.0010639585, 0.0011543151)) * bufB[2] + mat4(vec4(-0.15778223, -0.026572406, 0.014099703, -0.020671444), vec4(0.1028982, 0.124995776, -0.096144326, 0.047570895), vec4(-0.3647089, 0.06541705, -0.15792672, -0.21250744), vec4(0.045073062, 0.009488003, -0.1897781, -0.14441653)) * bufB[3] + mat4(vec4(0.0028203428, -0.23277229, -0.28973305, -0.23076029), vec4(-0.19406241, 0.20306388, -0.1591721, 0.13088568), vec4(-0.32017604, 0.1860045, 0.13009971, 0.09450798), vec4(0.028319633, 0.4981141, 0.034875937, -0.0056222174)) * bufB[4] + mat4(vec4(0.13678305, 0.46803412, -0.08710918, -0.034737196), vec4(0.06714418, -0.023281753, -0.13477102, -0.011367813), vec4(0.100766174, -0.12109047, -0.20074803, -0.15688768), vec4(-0.040960595, -0.055577837, -0.02685942, 0.053983774)) * bufB[5] + mat4(vec4(-0.03738117, -0.30382726, 0.13899356, 0.023429893), vec4(-0.1534612, 0.3029139, -0.12865844, -0.058131523), vec4(0.04699375, -0.112777576, -0.052044068, -0.03526492), vec4(0.042680252, -0.1062399, 0.001808316, 0.16279277)) * bufB[6] + mat4(vec4(-0.12814817, -0.038618077, -0.30689335, 0.31996778), vec4(0.08470756, 0.26066455, 0.19715932, -0.13581975), vec4(-0.48391035, -0.30129582, -0.0117129, -0.089052744), vec4(0.010933122, -0.28527844, -0.15801568, 0.17364882)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(-0.00090773543, 0.024765398, 0.0017882739, 0.020023366) + mat4(vec4(0.08879379, 0.12343048, 0.19355975, -0.12374405), vec4(0.01863982, 0.006081436, -0.28790075, -0.14143473), vec4(-0.02720893, -0.42853922, 0.10649855, 0.115528874), vec4(0.23786508, 0.1969868, 0.010660044, 0.16246064)) * bufB[0] + mat4(vec4(0.026607761, 0.048703935, -0.18961304, -0.18366471), vec4(0.06129296, 0.06221729, 0.14217508, -0.1635111), vec4(-0.16886415, 0.11731002, 0.173397, 0.14713481), vec4(-0.43983415, 0.10836869, 0.016292755, 0.12481249)) * bufB[1] + mat4(vec4(0.04555885, -0.17353384, -0.086783044, 0.05165712), vec4(-0.21927592, -0.39395833, 0.15721674, -0.09877077), vec4(-0.11186699, 0.06362127, -0.25257665, -0.040733974), vec4(0.056015752, 0.06740569, 0.43103176, -0.18916978)) * bufB[2] + mat4(vec4(-0.12475818, 0.13856323, -0.27840132, -0.27511492), vec4(-0.061156143, 0.19584052, 0.0105112465, -0.30453813), vec4(0.20221807, -0.025222223, 0.11101244, 0.13390747), vec4(-0.036005344, -0.070177145, -0.26903045, 0.03767473)) * bufB[3] + mat4(vec4(0.10381153, -0.093029514, -0.05421546, -0.08994188), vec4(0.28404236, -0.2086251, 0.13576506, 0.16696061), vec4(0.057081047, -0.28580844, -0.17080912, -0.019509284), vec4(0.092917085, -0.25466847, 0.024005514, 0.17371719)) * bufB[4] + mat4(vec4(-0.015247954, -0.04300271, 0.28613928, -0.07935175), vec4(0.31666535, 0.09617357, -0.05340463, 0.10357364), vec4(0.27048782, -0.5126131, -0.113741, -0.16879974), vec4(-0.15886599, 0.0529517, 0.04584354, 0.07422389)) * bufB[5] + mat4(vec4(0.2803038, -0.050791554, 0.19581777, -0.18960537), vec4(0.2657508, -0.001195852, 0.08199292, 0.12749921), vec4(-0.019790828, 0.26955608, 0.021023596, 0.10193622), vec4(0.25661165, -0.18741308, 0.214057, -0.08472616)) * bufB[6] + mat4(vec4(-0.13851877, 0.022791559, -0.14375539, -0.1943161), vec4(0.3030522, -0.012153894, -0.34512034, -0.07664916), vec4(0.054631747, 0.04247656, 0.017985001, 0.1404649), vec4(0.009944865, -0.13738845, -0.0131364735, -0.11374011)) * bufB[7];\nbufA[1] = vec4(-0.0012479543, 0.013299171, 0.036112055, 0.0026284081) + mat4(vec4(0.1410142, 0.15386988, 0.14016427, -0.13730624), vec4(-0.16154712, -0.1840838, -0.159774, 0.164435), vec4(-0.005448891, 0.0374344, 0.08904779, -0.15388535), vec4(0.08477423, -0.39146984, 0.121625796, 0.30508634)) * bufB[0] + mat4(vec4(0.01729529, -0.016966227, 0.021125518, -0.22067052), vec4(-0.15038595, 0.034322694, 0.13805729, 0.121687986), vec4(-0.20570825, -0.10243875, 0.032073084, -0.18971257), vec4(0.11750898, -0.27404734, -0.014908258, -0.16930854)) * bufB[1] + mat4(vec4(-0.06903628, -0.008200997, 0.123458706, -0.045277894), vec4(0.018555824, 0.15074506, -0.15894051, 0.0457452), vec4(-0.0087089725, -0.05660394, -0.12442378, -0.24978863), vec4(-0.19002979, -0.07658155, -0.010954044, -0.0022202872)) * bufB[2] + mat4(vec4(0.12021923, -0.21945764, -0.38387406, -0.11215487), vec4(-0.056928486, 0.08625454, -0.102797315, 0.089583114), vec4(0.20152351, 0.25019833, 0.092476614, 0.14975376), vec4(0.13392055, 0.04899593, 0.02162546, 0.012287432)) * bufB[3] + mat4(vec4(0.0070266128, -0.15433593, 0.15137172, 0.092406526), vec4(0.15974915, -0.2066178, -0.14980882, -0.26719335), vec4(-0.056636285, 0.021860873, 0.14170478, 0.064436436), vec4(0.03509077, -0.0026965735, 0.13378963, 0.18373483)) * bufB[4] + mat4(vec4(-0.6217683, 0.19286385, 0.07791121, -0.06575137), vec4(0.030630141, -0.35912678, -0.13921645, 0.04094377), vec4(0.012982201, 0.2872065, 0.10403004, -0.24507925), vec4(-0.4921628, -0.003823506, 0.19566546, 0.3755831)) * bufB[5] + mat4(vec4(-0.0068867095, -0.20028202, -0.11322322, -0.2078925), vec4(0.022203654, -0.03529943, -0.07216249, 0.18009932), vec4(0.6040669, 0.09993692, -0.11191897, 0.27877912), vec4(0.2824283, 0.14316238, -0.16627951, 0.033872563)) * bufB[6] + mat4(vec4(0.16015439, 0.2977278, 0.142793, 0.15838353), vec4(-0.42774433, -0.025307637, -0.122773185, 0.06429173), vec4(0.0003094141, -0.09835425, 0.17642325, 0.040156852), vec4(0.010462057, 0.29117653, -0.17571612, -0.084046915)) * bufB[7];\nbufA[2] = vec4(0.026529664, -0.01242776, -0.0043740533, 0.019370092) + mat4(vec4(-0.1539365, -0.14288056, -0.011359423, 0.26306993), vec4(-0.013573965, -0.07667894, -0.08633115, -0.11908233), vec4(0.023698887, -0.28437123, 0.30312794, 0.12751691), vec4(-0.3706544, 0.20286742, -0.07888283, -0.20957625)) * bufB[0] + mat4(vec4(0.09871043, 0.05501519, 0.064644344, 0.041088514), vec4(0.20930055, 0.25351894, -0.010963009, 0.024286546), vec4(0.5341704, 0.008018036, 0.06935221, -0.013459402), vec4(0.039748468, 0.192669, -0.0031243481, 0.19659947)) * bufB[1] + mat4(vec4(-0.23867175, -0.025558436, -0.11052103, 0.015600082), vec4(0.16721575, -0.002079394, -0.1163773, -0.043800168), vec4(0.10092197, -0.124048255, 0.13005507, 0.066404164), vec4(0.007291374, 0.1517885, 0.046339735, 0.3279252)) * bufB[2] + mat4(vec4(0.09006087, -0.21475555, 0.1458534, -0.10406544), vec4(-0.0562395, -0.04348287, -0.17155112, 0.06927982), vec4(0.001947562, -0.36740687, -0.22876851, -0.19070977), vec4(-0.09489506, -0.0005410871, 0.19076075, 0.0009317053)) * bufB[3] + mat4(vec4(-0.07198116, 0.09044889, 0.11872409, 0.16211358), vec4(-0.022220993, -0.028346237, -0.18884891, 0.20488754), vec4(0.033748414, -0.011641094, 0.04735837, 0.0140157975), vec4(-0.16484472, 0.06720538, -0.19006224, 0.026064944)) * bufB[4] + mat4(vec4(-0.29928795, -0.22814187, 0.06562348, -0.21380728), vec4(0.104309045, 0.02910018, -0.033195168, 0.15406474), vec4(0.00020705078, -0.013078414, 0.3278131, -0.027912725), vec4(0.1595081, -0.1036482, 0.34183997, -0.27918974)) * bufB[5] + mat4(vec4(-0.14256398, 0.2222391, 0.13442846, 0.04041185), vec4(0.12126158, 0.12488864, 0.044337686, -0.056888387), vec4(0.027434643, 0.07557426, 0.012647263, 0.1222286), vec4(-0.15238811, 0.16037348, -0.25994864, 0.11139763)) * bufB[6] + mat4(vec4(-0.2463162, -0.2249026, -0.084073894, 0.15681647), vec4(-0.1290665, -0.14385645, 0.15252885, 0.101522624), vec4(-0.0045281914, 0.06989558, -0.025298832, -0.045506485), vec4(-0.1987432, -0.010060166, 0.015635395, 0.20046337)) * bufB[7];\nbufA[3] = vec4(0.023581317, -0.0059065847, 0.008340137, 0.010768675) + mat4(vec4(0.26819146, -0.06226256, 0.11397164, 0.22784705), vec4(0.070901945, 0.31232646, 0.25285044, -0.05563011), vec4(0.32464322, 0.09736343, 0.11874564, 0.1379752), vec4(0.016253278, -0.11876894, 0.08005561, 0.031421464)) * bufB[0] + mat4(vec4(0.02990523, 0.0013262902, 0.07011328, 0.29759973), vec4(-0.27153543, 0.0664171, -0.08465212, 0.061835207), vec4(0.0037559494, 0.043714337, 0.24483399, -0.09189925), vec4(-0.39639518, 0.31176788, 0.18063074, 0.18164372)) * bufB[1] + mat4(vec4(0.15699655, 0.32205516, 0.20365046, 0.33136162), vec4(-0.0707035, -0.042981394, -0.15346952, 0.22472575), vec4(0.05302049, -0.29749262, 0.02699632, 0.08309115), vec4(-0.042944033, 0.07041512, -0.28277737, -0.048805244)) * bufB[2] + mat4(vec4(0.42952383, 0.06486891, -0.1407325, -0.010195683), vec4(-0.056484062, -0.09470093, -0.09928726, -0.05478626), vec4(-0.13161765, -0.20298553, 0.2905649, -0.1725956), vec4(0.21814656, 0.14044373, 0.16925232, -0.27383986)) * bufB[3] + mat4(vec4(-0.21227957, -0.07286176, 0.018225228, -0.08190546), vec4(-0.13562295, 0.10554264, 0.058605883, 0.048077505), vec4(0.24059442, 0.2454994, 0.14643866, -0.18513037), vec4(-0.055715613, 0.34504384, 0.17449842, 0.030148922)) * bufB[4] + mat4(vec4(-0.15880808, 0.34455892, 0.05061618, -0.08458242), vec4(-0.09910439, -0.2825654, 0.12869224, 0.04991299), vec4(-0.36112204, -0.18513128, -0.040982112, -0.11501862), vec4(-0.10961858, -0.062334098, -0.05752234, -0.091576144)) * bufB[5] + mat4(vec4(0.095185585, -0.21602982, 0.11153104, -0.10970645), vec4(-0.019186327, -0.11191752, 0.018941745, 0.30498776), vec4(-0.040937174, 0.24124241, -0.031650923, 0.12098698), vec4(0.11348876, 0.21107006, -0.12679969, -0.1757425)) * bufB[6] + mat4(vec4(-0.018987427, 0.030258713, 0.052693784, 0.039312705), vec4(-0.15748952, -0.27357867, 0.28390545, -0.086138286), vec4(-0.077332765, 0.10969088, 0.22661953, -0.045946855), vec4(-0.03083391, 0.21943101, 0.12983665, 0.094466254)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(0.010618741, 0.007141143, 0.026242621, -0.016578896) + mat4(vec4(-0.069838375, -0.4399129, -0.05512888, 0.1874657), vec4(0.06413281, 0.14237791, -0.18251732, 0.2443734), vec4(-0.104252234, -0.15753637, 0.1310684, -0.09659173), vec4(0.27486184, 0.03149485, -0.14757882, -0.04903821)) * bufB[0] + mat4(vec4(0.022242183, -0.24927051, 0.14139883, 0.15030523), vec4(0.28026646, 0.15964344, -0.17434523, -0.08497675), vec4(-0.16069621, 0.17857179, 0.13292153, -0.122776076), vec4(-0.42344856, 0.23100074, -0.1695607, 0.26967686)) * bufB[1] + mat4(vec4(0.08157221, 0.09925214, -0.03623917, -0.11723899), vec4(0.026257247, -0.27085996, -0.14118083, 0.071838185), vec4(0.04993575, 0.054240815, -0.06280207, -0.06215952), vec4(-0.1276642, -0.40386498, -0.10073023, 0.07134006)) * bufB[2] + mat4(vec4(0.2392366, -0.21677125, 0.15735213, 0.17199434), vec4(-0.21573511, -0.24393243, 0.03326026, 0.1810962), vec4(0.1251264, -0.09150808, -0.27319807, -0.1348337), vec4(0.077261515, -0.49895474, 0.046482448, -0.288604)) * bufB[3] + mat4(vec4(-0.47867796, 0.1797845, -0.103126645, -0.18048376), vec4(0.09072384, 0.3027625, 0.04936829, 0.26682904), vec4(0.014398234, -0.2918249, 0.019457556, -0.034472678), vec4(0.10120273, -0.0955138, 0.0927553, 0.2942644)) * bufB[4] + mat4(vec4(0.026654182, -0.06404044, -0.116903, 0.22064953), vec4(0.29567766, 0.14776178, -0.17214113, 0.097403094), vec4(0.051024824, -0.19262217, -0.114967845, -0.14018503), vec4(-0.26157776, -0.19712704, -0.090822674, 0.08117975)) * bufB[5] + mat4(vec4(-0.33189082, -0.12848467, -0.06279263, 0.11579304), vec4(0.42611066, 0.112809576, -0.16538635, -0.12563446), vec4(-0.105617024, -0.0068421634, 0.13038631, -0.2540529), vec4(0.14566626, -0.04945879, -0.07609732, -0.2506076)) * bufB[6] + mat4(vec4(0.1587547, 0.08101927, 0.084841214, 0.16278614), vec4(0.13204612, -0.079741985, 0.048393708, 0.004625291), vec4(0.24085216, 0.017246839, 0.20810854, -0.09619213), vec4(0.14973374, 0.16101468, 0.13505797, 0.28088775)) * bufB[7] + in0;\nbufA[1] = vec4(-0.056647908, 0.04482958, 0.031812645, -0.018519847) + mat4(vec4(0.24281491, -0.19296888, -0.14254138, -0.08184434), vec4(0.04881286, -0.05247893, -0.28696918, -0.091749266), vec4(0.18154868, 0.104438595, -0.13252918, -0.12612736), vec4(-0.3250179, -0.004976563, 0.19359604, -0.034515716)) * bufB[0] + mat4(vec4(0.12391495, -0.04755945, 0.077008896, 0.011678568), vec4(0.11065586, -0.01208154, -0.3586444, -0.1446697), vec4(0.032717377, 0.04220549, 0.03599193, -0.20008913), vec4(0.16581006, 0.053284876, -0.10856268, -0.09695318)) * bufB[1] + mat4(vec4(-0.28343534, 0.06264322, 0.071057715, -0.06308187), vec4(-0.0008548618, 0.22329079, 0.097872086, -0.035899892), vec4(-0.065978214, -0.20150238, 0.32321438, 0.2359113), vec4(0.099962175, 0.09760388, 0.17573254, 0.14698194)) * bufB[2] + mat4(vec4(-0.26774448, 0.064815626, -0.22315872, 0.08960176), vec4(0.06089649, 0.02870766, 0.0031973724, -0.20174354), vec4(-0.30556482, -0.12623082, 0.33117333, 0.06374136), vec4(0.18227865, 0.015603094, -0.44080916, 0.10959866)) * bufB[3] + mat4(vec4(0.152401, -0.012298313, -0.079305254, -0.16206767), vec4(0.053304546, 0.100868896, -0.005878477, 0.22975668), vec4(0.0051519265, 0.17788607, -0.12750323, -0.08411847), vec4(-0.18274957, -0.09729535, 0.15837003, 0.38314658)) * bufB[4] + mat4(vec4(0.15754883, 0.040822465, -0.02736126, -0.09781719), vec4(0.18656732, -0.0282488, 0.10419713, 0.29264408), vec4(-0.07141531, 0.08135913, 0.29291043, -0.14859141), vec4(0.07317201, 0.09159522, -0.053854596, 0.15316138)) * bufB[5] + mat4(vec4(-0.22691028, -0.089993194, -0.16893798, -0.049588703), vec4(0.20669368, 0.0053614196, -0.101521276, -0.034800738), vec4(-0.10811427, -0.35548598, -0.079348646, -0.45401278), vec4(0.031173741, -0.27176362, 0.06085525, -0.22498237)) * bufB[6] + mat4(vec4(-0.114444815, -0.16664337, -0.1632605, -0.058468897), vec4(0.2155082, -0.16572435, 0.18255436, 0.24716066), vec4(-0.11633201, -0.15740755, -0.22295527, 0.2596538), vec4(0.30876905, 0.07884093, 0.0058033187, -0.00031092335)) * bufB[7] + in1;\nbufA[2] = vec4(0.014584822, 0.01403275, 0.023581883, -0.0030764705) + mat4(vec4(0.007212227, -0.18713641, -0.3602914, -0.05581616), vec4(-0.10179494, -0.060699612, 0.15337105, -0.2769239), vec4(-0.2107867, 0.16709727, -0.28562596, 0.10724306), vec4(0.13774204, 0.26539266, -0.03913856, -0.032133475)) * bufB[0] + mat4(vec4(0.3071964, -0.13898197, -0.12690327, -0.047861125), vec4(-0.40273133, -0.046488468, -0.04620862, -0.04441271), vec4(-0.25104964, 0.24075511, -0.13897948, 0.021531157), vec4(-0.23510751, 0.074128896, 0.015311155, 0.18641794)) * bufB[1] + mat4(vec4(-0.015060444, -0.071039215, 0.13818088, 0.03849557), vec4(0.2265055, -0.16016875, 0.069368675, -0.114795744), vec4(-0.26652563, -0.0340035, -0.027119787, -0.032733135), vec4(0.0942954, 0.0510196, 0.050668925, 0.14748517)) * bufB[2] + mat4(vec4(0.03645335, 0.12186389, 0.024768464, -0.08862236), vec4(0.0073505216, 0.07813965, 0.034780934, 0.09032123), vec4(0.040205386, 0.25418407, -0.25943884, 0.027439607), vec4(0.07349637, 0.3292241, 0.08870709, 0.21622328)) * bufB[3] + mat4(vec4(0.022246515, 0.2548457, 0.2777853, 0.049780436), vec4(0.046675134, 0.1526991, 0.23539099, 0.10480024), vec4(0.21500105, 0.0119178565, 0.2698917, -0.29525265), vec4(0.11839921, 0.26326582, -0.01600443, 0.0771731)) * bufB[4] + mat4(vec4(-0.016854484, 0.13841349, -0.097221635, -0.33559898), vec4(0.04160463, 0.120488495, 0.16418868, 0.2508479), vec4(-0.0741532, 0.091962, -0.29891944, 0.049636874), vec4(-0.40537882, -0.045361858, 0.2856894, -0.073659144)) * bufB[5] + mat4(vec4(-0.18424065, 0.13899137, 0.09630163, 0.28146553), vec4(-0.06079049, -0.15063457, 0.19316933, -0.24495736), vec4(-0.20072928, -0.17604138, -0.04090952, -0.080709755), vec4(-0.0043213996, -0.15336856, -0.175681, 0.2031114)) * bufB[6] + mat4(vec4(0.2136767, 0.21471198, 0.015517448, 0.2871597), vec4(-0.19099653, -0.047660705, -0.052414656, 0.3049646), vec4(-0.1789628, -0.019069038, -0.20718025, 0.39256522), vec4(0.07633464, 0.1963815, 0.042058676, 0.013676206)) * bufB[7] + in2;\nbufA[3] = vec4(0.02835229, 0.010539764, 0.0028108803, -0.019533925) + mat4(vec4(0.13857597, -0.10635203, 0.07561386, 0.07616162), vec4(0.18327306, 0.11831314, -0.09904204, -0.267804), vec4(0.03594872, -0.07313839, 0.3636314, 0.12966125), vec4(0.23200105, 0.07845535, -0.03803329, -0.21786132)) * bufB[0] + mat4(vec4(0.107045464, 0.19480026, -0.09192805, -0.03942138), vec4(0.27447477, -0.06268928, 0.038538758, -0.015478185), vec4(-0.014576297, -0.23692562, 0.3307044, -0.15995349), vec4(0.034247372, -0.04021423, -0.24975255, 0.22129512)) * bufB[1] + mat4(vec4(0.003013884, 0.02028021, 0.15770942, 0.014838588), vec4(-0.057836395, 0.032944057, -0.15854597, -0.13988674), vec4(0.017885549, -0.06382104, 0.08123111, 0.12946428), vec4(0.20969757, -0.43904272, -0.17227015, -0.31316462)) * bufB[2] + mat4(vec4(0.14767112, -0.17869729, 0.13251482, -0.31360263), vec4(0.37541333, -0.35245803, -0.17180103, 0.17685562), vec4(-0.21305811, -0.2097253, 0.11386393, 0.06067269), vec4(-0.0039265305, 0.0851223, -0.15003575, -0.13484047)) * bufB[3] + mat4(vec4(-0.35089818, -0.0052604624, -0.15715808, 0.22133026), vec4(-0.24785148, -0.123606384, -0.18206, -0.11017736), vec4(0.046788994, 0.16547456, -0.19568399, 0.008108924), vec4(-0.29774433, 0.00471175, -0.1007762, -0.17325196)) * bufB[4] + mat4(vec4(0.09746535, 0.33275598, -0.047245167, -0.11310144), vec4(-0.015182381, -0.14850597, -0.07332459, 0.11497547), vec4(0.018080885, 0.24106973, -0.066750035, 0.05114624), vec4(-0.169193, -0.10812926, -0.37353116, -0.2653524)) * bufB[5] + mat4(vec4(-0.30484143, -0.24108262, -0.20758843, -0.07033534), vec4(-0.4407624, -0.0091153635, 0.040908765, 0.06537372), vec4(0.008042734, 0.047727197, 0.2244575, 0.4819548), vec4(-0.08034639, 0.052700065, 0.008142524, -0.1962406)) * bufB[6] + mat4(vec4(0.03758401, -0.14589949, -0.27277038, -0.2827568), vec4(0.0061045126, 0.018914752, -0.21188772, 0.33479828), vec4(0.024856059, -0.061210427, -0.16685364, 0.20526677), vec4(-0.11307932, -0.21482132, 0.19035286, -0.058035288)) * bufB[7] + in3;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(0.024447065, -0.0065997136, -0.020911325, 0.018264664) + mat4(vec4(0.07843969, 0.11109713, -0.22925621, -0.18940715), vec4(-0.089005016, 0.058212496, 0.28881145, -0.002871968), vec4(0.07874462, -0.016723527, 0.16948146, 0.122694165), vec4(0.074016556, 0.26941037, 0.13950486, -0.06593216)) * bufB[0] + mat4(vec4(-0.2239914, 0.14413059, 0.35306573, 0.09096214), vec4(-0.15990578, 0.27806184, -0.17989531, 0.05150438), vec4(-0.23291422, 0.07878018, 0.017089827, 0.18173528), vec4(0.13558346, -0.20163755, -0.055697188, -0.03994605)) * bufB[1] + mat4(vec4(0.050356798, -0.20777164, -0.21084239, -0.088526875), vec4(0.042108327, 0.120642655, 0.23004591, -0.036343053), vec4(0.043508787, 0.268447, -0.026219483, -0.03300331), vec4(0.21999513, -0.0812402, -0.043053832, 0.32188565)) * bufB[2] + mat4(vec4(-0.04405297, -0.20550837, -0.0587055, 0.2945101), vec4(0.38218227, 0.11558188, 0.36405852, -0.058435615), vec4(-0.18211631, -0.19574478, -0.10625969, -0.115900956), vec4(-0.22754928, -0.1187628, -0.2850278, -0.24722528)) * bufB[3] + mat4(vec4(-0.20236528, 0.047012534, 0.11249767, 0.07272749), vec4(-0.1281295, 0.26861486, -0.15358579, -0.074018225), vec4(-0.18553208, 0.07711307, 0.055308998, 0.26617697), vec4(-0.035079025, -0.15359539, 0.1664641, 0.2110733)) * bufB[4] + mat4(vec4(-0.15441003, -0.36566758, -0.118590355, 0.0137882), vec4(0.013185356, 0.06867107, -0.07383222, 0.14498776), vec4(-0.05959629, 0.20499498, -0.006502052, -0.008188403), vec4(-0.08699415, 0.12767914, 0.09814154, 0.23833188)) * bufB[5] + mat4(vec4(0.020704538, 0.3596543, 0.039980225, 0.10257418), vec4(-0.015550388, 0.072057225, -0.15759681, 0.15211037), vec4(-0.0949935, 0.051244304, -0.33959988, -0.1621093), vec4(-0.20521493, -0.08881603, 0.019585207, -0.06794708)) * bufB[6] + mat4(vec4(0.13503921, 0.07264471, 0.28798068, -0.048967507), vec4(-0.18343352, 0.032762922, 0.1902775, -0.080996685), vec4(0.10281374, -0.026354281, 0.123563886, -0.040997636), vec4(0.006025424, -0.07720926, -0.090724625, -0.07179808)) * bufB[7];\nbufA[1] = vec4(-0.008874102, 0.026735619, 0.010189454, 0.0025451735) + mat4(vec4(-0.21314584, 0.06233864, -0.11450743, -0.49038106), vec4(-0.029246105, -0.16110952, -0.05171185, 0.198681), vec4(-0.09143113, 0.18225485, 0.41730538, -0.07104813), vec4(-0.039306834, 0.2848535, -0.053128492, -0.098473504)) * bufB[0] + mat4(vec4(0.18720965, 0.07905521, 0.10688543, -0.0447787), vec4(0.011578242, -0.039645668, -0.06705441, -0.26834244), vec4(0.07325841, -0.023256907, -0.13320811, -0.07163476), vec4(-0.2045265, 0.30783737, -0.001845696, 0.3010566)) * bufB[1] + mat4(vec4(-0.0024895829, 0.06745131, -0.095818706, -0.10111809), vec4(-0.09241468, 0.056133274, 0.17158882, -0.28783995), vec4(0.115459956, 0.14072812, 0.23254207, -0.06021448), vec4(0.024170117, -0.32346702, -0.051700328, -0.01160732)) * bufB[2] + mat4(vec4(-0.13002504, -0.12049328, -0.12919438, -0.15405542), vec4(-0.09233488, -0.17907536, -0.22982803, 0.09117911), vec4(0.5295474, 0.19546081, 0.2643308, -0.1033375), vec4(-0.044201836, -0.18380383, -0.29402572, 0.07437936)) * bufB[3] + mat4(vec4(-0.0007554096, 0.004505129, -0.1501719, -0.041647475), vec4(0.114607, -0.14015874, -0.4981313, 0.057208084), vec4(0.028177692, -0.10613425, -0.029501844, 0.02136557), vec4(-0.13941786, -0.33059204, -0.3174945, 0.015949655)) * bufB[4] + mat4(vec4(0.20269333, 0.14591311, 0.056904342, 0.035418432), vec4(-0.16263108, -0.41918147, -0.0511233, 0.41566846), vec4(0.35738778, -0.31531242, -0.026406445, -0.24941114), vec4(-0.18398832, 0.18186045, -0.095728494, -0.045031834)) * bufB[5] + mat4(vec4(-0.07128366, 0.049689263, -0.13676438, -0.010830676), vec4(0.16891599, -0.031191789, 0.0743212, 0.046662856), vec4(0.012636815, 0.098951876, -0.38149256, -0.005370461), vec4(0.13090211, -0.027249498, 0.1496368, 0.28568962)) * bufB[6] + mat4(vec4(-0.18064287, -0.19577505, 0.079194166, 0.15966636), vec4(-0.03876835, 0.040453926, 0.02628013, -0.2675246), vec4(0.24997638, -0.0040670545, 0.04748497, -0.3096089), vec4(-0.035985805, 0.0371217, 0.040130634, 0.025183344)) * bufB[7];\nbufA[2] = vec4(-0.026508324, 0.057821915, 0.053845055, -0.010029131) + mat4(vec4(0.13749379, 0.35062978, 0.029368827, 0.017069371), vec4(-0.49570304, 0.28102812, -0.2606788, -0.06425771), vec4(-0.28645125, 0.029283812, 0.117440775, 0.10196673), vec4(-0.22542891, 0.2756543, -0.026864178, -0.12481861)) * bufB[0] + mat4(vec4(-0.12858526, -0.36296257, -0.17031907, -0.22416787), vec4(-0.08867632, 0.037892483, -0.06260093, 0.12015338), vec4(0.20248792, -0.054576267, -0.14785546, 0.018355887), vec4(0.22998318, 0.19374953, 0.04309262, 0.15403624)) * bufB[1] + mat4(vec4(-0.078509994, -0.34251043, -0.2439287, 0.1397673), vec4(-0.06204944, 0.20155269, -0.041234106, 0.030916872), vec4(-0.31191346, -0.043732148, 0.04174067, -0.104727425), vec4(-0.18538456, 0.07070673, 0.2017215, -0.32594192)) * bufB[2] + mat4(vec4(-0.025278289, 0.3140941, 0.3498839, 0.37262204), vec4(-0.04255557, 0.092590794, 0.04995954, 0.29607925), vec4(-0.2831805, -0.00176823, -0.28173223, 0.03892717), vec4(0.35449266, -0.16902909, 0.11494307, 0.07792814)) * bufB[3] + mat4(vec4(-0.12977925, -0.11169264, 0.20246759, 0.25959614), vec4(0.07738424, -0.18559422, 0.15347445, -0.061486572), vec4(-0.023988448, -0.26993677, -0.24059401, -0.08962756), vec4(-0.2325535, -0.045240466, 0.2751021, 0.29735667)) * bufB[4] + mat4(vec4(0.020324204, 0.06217086, -0.31459224, 0.19819313), vec4(-0.20266287, 0.06482059, 0.06026823, 0.20143667), vec4(-0.43939796, -0.06192357, 0.26767507, 0.16668637), vec4(0.030301562, 0.13602288, -0.15064275, -0.081913054)) * bufB[5] + mat4(vec4(0.07041697, -0.1163648, -0.0066984063, 0.25393862), vec4(0.25673303, 0.072139345, 0.028394565, 0.1433071), vec4(0.086474285, 0.02673448, 0.07054115, 0.16361953), vec4(-0.056751955, -0.13025793, -0.054032516, -0.04942781)) * bufB[6] + mat4(vec4(-0.16995011, -0.0735084, -0.43806013, -0.075938426), vec4(0.2483615, -0.17924568, 0.444355, -0.051419236), vec4(0.1594907, -0.3414286, -0.0003150213, -0.06379005), vec4(0.1443271, 0.0125328945, 0.30763376, 0.22116998)) * bufB[7];\nbufA[3] = vec4(0.041447945, 0.035839286, 0.06665748, -0.08557006) + mat4(vec4(-0.12188504, 0.23495744, 0.09078204, -0.0662647), vec4(-0.010639418, -0.14827825, 0.0014845561, 0.15213358), vec4(-0.0022727137, 0.09653232, 0.13875398, 0.2222872), vec4(-0.22252251, 0.12422398, -0.2364834, 0.32214496)) * bufB[0] + mat4(vec4(0.0062893736, -0.16376445, -0.1287047, -0.20207658), vec4(0.20374589, -0.15092058, 0.03146533, 0.012796644), vec4(0.2510554, 0.11411248, 0.13739878, 0.14365733), vec4(0.4418271, -0.014559326, 0.0052288766, 0.025997186)) * bufB[1] + mat4(vec4(0.073340155, 0.1711071, 0.4088479, 0.26283765), vec4(-0.07639865, 0.09442133, 0.13646023, -0.2723166), vec4(-0.12960838, 0.023573097, 0.24569894, -0.0050871004), vec4(0.30299497, -0.17203328, 0.17036663, 0.2779696)) * bufB[2] + mat4(vec4(0.06576418, -0.13247073, 0.15094757, 0.29581213), vec4(-0.28432134, -0.0053768526, 0.009624123, 0.09347373), vec4(0.061225206, -0.3870436, -0.21482883, 0.32273838), vec4(-0.44842523, -0.03733134, -0.0033607723, -0.25557455)) * bufB[3] + mat4(vec4(0.24303183, 0.18785004, -0.0014477998, 0.04108119), vec4(0.07924503, 0.09194916, 0.04428376, 0.08879996), vec4(-0.13431291, 0.09831655, -0.27349374, 0.016853208), vec4(-0.25515616, -0.18767557, -0.16588569, 0.18008113)) * bufB[4] + mat4(vec4(-0.116812535, 0.1471797, -0.20797578, -0.1280296), vec4(0.1322624, -0.36399218, 0.0446915, -0.16132809), vec4(-0.16094841, 0.047896374, -0.109721676, -0.0914746), vec4(0.13732405, 0.009546272, -0.16186771, 0.08093964)) * bufB[5] + mat4(vec4(-0.18942358, 0.16687518, -0.0061333687, -0.06324309), vec4(0.07454099, 0.08214017, 0.025058905, 0.20500264), vec4(0.1086473, -0.22524723, 0.070560575, 0.1289449), vec4(0.2742881, 0.08967203, 0.048431043, -0.079843566)) * bufB[6] + mat4(vec4(0.06484405, -0.018308327, 0.10789169, -0.04166101), vec4(-0.12056734, -0.10953515, -0.31461954, 0.23971103), vec4(-0.0306058, 0.1946146, 0.06430828, 0.262275), vec4(-0.27206022, -0.04730064, -0.17375526, 0.14634404)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(0.091378555, -0.058348347, -0.0201467, -0.056310553) + mat4(vec4(0.21467045, 0.1376415, 0.110163406, -0.021298207), vec4(0.054215558, -0.035342406, 0.20944543, -0.004427444), vec4(0.021275638, -0.23082413, 0.3693675, -0.08572785), vec4(-0.24130833, -0.19709258, -0.0016858805, 0.2232008)) * bufB[0] + mat4(vec4(0.06242182, 0.053177845, 0.007824526, 0.31364265), vec4(0.076932706, 0.17826246, -0.1278367, -0.13885649), vec4(-0.118408754, -0.119253166, -0.039416913, -0.005702574), vec4(0.25523934, 0.11308603, 0.17337684, -0.090866834)) * bufB[1] + mat4(vec4(0.20721862, 0.39620656, 0.41879216, -0.17729856), vec4(0.050512612, 0.025982898, 0.06972742, -0.28316274), vec4(0.094451, 0.11898992, -0.2984136, -0.37003493), vec4(-0.31803814, 0.08542717, -0.06607016, -0.17375948)) * bufB[2] + mat4(vec4(0.1754949, 0.21347436, -0.023534203, 0.32675543), vec4(0.24432723, 0.35811585, -0.5643289, -0.12239321), vec4(0.0692874, -0.2393267, 0.08367825, 0.18083815), vec4(-0.07113156, -0.17442623, -0.032080617, 0.2599624)) * bufB[3] + mat4(vec4(-0.05213306, -0.1296546, -0.17338063, 0.12947965), vec4(-0.18105303, -0.17638327, 0.14983313, -0.010728387), vec4(0.22368003, 0.18091509, -0.0931844, -0.2598466), vec4(-0.20059201, -0.20592564, 0.022419494, 0.27251327)) * bufB[4] + mat4(vec4(-0.23340334, 0.0890384, 0.16699529, -0.10330252), vec4(-0.06935931, -0.07944219, 0.011961148, 0.23190397), vec4(0.29397643, 0.16036448, 0.23126873, 0.28711456), vec4(-0.5050033, 0.086296886, 0.38589874, 0.33563954)) * bufB[5] + mat4(vec4(0.12798406, -0.21731766, 0.26573485, -0.41893893), vec4(-0.13874912, 0.1225234, 0.1215977, -0.27139276), vec4(-0.036308806, 0.03296974, -0.11423123, -0.13080823), vec4(0.20774168, 0.41469747, 0.010452655, -0.16093364)) * bufB[6] + mat4(vec4(-0.10247651, -0.011276807, -0.14299677, -0.05907503), vec4(-0.1380547, 0.105275206, -0.16955367, 0.016053436), vec4(-0.1491372, 0.23086266, -0.21436213, 0.023083096), vec4(-0.20868929, -0.2720337, 0.04016613, -0.093039855)) * bufB[7];\nbufA[1] = vec4(0.020227654, 0.05655869, 0.02879173, -0.0010876155) + mat4(vec4(-0.39338884, 0.35886782, 0.07143733, -0.3823724), vec4(0.016491188, -0.19443768, -0.18735456, 0.3297002), vec4(0.16720279, -0.2285589, 0.35033372, 0.2167981), vec4(-0.056305543, -0.06919555, 0.22028457, -0.03801244)) * bufB[0] + mat4(vec4(-0.2236926, 0.081844434, 0.073321976, -0.2910984), vec4(0.17740487, -0.10743837, 0.19509542, 0.2965181), vec4(-0.39583004, 0.07073184, 0.20524223, -0.24692617), vec4(-0.21924251, 0.033071596, 0.014189433, -0.27048194)) * bufB[1] + mat4(vec4(-0.015139631, -0.08049059, 0.5170259, -0.060832504), vec4(0.0965696, -0.45700684, -0.20288405, 0.047621854), vec4(0.026434494, 0.08971453, 0.09704391, -0.10083511), vec4(0.17128189, 0.106818594, -0.02803735, 0.04971021)) * bufB[2] + mat4(vec4(0.03508818, 0.022956371, -0.2267539, 0.1596562), vec4(0.33256853, 0.29602686, -0.17396498, -0.006368995), vec4(-0.014951627, 0.06833273, -0.07392775, -0.065251864), vec4(0.347173, -0.2860433, 0.16253088, 0.17714186)) * bufB[3] + mat4(vec4(-0.13288309, -0.28375342, -0.1758874, 0.023713425), vec4(0.057436157, 0.15540828, -0.12962142, -0.09465522), vec4(0.26256147, -0.11093815, 0.016709857, -0.04961727), vec4(0.2239084, -0.22305374, 0.010519089, 0.246959)) * bufB[4] + mat4(vec4(-0.4585331, 0.28561705, -0.035236284, 0.10654512), vec4(-0.025383404, -0.13029753, 0.29280522, 0.2213817), vec4(-0.11264322, -0.012526434, -0.05861116, -0.120355174), vec4(0.21657336, 0.1278672, -0.0315414, 0.14939812)) * bufB[5] + mat4(vec4(0.098485745, -0.028041638, 0.06073813, 0.021238256), vec4(0.09579782, 0.13713992, 0.104928106, -0.16545144), vec4(-0.2306353, -0.01817968, -0.1372663, -0.16862638), vec4(-0.03617571, -0.4678661, 0.34661123, -0.031839278)) * bufB[6] + mat4(vec4(-0.21363655, -0.10704725, -0.32054588, -0.05482057), vec4(0.0132973865, -0.045271423, 0.026618233, 0.40149876), vec4(0.024894364, -0.23738207, 0.1524702, -0.26680517), vec4(0.024951741, 0.042894296, -0.024373598, 0.07495067)) * bufB[7];\nbufA[2] = vec4(0.014836865, 0.13502918, -0.044287466, -0.093842946) + mat4(vec4(-0.10272317, -0.12445259, 0.23542425, 0.31342754), vec4(0.2562097, -0.16924818, -0.00904445, 0.089083835), vec4(-0.00023713554, -0.14836644, 0.07676743, -0.14020734), vec4(-0.12770112, 0.10068447, -0.07098099, 0.2898902)) * bufB[0] + mat4(vec4(-0.05649991, -0.17510493, 0.32925612, -0.012017842), vec4(-0.0061492873, 0.1843042, -0.14417571, -0.06300594), vec4(0.06661286, 0.21637645, -0.15743874, -0.07062903), vec4(-0.17401125, -0.26921847, 0.08564736, 0.0667394)) * bufB[1] + mat4(vec4(-0.33146444, -0.16291922, 0.015261055, -0.11542587), vec4(-0.16895658, 0.19888507, -0.20458436, -0.05113833), vec4(0.21293698, 0.22479263, -0.14467385, -0.21935499), vec4(-0.06370547, 0.06274645, -0.10362018, -0.096778505)) * bufB[2] + mat4(vec4(-0.03838965, -0.110978626, 0.01797122, 0.17102024), vec4(0.09247003, 0.26383108, -0.037645623, 0.3001975), vec4(-0.12920855, 0.04422217, -0.22939664, -0.20011377), vec4(0.011279304, -0.10733479, 0.011719596, -0.26319405)) * bufB[3] + mat4(vec4(0.1112735, -0.12188516, 0.22331315, 0.34230822), vec4(0.19697689, 0.29779464, 0.12187176, 0.25123435), vec4(-0.16801818, -0.41542843, 0.21906355, 0.19210698), vec4(0.22066273, -0.29855862, 0.12157504, -0.15689765)) * bufB[4] + mat4(vec4(0.09439741, -0.24263537, 0.071099825, -0.09700039), vec4(0.07957579, -0.029659862, -0.050787542, -0.13419704), vec4(0.16424233, 0.11398967, 0.13766116, 0.1880572), vec4(-0.23978777, -0.13006449, -0.04211178, -0.25387636)) * bufB[5] + mat4(vec4(-0.09897759, -0.14265816, -0.32927528, 0.20307702), vec4(0.23970377, -0.05970605, -0.07223086, 0.0023714802), vec4(-0.033487972, -0.44534716, -0.14206836, -0.029304123), vec4(-0.060940683, -0.30204302, -0.08514628, 0.28870568)) * bufB[6] + mat4(vec4(0.11971161, -0.17368248, 0.19630492, 0.023228604), vec4(-0.037911788, -0.106500424, 0.049261477, 0.105142824), vec4(-0.54915035, -0.14596191, 0.045026135, -0.103957824), vec4(-0.03971627, 0.23055242, 0.32343736, -0.010879001)) * bufB[7];\nbufA[3] = vec4(0.046404943, -0.029016923, 0.020221092, -0.08195147) + mat4(vec4(-0.13477142, 0.00827801, 0.046456296, 0.22709435), vec4(0.1308072, -0.062648274, -0.07505697, -0.076330915), vec4(-0.03763408, -0.014356859, 0.1590917, 0.05312983), vec4(0.1483096, -0.04277402, -0.10428823, 0.5973707)) * bufB[0] + mat4(vec4(0.1958799, 0.015943917, 0.0859572, 0.06506278), vec4(0.10142839, 0.07122185, -0.15099755, -0.12983775), vec4(-0.18777254, -0.039478865, -0.5253516, 0.6627805), vec4(0.44352785, -0.05380592, -0.58899194, 0.18402377)) * bufB[1] + mat4(vec4(-0.1034881, 0.06963375, -0.041632254, 0.058339458), vec4(0.115118414, -0.081906356, 0.23439986, -0.2111852), vec4(0.104598925, -0.10830961, -0.1297643, -0.09184501), vec4(0.0052791866, 0.4930674, -0.27728426, -0.21709812)) * bufB[2] + mat4(vec4(0.069109954, 0.077851236, 0.24261126, -0.34906706), vec4(-0.17095764, 0.023558134, -0.16461912, 0.18856312), vec4(0.03295034, 0.07081265, 0.20957917, 0.007543044), vec4(-0.12090014, 0.12417441, 0.0050429627, -0.073696196)) * bufB[3] + mat4(vec4(-0.1953115, -0.2451067, -0.10277769, -0.14098805), vec4(-0.0023005418, 0.0726669, -0.08695928, -0.12125938), vec4(0.4306205, -0.2587734, 0.20638281, 0.047781684), vec4(-0.31469062, 0.07329201, -0.37197316, 0.16140063)) * bufB[4] + mat4(vec4(-0.09557946, 0.12716414, -0.07848857, -0.023414105), vec4(-0.064001605, 0.12504926, -0.060617786, 0.08832514), vec4(0.23059987, -0.23716918, -0.23596145, 0.2775831), vec4(0.28394878, -0.11104968, 0.12937576, -0.28220677)) * bufB[5] + mat4(vec4(-0.2906984, 0.12970294, 0.030087119, 0.1807194), vec4(-0.0061073117, 0.09396447, 0.15470219, -0.17366849), vec4(0.08502642, -0.15468465, 0.17494562, -0.08793563), vec4(-0.19471163, -0.21397103, -0.19319296, -0.012757432)) * bufB[6] + mat4(vec4(-0.14906482, -0.04513449, 0.13131504, 0.006229128), vec4(0.21292697, -0.30420443, 0.18747807, -0.04063418), vec4(-0.2042967, -0.257605, 0.08641315, -0.09776967), vec4(0.17795992, -0.04962707, -0.12740721, 0.2163536)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(-0.09833077, 0.054418176, -0.048223227, 0.051002875) + mat4(vec4(0.20165266, -0.2571639, -0.13196857, -0.014630785), vec4(-0.25203863, -0.12882067, -0.21747679, 0.1907066), vec4(-0.20299922, 0.24962732, 0.29254588, -0.15471993), vec4(0.23175934, -0.08884075, -0.080305256, 0.088641904)) * bufB[0] + mat4(vec4(0.0828605, 0.4130337, -0.09824575, -0.16667151), vec4(-0.17253062, -0.04789495, -0.022905534, 0.25656182), vec4(0.08669836, -0.10589228, -0.27408442, -0.37236285), vec4(-0.18686944, -0.21707225, -0.09149773, 0.011891334)) * bufB[1] + mat4(vec4(-0.059195463, 0.07488677, -0.047500864, 0.29407284), vec4(-0.07158503, 0.14171115, 0.41896096, 0.10786146), vec4(0.03144595, -0.5135676, -0.13198502, -0.022422306), vec4(0.036280088, 0.078245945, -0.094425075, 0.09216257)) * bufB[2] + mat4(vec4(-0.28373948, -0.08192991, -0.2540202, -0.017866991), vec4(-0.19244553, -0.2068889, -0.14602602, -0.068094924), vec4(-0.051813964, 0.12575491, 0.2843164, -0.023074461), vec4(-0.1725795, 0.002589968, 0.08465194, -0.19735205)) * bufB[3] + mat4(vec4(-0.009761618, -0.076610796, -0.09542639, -0.09657886), vec4(-0.16313308, 0.10232767, -0.16348104, 0.17728014), vec4(-0.19893496, 0.023502428, -0.107214965, -0.26579058), vec4(0.14625005, -0.15177886, -0.069540106, -0.3360011)) * bufB[4] + mat4(vec4(0.10451042, 0.20020327, 0.08494536, -0.1762302), vec4(-0.11935651, 0.23933084, -0.26735112, -0.30907816), vec4(0.017021138, 0.08436788, 0.05673079, 0.047383707), vec4(-0.038788896, 0.05368702, -0.33254525, 0.039104674)) * bufB[5] + mat4(vec4(0.14373057, 0.055462573, 0.062442627, -0.25468487), vec4(-0.009430438, -0.25212142, -0.39659813, 0.063766666), vec4(-0.008731995, 0.20193206, 0.18187737, -0.26494935), vec4(-0.15440212, -0.1764273, -0.35309908, -0.17367013)) * bufB[6] + mat4(vec4(0.27104828, 0.031247612, 0.0052847858, -0.13724764), vec4(0.17896265, -0.057748668, -0.29573646, -0.13178252), vec4(-0.16851163, -0.003753003, 0.072531134, 0.13154799), vec4(0.24713333, 0.16299276, 0.36542943, 0.0024521146)) * bufB[7];\nbufA[1] = vec4(0.04555465, -0.0916264, 0.025501639, -0.0797136) + mat4(vec4(0.1513231, -0.208528, -0.09232099, -0.1589989), vec4(0.2256045, 0.08381184, -0.03107439, 0.16330945), vec4(0.20076331, 0.50386095, 0.10536451, -0.20210104), vec4(0.006666927, 0.10710603, 0.30493414, -0.02586814)) * bufB[0] + mat4(vec4(0.35253474, 0.022287553, -0.1365271, 0.1353031), vec4(-0.20575266, 0.024861922, -0.09888993, -0.11896045), vec4(0.056083385, 0.06879534, -0.28414717, 0.10690169), vec4(0.07441211, -0.15033172, -0.37128046, -0.2695964)) * bufB[1] + mat4(vec4(0.26935384, 0.25969264, 0.05145487, 0.10830803), vec4(-0.0061912485, 0.05587271, -0.30811954, -0.21127628), vec4(0.1295246, 0.18242411, 0.061500322, -0.050166197), vec4(0.24065375, -0.17983891, 0.2610238, 0.057886623)) * bufB[2] + mat4(vec4(0.26576078, 0.09941774, 0.18138322, -0.21062203), vec4(-0.25827038, 0.19018467, 0.11474641, 0.06640839), vec4(-0.0054386924, -0.21509728, -0.04994168, 0.070109814), vec4(-0.09959576, 0.22368802, -0.2806071, 0.20230956)) * bufB[3] + mat4(vec4(0.04099571, 0.269444, -0.22625145, 0.22175492), vec4(0.02045273, -0.3515006, 0.010580817, -0.07818541), vec4(0.12819505, 0.18312916, 0.41703755, -0.014198244), vec4(0.558227, 0.23843904, -0.1837419, -0.25334698)) * bufB[4] + mat4(vec4(-0.08927821, -0.2670345, -0.31870642, 0.22935048), vec4(-0.18304603, 0.03432857, 0.0767621, 0.3006079), vec4(-0.037915263, 0.35734975, -0.42461732, 0.018344682), vec4(-0.40082827, 0.40106806, 0.15361269, -0.09799758)) * bufB[5] + mat4(vec4(-0.2995419, 0.14502421, -0.061845005, -0.023767704), vec4(-0.068238124, -0.34390995, -0.11155049, -0.08563697), vec4(-0.12380586, 0.05785125, -0.32284465, -0.063625224), vec4(0.12167888, -0.019325357, -0.008687492, 0.5042734)) * bufB[6] + mat4(vec4(-0.20071723, 0.036530532, 0.500492, -0.3567519), vec4(-0.08795307, -0.1541681, 0.2802183, -0.24409185), vec4(-0.15888949, 0.3089125, 0.2413039, -0.042157926), vec4(0.4386573, -0.01716726, 0.096343175, 0.0399142)) * bufB[7];\nbufA[2] = vec4(-0.044126358, 0.051972255, -0.043788392, 0.042218305) + mat4(vec4(-0.01216839, 0.20969307, -0.322111, 0.06337672), vec4(0.16229402, -0.39506805, 0.21645129, 0.22832912), vec4(-0.13449216, -0.046434112, 0.11464327, 0.029846529), vec4(0.082174845, 0.045830287, 0.08592665, 0.12509541)) * bufB[0] + mat4(vec4(-0.3903989, -0.19671163, 0.16409345, -0.048208885), vec4(0.26691523, -0.0035908958, -0.15511487, -0.30769297), vec4(0.12719479, -0.031084271, 0.18809332, -0.047534745), vec4(0.23352104, -0.17237093, 0.23058528, 0.11081454)) * bufB[1] + mat4(vec4(-0.16069035, 0.1251949, -0.05569425, 0.2119139), vec4(-0.09340268, 0.16799086, -0.33077276, -0.01924143), vec4(0.09727626, 0.15275969, 0.3022671, -0.29600358), vec4(0.23467767, 0.07003816, -0.08802594, -0.2542075)) * bufB[2] + mat4(vec4(-0.2587514, -0.23281929, -0.022862036, 0.040673066), vec4(0.050747406, 0.25956962, 0.19086945, -0.19595063), vec4(0.20270175, -0.011953621, -0.1917323, 0.12241429), vec4(0.31335658, 0.11641854, 0.009437097, 0.13023409)) * bufB[3] + mat4(vec4(-0.07314371, -0.07042245, -0.2035682, 0.0142605845), vec4(-0.06436931, -0.41070306, -0.087564155, 0.14597887), vec4(-0.046016302, 0.14143682, 0.12947065, -0.13249174), vec4(0.004914443, 0.12792668, 0.03236982, 0.23722562)) * bufB[4] + mat4(vec4(0.051706653, -0.11104483, 0.5170574, 0.30331182), vec4(-0.01871773, 0.11007718, 0.21648261, 0.03312397), vec4(-0.17018476, 0.056373596, -0.06563616, -0.12776953), vec4(0.17362328, 0.116169676, -0.3246494, -0.061039492)) * bufB[5] + mat4(vec4(-0.033526387, -0.08226827, 0.43641508, 0.0018420306), vec4(0.27489352, 0.07153247, -0.15970644, 0.18063241), vec4(0.37113795, 0.014097171, 0.13247524, -0.12434086), vec4(-0.08094214, 0.07329475, -0.16885369, 0.02050546)) * bufB[6] + mat4(vec4(0.18943422, -0.08628953, 0.23760033, 0.059888244), vec4(-0.1904113, 0.06387547, -0.043942973, -0.25788015), vec4(-0.16221793, 0.07397221, -0.21446411, 0.104339965), vec4(0.11596044, 0.38119835, -0.043407418, 0.06218998)) * bufB[7];\nbufA[3] = vec4(-0.02563738, 0.07453802, 0.01578986, 0.07646519) + mat4(vec4(-0.09213535, 0.19859073, 0.08077167, 0.08125488), vec4(-0.27388853, -0.32181808, 0.24934159, -0.14194511), vec4(0.42648414, 0.04506408, 0.22953011, 0.12506996), vec4(0.2066278, -0.15794419, -0.012041615, -0.039080296)) * bufB[0] + mat4(vec4(-0.17500232, -0.012135948, 0.077285685, 0.14110813), vec4(0.030931266, -0.021096887, 0.21803926, -0.12151801), vec4(0.097730905, -0.056194596, -0.21490811, -0.11105026), vec4(0.002485781, 0.1496146, -0.24681142, -0.087490536)) * bufB[1] + mat4(vec4(0.24532086, 0.02515453, 0.38313767, 0.27410138), vec4(0.057949007, 0.06928681, 0.5112264, 0.2166674), vec4(-0.18624622, -0.25127095, 0.35689396, -0.11333762), vec4(0.26681203, 0.19309334, -0.0051415777, -0.2298836)) * bufB[2] + mat4(vec4(-0.15182678, 0.02512292, 0.3464609, -0.27389625), vec4(-0.13934283, 0.109909505, 0.068894215, 0.40177262), vec4(0.122896515, 0.56340504, -0.010636497, 0.3532702), vec4(0.14112946, -0.18579382, 0.09224363, -0.017580811)) * bufB[3] + mat4(vec4(0.030468868, -0.235311, -0.13204111, 0.20761494), vec4(-0.24326432, -0.1487142, -0.17665051, 0.18403381), vec4(-0.54593146, -0.20131831, 0.07611906, -0.011012999), vec4(0.10110932, 0.044580203, 0.15768257, -0.062157188)) * bufB[4] + mat4(vec4(-0.20370854, -0.051604174, 0.17517462, -0.2517666), vec4(0.3747894, 0.36486608, -0.09841301, 0.09553689), vec4(-0.16847919, -0.09462541, -0.064092204, -0.0063707326), vec4(-0.015295217, -0.03408272, 0.035607588, 0.021083293)) * bufB[5] + mat4(vec4(0.39921018, 0.07283116, 0.061690334, -0.29299173), vec4(0.26940346, -0.09038799, 0.47311985, -0.12607022), vec4(-0.050351255, -0.15718243, -0.21079107, 0.1028176), vec4(0.14647983, 0.08288881, -0.2784353, -0.0544648)) * bufB[6] + mat4(vec4(-0.21125163, -0.07283727, 0.111264266, -0.38460845), vec4(-0.03169613, -0.0597247, -0.20133193, -0.1643692), vec4(0.2089769, 0.034918718, 0.057727557, 0.2041535), vec4(-0.08991245, -0.040857427, 0.13304411, -0.05839531)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(-0.049310327, -0.039463475, 0.05425033, 0.011326355) + mat4(vec4(0.17441589, -0.10719187, -0.049967095, -0.14391051), vec4(0.10761328, -0.31444383, -0.1677751, 0.13854142), vec4(-0.39630717, -0.094832756, 0.31889337, -0.12153876), vec4(0.13954164, 0.18268272, 0.3299222, 0.21778512)) * bufB[0] + mat4(vec4(-0.11244572, 0.03734414, 0.2831894, 0.23513287), vec4(-0.07224861, -0.0038895987, -0.0031550187, 0.003390144), vec4(-0.0855897, 0.20114413, 0.15398319, -0.14079492), vec4(0.0357255, 0.10135716, 0.28919366, 0.29669568)) * bufB[1] + mat4(vec4(-0.0041086012, -0.09014776, -0.25063714, -0.059682738), vec4(0.30545345, -0.08213706, -0.02670222, 0.04014164), vec4(0.12618078, 0.16888474, -0.10397014, 0.13343413), vec4(-0.024193544, -0.1769409, -0.014431215, -0.03868831)) * bufB[2] + mat4(vec4(0.25372133, -0.29311207, 0.48758128, 0.1699305), vec4(0.45067996, -0.05364004, -0.06449066, -0.10928605), vec4(0.09759073, -0.33421054, -0.063329786, -0.26654634), vec4(0.32105875, -0.51209486, -0.07498054, 0.0016391375)) * bufB[3] + mat4(vec4(0.12836069, 0.1294461, -0.017449517, -0.32400718), vec4(-0.14596352, 0.2687605, 0.3320294, -0.049944725), vec4(-0.21400395, -0.17612892, -0.37979832, 0.25154182), vec4(0.1242007, -0.12990184, 0.21761209, 0.25066927)) * bufB[4] + mat4(vec4(-0.2226105, 0.05220635, 0.0064034276, 0.38008288), vec4(0.021027662, 0.25331295, 0.14731428, 0.276965), vec4(-0.3484062, 0.291554, 0.19399841, -0.29049596), vec4(0.009274175, 0.0046717594, 0.09335534, -0.11065682)) * bufB[5] + mat4(vec4(-0.3213359, 0.37625462, -0.5397647, -0.1352386), vec4(-0.1800668, 0.0077840686, 0.18483539, 0.4001831), vec4(0.03330887, -0.18088797, 0.048344348, -0.30630845), vec4(0.09451839, -0.0106499465, -0.25291255, -0.57652634)) * bufB[6] + mat4(vec4(0.09813024, -0.15891486, 0.090538114, -0.3224561), vec4(0.3399583, -0.092298254, -0.46438974, -0.19093175), vec4(-0.099534005, -0.013033444, 0.061747428, 0.099533506), vec4(0.20662428, -0.3414194, 0.3114172, 0.2596591)) * bufB[7];\nbufA[1] = vec4(0.09648705, 0.043127332, -0.05020903, 0.12940069) + mat4(vec4(0.07908006, -0.04489131, 0.09234484, 0.05048923), vec4(0.09841186, -0.33142495, -0.36337385, 0.12040648), vec4(0.077757, 0.0066281515, 0.20017838, 0.11544311), vec4(0.095890366, 0.022225933, -0.11293014, -0.34008574)) * bufB[0] + mat4(vec4(0.042057782, -0.11760418, -0.0076514427, 0.10912386), vec4(-0.22701403, 0.044532955, 0.41663957, -0.012757724), vec4(-0.0014435942, -0.047949716, 0.089169756, 0.23290712), vec4(0.17587504, -0.019285396, 0.04744393, 0.13982219)) * bufB[1] + mat4(vec4(0.092570305, -0.07192292, 0.055032916, -0.06884011), vec4(0.022869289, -0.19426122, 0.29573762, 0.022388553), vec4(-0.33703166, -0.12422418, -0.24536926, 0.042044014), vec4(0.029025964, 0.3237375, -0.235502, -0.31067017)) * bufB[2] + mat4(vec4(0.10140501, -0.24257568, 0.4417448, -0.33034506), vec4(0.07901319, 0.10041013, -0.20015316, -0.1477448), vec4(0.10925409, -0.286202, -0.24554344, 0.08675419), vec4(-0.03601872, 0.336365, -0.09399448, -0.29758093)) * bufB[3] + mat4(vec4(0.16918233, 0.09278764, -0.06759332, -0.24149892), vec4(0.023888128, -0.04621064, -0.15091912, -0.17686704), vec4(0.06909965, -0.07718372, 0.3648079, 0.09720598), vec4(0.41102165, -0.006446347, 0.21109743, -0.17303628)) * bufB[4] + mat4(vec4(-0.18222745, -0.28924537, -0.042289477, -0.044622764), vec4(0.06590158, 0.20128417, -0.102477156, 0.28460217), vec4(-0.46993452, 0.08258647, 0.068882465, 0.07342406), vec4(0.1073091, 0.16018705, -0.031465363, -0.13428776)) * bufB[5] + mat4(vec4(-0.22322811, -0.07429118, 0.15521543, 0.1813492), vec4(-0.47649613, 0.116867185, 0.28229624, -0.25443786), vec4(0.3977926, 0.45747936, -0.25634125, -0.101015866), vec4(-0.25141975, 0.019537503, -0.028466893, -0.37223917)) * bufB[6] + mat4(vec4(0.117988154, -0.10495977, 0.22906923, 0.046950955), vec4(-0.10702314, -0.5906195, 0.015940117, 0.33634585), vec4(0.11230944, 0.17258583, -0.30240783, 0.09250878), vec4(0.2954357, -0.111861885, 0.010382944, -0.129878)) * bufB[7];\nbufA[2] = vec4(0.0014226078, 0.18108448, 0.05594689, 0.05470278) + mat4(vec4(0.10954096, 0.22918543, 0.3061698, -0.08253376), vec4(-0.33712223, 0.09764458, 0.4758913, -0.0684582), vec4(-0.27978605, 0.1564769, 0.008109985, -0.07879867), vec4(0.2457603, -0.10547976, -0.12186126, -0.08690713)) * bufB[0] + mat4(vec4(0.001307446, -0.27701598, 0.02445424, -0.033733327), vec4(0.11471109, -0.031824324, -0.5936979, 0.22847928), vec4(-0.05192838, 0.050274182, -0.14364696, -0.08031055), vec4(-0.16594268, 0.17244302, -0.1503155, -0.38164017)) * bufB[1] + mat4(vec4(-0.11898521, 0.29948294, 0.11725536, 0.18861745), vec4(0.018878434, 0.18979536, -0.06296623, -0.32179847), vec4(-0.3577774, 0.18228978, 0.06880394, -0.11566647), vec4(-0.16475095, 0.044562664, 0.09154193, 0.059640754)) * bufB[2] + mat4(vec4(0.30588472, -0.30461273, 0.0035282387, 0.36218557), vec4(0.044588875, -0.24393404, 0.12973331, 0.08484998), vec4(-0.032318782, 0.10468461, 0.1507965, 0.08605477), vec4(0.06014255, 0.26094103, 0.1335347, -0.39420515)) * bufB[3] + mat4(vec4(0.088977434, -0.05873104, -0.44169465, -0.058169886), vec4(-0.044818234, -0.1724443, -0.124501504, 0.2011478), vec4(0.031819794, -0.48597184, -0.114723876, -0.15261127), vec4(-0.061014436, -0.17337944, 0.012049411, -0.1325832)) * bufB[4] + mat4(vec4(-0.61291885, 0.18889964, 0.01356514, -0.118787475), vec4(0.35619727, -0.26709816, 0.22002758, -0.41361997), vec4(0.28885898, 0.20870127, -0.21409018, 0.0012242566), vec4(-0.46700996, -0.59712875, -0.3702499, 0.28041768)) * bufB[5] + mat4(vec4(0.20644677, -0.45786688, -0.14659709, 0.3342389), vec4(-0.057896856, 0.11313018, -0.27392876, -0.10035008), vec4(0.23946394, 0.23512752, -0.29249173, 0.07384836), vec4(0.023341818, -0.24521895, 0.0602615, -0.17677595)) * bufB[6] + mat4(vec4(0.06651006, 0.13660838, 0.09524751, -0.3289074), vec4(0.14700602, -0.2309903, -0.015065451, -0.17629655), vec4(-0.36019328, 0.32891062, 0.20687927, 0.011469798), vec4(-0.08323675, 0.3009442, 0.060897816, 0.3573505)) * bufB[7];\nbufA[3] = vec4(0.06078902, 0.0263254, -0.106270835, 0.030020174) + mat4(vec4(0.03708064, 0.22929701, 0.044884324, -0.21493223), vec4(-0.40160522, -0.24646115, 0.18690109, -0.2032443), vec4(0.23964812, -0.22865337, 0.32984507, 0.10486585), vec4(-0.022197727, 0.2025173, -0.23888655, 0.0023832961)) * bufB[0] + mat4(vec4(0.18838643, 0.14116439, 0.19106849, 0.13343848), vec4(-0.0883966, -0.21011116, 0.16435425, 0.043351747), vec4(0.18879229, 0.13353631, 0.054724164, -0.2443976), vec4(0.044938724, 0.15219149, 0.21762706, -0.0058947043)) * bufB[1] + mat4(vec4(0.41836828, 0.29484752, 0.05882771, 0.079897374), vec4(-0.19906333, 0.096838646, 0.077307634, 0.13146348), vec4(0.14618056, 0.11432545, -0.21011887, -0.048496388), vec4(0.1707215, 0.59611404, -0.07861439, 0.028754042)) * bufB[2] + mat4(vec4(-0.16999273, -0.016694674, 0.08543361, 0.03482683), vec4(0.18958884, 0.4390058, 0.086200014, -0.118864164), vec4(0.06267322, -0.11324204, -0.07983137, -0.20616241), vec4(0.4628982, 0.20565395, 0.15767208, -0.3097559)) * bufB[3] + mat4(vec4(0.051855396, 0.013009268, 0.14055882, -0.12885886), vec4(-0.10007832, -0.20493273, -0.10618122, -0.07165679), vec4(-0.05852887, 0.20383213, 0.037903555, 0.09195614), vec4(0.44333023, -0.013326078, -0.0162471, -0.44160548)) * bufB[4] + mat4(vec4(-0.21731843, 0.07918449, 0.19121483, 0.022961667), vec4(0.26618642, 0.2374836, -0.20453393, 0.2201216), vec4(-0.059189502, 0.22872579, 0.10808795, 0.0280353), vec4(-0.24957147, 0.15962766, 0.12103716, 0.23951101)) * bufB[5] + mat4(vec4(-0.3690102, 0.34488702, -0.16457884, -0.28702092), vec4(-0.23489518, -0.2817006, -0.07234193, 0.124722116), vec4(0.25547472, -0.12553005, 0.022584094, 0.2921667), vec4(-0.091302596, 0.026706845, 0.2748765, -0.19317807)) * bufB[6] + mat4(vec4(-0.15531854, -0.17430173, -0.19190243, -0.14953338), vec4(0.11733544, -0.046222724, 0.52953607, 0.05597632), vec4(0.15473704, 0.085916854, 0.22432072, -0.2679783), vec4(-0.47191402, -0.18220136, 0.004501957, 0.25262737)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.008659524, 0.13896865, 0.20719159, -0.13253284) + mat4(vec4(0.2538267, 0.058676336, 0.18251145, -0.16517329), vec4(-0.16966642, 0.2942402, 0.09012356, -0.057658993), vec4(-0.072281644, -0.05285255, 0.10770886, -0.030593619), vec4(-0.10999975, -0.06638536, -0.07263863, -0.09633157)) * bufB[0] + mat4(vec4(-0.09763893, 0.13928618, 0.15668647, 0.087941386), vec4(-0.15842365, 0.26538095, 0.23462313, 0.10346431), vec4(0.27764463, 0.0022857885, -0.26453453, 0.15666498), vec4(-0.16721053, -0.22264762, 0.014069604, -0.4223739)) * bufB[1] + mat4(vec4(0.17275366, 0.21312284, 0.042952135, -0.004911232), vec4(0.11609789, -0.21141662, 0.15810716, -0.03505625), vec4(0.14910527, 0.2146849, 0.46997854, -0.34459475), vec4(0.005601259, 0.07973084, -0.073866464, -0.29238552)) * bufB[2] + mat4(vec4(0.08242545, 0.40047956, 0.10634125, -0.21746986), vec4(-0.03875481, -0.07239307, 0.07710221, -0.2929328), vec4(0.31435114, 0.09745779, -0.20338416, -0.389185), vec4(0.564487, -0.3493018, -0.1291495, 0.14967236)) * bufB[3] + mat4(vec4(0.0148455, -0.25201496, -0.28163424, 0.25755665), vec4(-0.096878454, -0.19581626, 0.10315153, 0.25291827), vec4(0.028854093, -0.15653405, -0.04739351, 0.4456272), vec4(-0.029195651, -0.056986466, 0.30047086, -0.36159402)) * bufB[4] + mat4(vec4(0.16893893, -0.022455709, -0.17422476, -0.07583615), vec4(-0.23874605, -0.16432445, 0.01116653, 0.02811502), vec4(-0.41542846, 0.13600658, 0.15379533, -0.39249787), vec4(-0.052016344, -0.13817677, -0.102939054, -0.2909199)) * bufB[5] + mat4(vec4(0.08263286, 0.121487126, -0.11061312, 0.19867612), vec4(0.15213636, -0.13242385, 0.10190352, -0.0359659), vec4(-0.34982964, -0.22332872, 0.44205332, -0.36106947), vec4(-0.5919018, -0.22307222, 0.07409882, -0.15649429)) * bufB[6] + mat4(vec4(0.08633056, 0.0026700876, 0.11525046, 0.7334044), vec4(0.0674368, -0.07955788, -0.41075516, 0.7239343), vec4(-0.024916321, 0.2753463, 0.4540179, -0.21127824), vec4(-0.25300312, 0.23359543, -0.23688899, -0.10057053)) * bufB[7];\nbufA[1] = vec4(-0.010253543, 0.11845847, -0.06700246, -0.070128694) + mat4(vec4(-0.00975535, -0.14190648, -0.053803492, 0.2700528), vec4(0.16922927, 0.034736633, -0.15109386, 0.10039582), vec4(0.3945825, -0.18928128, -0.09652841, 0.3729427), vec4(-0.115050085, 0.081185006, -0.13573278, -0.2886958)) * bufB[0] + mat4(vec4(0.0324379, 0.28761262, 0.47459313, -0.048865728), vec4(-0.07831431, 0.09179615, -0.030803828, 0.06869656), vec4(-0.061162814, -0.0643675, 0.18950424, 0.47761944), vec4(-0.38236815, 0.0010762117, -0.19887772, 0.28486678)) * bufB[1] + mat4(vec4(0.2618422, 0.13826865, 0.40180716, 0.2946186), vec4(-0.14434992, 0.13371179, 0.18607263, 0.15528706), vec4(-0.22169557, 0.14503364, -0.25171143, -0.13324313), vec4(-0.22440895, -0.20075263, -0.34978303, -0.1123877)) * bufB[2] + mat4(vec4(0.3173881, -0.24030599, 0.5330754, 0.13474362), vec4(-0.115182325, 0.3259539, 0.037811138, 0.40254006), vec4(-0.23699816, 0.007412058, -0.47459197, 0.16800451), vec4(-0.09565125, -0.35751024, -0.26539606, -0.024293413)) * bufB[3] + mat4(vec4(0.08400804, 0.16448952, -0.26880506, -0.04750064), vec4(-0.22719581, -0.19195539, 0.2746393, 0.18470757), vec4(0.30708915, -0.22117797, -0.09705254, 0.027309183), vec4(-0.47473305, -0.2807709, -0.10771416, 0.04660897)) * bufB[4] + mat4(vec4(0.70818657, -0.018289506, 0.16403873, -0.45456174), vec4(0.12239469, -0.2969133, 0.21998511, 0.4553886), vec4(0.18906124, -0.044468448, 0.04680858, -0.023110135), vec4(-0.1253242, -0.29148623, -0.5340617, -0.2868094)) * bufB[5] + mat4(vec4(0.6301106, 0.26093113, 0.014776035, -0.13901314), vec4(0.1136367, -0.07073197, -0.20277014, -0.14790323), vec4(-0.021096865, -0.14768943, 0.16093855, 0.19120881), vec4(0.16507243, 0.13477619, -0.023409277, 0.17739475)) * bufB[6] + mat4(vec4(-0.08372462, -0.27883157, 0.2082229, 0.34746003), vec4(-0.6794335, 0.10153871, -0.35110605, -0.02565731), vec4(-0.31311572, 0.13830411, -0.19402494, -0.6173469), vec4(-0.3284254, -0.068640135, 0.20647852, 0.1989239)) * bufB[7];\nbufA[2] = vec4(-0.03006415, 0.26772273, -0.0039509884, -0.15091774) + mat4(vec4(-0.031415183, 0.087866254, 0.12056083, 0.035957403), vec4(0.045347467, -0.16916068, 0.068533584, 0.14617038), vec4(0.061970145, 0.13553716, -0.16422263, -0.25467083), vec4(0.13199674, -0.30614644, 0.42531303, -0.20412365)) * bufB[0] + mat4(vec4(0.23020358, -0.105096154, -0.27251962, -0.1567153), vec4(0.011990239, -0.017223371, 0.016260479, -0.32198057), vec4(-0.04795313, -0.18440984, 0.22415084, -0.14788067), vec4(-0.1814249, 0.22933383, 0.16735113, -0.20212281)) * bufB[1] + mat4(vec4(-0.18605727, -0.41135255, -0.36705193, -0.00784761), vec4(0.17606442, -0.2531343, 0.18136838, -0.1475955), vec4(0.22729139, -0.06377001, 0.08565687, -0.14645441), vec4(-0.28144774, 0.07697351, 0.642412, -0.2590077)) * bufB[2] + mat4(vec4(0.03862418, -0.14180225, 0.38178977, -0.044708602), vec4(-0.23925765, -0.13151257, -0.19455959, 0.11365497), vec4(0.022421326, -0.0594604, -0.14479372, 0.11244611), vec4(-0.29260474, 0.2499954, -0.4569944, 0.117615975)) * bufB[3] + mat4(vec4(-0.09733348, -0.70816743, -0.39928365, 0.24135865), vec4(0.19998774, 0.3414118, -0.09899232, -0.29480934), vec4(0.36903983, -0.36922345, 0.30145103, 0.27266648), vec4(0.0723216, -0.39017865, -0.27715817, 0.012958095)) * bufB[4] + mat4(vec4(0.090773314, 0.07258846, 0.20505373, -0.06344248), vec4(0.35722658, -0.31354472, 0.40549332, -0.19002843), vec4(-0.029057251, 0.32293862, -0.13676256, 0.3835807), vec4(0.31918088, -0.29060408, 0.18808053, 0.0036034787)) * bufB[5] + mat4(vec4(-0.17771098, -0.10699173, 0.18275395, 0.11504387), vec4(-0.33185703, 0.11591176, 0.07303012, 0.38057178), vec4(0.45859456, -0.29742837, -0.33328438, -0.11177309), vec4(-0.15438153, -0.042431723, 0.4411904, 0.07446238)) * bufB[6] + mat4(vec4(0.038738884, 0.2330852, 0.056642152, -0.43330517), vec4(-0.21146952, 0.00799525, 0.17909972, -0.120695725), vec4(0.1578295, 0.089416236, 0.11984588, 0.2488035), vec4(0.10453331, -0.13445789, -0.48852503, 0.4234623)) * bufB[7];\nbufA[3] = vec4(-0.07532936, 0.07956913, -0.011387418, -0.036479667) + mat4(vec4(0.36350667, -0.05666064, -0.021973247, -0.21061221), vec4(0.20310919, 0.03181924, 0.13943042, -0.03124947), vec4(0.08529683, -0.51282585, -0.30048978, -0.07056396), vec4(0.059908997, 0.18077366, 0.09338182, -0.101343066)) * bufB[0] + mat4(vec4(0.36625, -0.29182464, -0.054958582, 0.38941061), vec4(0.058564436, -0.14727592, 0.094741106, -0.13252325), vec4(0.16572765, -0.23608555, -0.49733946, -0.1762938), vec4(0.2716811, -0.10744113, 0.15835631, -0.12221606)) * bufB[1] + mat4(vec4(0.26542667, -0.08752734, -0.011805017, -0.2933594), vec4(-0.15029559, 0.16958675, 0.27210695, -0.00084592483), vec4(-0.022908356, 0.28883302, 0.14798588, -0.1859789), vec4(-0.15554501, 0.01666535, -0.076530255, 0.27927268)) * bufB[2] + mat4(vec4(0.133365, -0.24087556, -0.015117578, -0.017878015), vec4(-0.016917909, 0.04444952, 0.122061715, -0.02022217), vec4(0.18051755, 0.17667027, -0.045875166, 0.2477773), vec4(0.07500952, 0.040779423, -0.36225685, 0.5216184)) * bufB[3] + mat4(vec4(-0.108113855, -0.1299506, 0.041907944, -0.15751083), vec4(0.27800882, 0.32515815, 0.24606836, 0.5217485), vec4(0.043559924, -0.3517873, -0.12749048, -0.22871415), vec4(0.074866064, -0.5058325, -0.034348637, 0.011342927)) * bufB[4] + mat4(vec4(0.09596191, 0.052627463, 0.063195154, -0.23167117), vec4(-0.056604575, -0.12483692, -0.08464235, -0.18444258), vec4(0.07514917, -0.09152633, -0.23945837, 0.06342518), vec4(0.24449338, 0.13372377, 0.1306023, 0.44973034)) * bufB[5] + mat4(vec4(-0.55843425, -0.35226893, 0.115407445, 0.08358865), vec4(-0.5640226, 0.5004561, 0.31139556, -0.1374765), vec4(-0.21400036, -0.07303242, 0.041994058, -0.326192), vec4(0.111593515, -0.4178491, -0.17098877, 0.31326076)) * bufB[6] + mat4(vec4(0.4662072, -0.019523665, 0.05299573, -0.08354999), vec4(-0.2803353, 0.3109778, 0.11745559, 0.5279129), vec4(0.10839666, -0.25435495, 0.2820068, -0.22322878), vec4(0.39722922, -0.019412387, -0.51989794, -0.38795224)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(0.09276742488145828, 0.006313864141702652, 0.09400972723960876, 0.0) + mat4(vec4(-0.009082479402422905, -0.09618537873029709, -0.05412061884999275, 0.0), vec4(-0.1024560034275055, -0.009011960588395596, -0.10777462273836136, 0.0), vec4(0.10663172602653503, 0.01759677194058895, 0.0405387207865715, 0.0), vec4(-0.05050364136695862, -0.08828376233577728, -0.07829759269952774, 0.0)) * bufB[0] + mat4(vec4(0.03429563343524933, 0.07135413587093353, 0.04201420769095421, 0.0), vec4(0.005571917165070772, -0.019401568919420242, 0.11412903666496277, 0.0), vec4(0.020174480974674225, -0.06661857664585114, -0.0535488985478878, 0.0), vec4(-0.11750896275043488, -0.07272236049175262, -0.09138499200344086, 0.0)) * bufB[1] + mat4(vec4(0.0736083835363388, 0.019975261762738228, 0.04345898702740669, 0.0), vec4(-0.07747188955545425, -0.047622401267290115, -0.05897551774978638, 0.0), vec4(0.04516145586967468, 0.0470823310315609, 0.00815138965845108, 0.0), vec4(0.06326532363891602, 0.04919764772057533, 0.1357603818178177, 0.0)) * bufB[2] + mat4(vec4(-0.018590908497571945, -0.021667737513780594, -0.06427363306283951, 0.0), vec4(-0.01847735233604908, 0.01852480135858059, 0.11320092529058456, 0.0), vec4(-0.029709089547395706, 0.08342652022838593, 0.03224649280309677, 0.0), vec4(-0.019444430246949196, 0.007755672093480825, 0.10132010281085968, 0.0)) * bufB[3] + mat4(vec4(0.07365400344133377, 0.015257793478667736, -0.09280645847320557, 0.0), vec4(0.01364419236779213, -0.0906759724020958, -0.09422896802425385, 0.0), vec4(0.11033598333597183, 0.04519486799836159, -0.08464454114437103, 0.0), vec4(0.11080411076545715, 0.1359335482120514, 0.12313579767942429, 0.0)) * bufB[4] + mat4(vec4(0.1463177651166916, 0.15343278646469116, 0.16645309329032898, 0.0), vec4(-0.15586480498313904, -0.12489683926105499, 0.0077819605357944965, 0.0), vec4(0.08433365821838379, 0.0905037373304367, 0.036559220403432846, 0.0), vec4(0.025482652708888054, 0.07461335510015488, 0.15126948058605194, 0.0)) * bufB[5] + mat4(vec4(-0.10709093511104584, -0.11167994141578674, -0.16960687935352325, 0.0), vec4(-0.19009053707122803, -0.1603417843580246, -0.11009759455919266, 0.0), vec4(-0.14509636163711548, -0.1415204405784607, -0.13188472390174866, 0.0), vec4(-0.12020419538021088, -0.1305268108844757, -0.05733203515410423, 0.0)) * bufB[6] + mat4(vec4(0.08011387288570404, 0.11546795815229416, 0.12679047882556915, 0.0), vec4(-0.17172864079475403, -0.13398389518260956, -0.21410366892814636, 0.0), vec4(0.006712683476507664, 0.042790357023477554, 0.12579475343227386, 0.0), vec4(-0.12514819204807281, -0.08413729816675186, -0.1964339017868042, 0.0)) * bufB[7];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(2., -2.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.01*sin(iTime), 50.01*sin(0.09*iTime), 0.2*sin(0.04*iTime), sin(0.13*iTime));\n}\n        ",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Very nice, great colors",
        "date": "1560873929",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XtjcW3",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wlBGWD",
      "date": "1559570500",
      "viewed": 11272,
      "name": "Fake move",
      "username": "avin",
      "description": "Reproduction of article https://journals.sagepub.com/doi/full/10.1177/2041669518815708",
      "likes": 15,
      "published": 3,
      "flags": 0,
      "tags": [
        "illusion"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define SQUARE_SIZE .2\n#define EDGE_SIZE .005\n#define SPEED 15.\n\n#define PI_2 1.5707963\n#define PI_4 0.7853981\n#define PINK_COL vec3(136,105,121)/255.\n\n#define sinp(v) (sin(v) * .2 + .4)\n\nvec3 addEdgeCol(vec3 squareCol, float side, float time){\n\tfloat edge = step(EDGE_SIZE + side, SQUARE_SIZE);    \n    vec3 edgeCol = vec3(sinp(time));\n    return mix(edgeCol, squareCol, edge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    uv *= mat2(1,-1,1,1) * 0.7; // PI/4 rotation\n    \n    float t = iTime * SPEED;\n        \n    float m = step(max(abs(uv.x),abs(uv.y)), SQUARE_SIZE );                  \n            \n    float time1 = t + PI_2;\n    float time2 = t - PI_2;  \n    \n    vec3 squareCol = PINK_COL;  \n            \n    // top-left edge\n    squareCol = addEdgeCol(squareCol, -uv.x, time1);        \n    // top-right edge\n    squareCol = addEdgeCol(squareCol, +uv.y, time1);       \n    // bottom-right edge\n    squareCol = addEdgeCol(squareCol, +uv.x, time2);           \n    // bottom-left edge\n    squareCol = addEdgeCol(squareCol, -uv.y, time2);        \n    \n    vec3 backCol = vec3(sinp(t));\n    \n    vec3 col = mix(backCol, squareCol, m);\n    \n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Thanks for the link. How about providing a direction & sizing button, changing the order of time1 & time2 in lines 32-38?",
        "date": "1560940989",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "Xl2yWc",
        "hidden": 0
      },
      {
        "text": "A grreat illusion.  Nice one, avin.",
        "date": "1560940257",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "4t2yWc",
        "hidden": 0
      },
      {
        "text": "Intense. It definitely moves. But the world moves together with it :3",
        "date": "1560283489",
        "username": "metalim",
        "userpicture": "/media/users/metalim/profile.jpeg",
        "id": "ltBcDV",
        "hidden": 0
      },
      {
        "text": "@FabriceNeyret2 thank you for a cool trick of pi/4 rotation",
        "date": "1559585570",
        "username": "avin",
        "userpicture": "/media/users/avin/profile.png",
        "id": "MljyRd",
        "hidden": 0
      },
      {
        "text": "wow",
        "date": "1559584733",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MtjyRd",
        "hidden": 0
      },
      {
        "text": "cool !\n\nsome remarks:\n\nfor just pi/4 rotation, you could avoid trigo and use one of the following:\n    uv = vec2(uv.x-uv.y, uv.x+uv.y)/sqrt(2.);           \n    uv = (uv+vec2(-uv.y,uv.x))/sqrt(2.);\n    uv *= mat2(1,-1,1,1)/sqrt(2.); \n\na bit cheaper: m = step(max(abs(uv.x),abs(uv.y)), SQUARE_SIZE );\nyou could factor left-right edges the same way.\nAlso, all your step and mix(binary value) could be replace by if else. (except if you later turn step to smoothstep ;-) )\n\ngrey cols: why not using floats rather than vec3 ?\n",
        "date": "1559581971",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "Mljczt",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wlSGDD",
      "date": "1559713614",
      "viewed": 766,
      "name": "Cube-mapped Double Quad Truchet",
      "username": "BigWIngs",
      "description": "See comments for details. Mouse to move",
      "likes": 31,
      "published": 1,
      "flags": 0,
      "tags": [
        "cubemap",
        "truchet",
        "double",
        "quad"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Cube-mapped Double Quad Truchet by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com  Twitter: @The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Playing around with truchet tiles. This makes use of the normal quad tiling\n// but has two exit points per edge instead of one making for a lot more random\n// looking effect. The lines from entry to exit point are made of segmented\n// bezier splines which isn't terribly performant but looks nice.\n// \n// In order to get this onto a sphere without any poles I used a cubemapping\n// technique which works well with quad truchet because it seemlessly fits\n// corners where three edges meet.\n//\n// I didn't make completely random entry-exit point combinations. Perhaps \n// someone can come up with a clever algorithm for this. Instead, I made a bunch\n// of presets that I choose from randomly, subsequently I rotate the entry-exit\n// points by a random offset to get the variety you see. There should be many more\n// variations though if the points were truly random. A quick calculation (and I\n// might be wrong) yields 8 factorial divided by two different combinations,\n// which is more than 20 thousand\n//\n// Set SHOWGRID to true to be able to see the truchet tiles.\n//\n// Use these to change the effect\n\n#define SHOWGRID false\n#define BEZIER_STEPS 8\n#define GRID_SIZE 5.\n#define SPLINE_WIDTH .1\n#define SPLINE_COLOR vec3(1)\n#define SPLINE_SOFTNESS .5\n#define SHADOW_WIDTH 3.\n#define CYCLE_VARIATIONS 0.\n\n// entry-exit point presets\nfloat g[64] = float[64] (\n\t0., 3., 1., 5., 2., 7., 4., 6.,\n    0., 1., 2., 3., 4., 7., 5., 6.,\n    0., 7., 1., 5., 2., 6., 3., 4.,\n    0., 4., 1., 3., 2., 5., 6., 7.,\n    0., 5., 1., 4., 2., 7., 3., 6.,\n    0., 6., 1., 5., 2., 4., 3., 7.,\n    0., 2., 1., 5., 3., 4., 6., 7.,\n    0., 7., 2., 6., 3., 4., 5., 1.\n);\n\nfloat N21(vec2 p) {\n\tp = fract(p*vec2(123.34,345.56));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat dLineSeg(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\n// distance to segmented cubic bezier\nfloat dBezier(vec2 p, vec4 a, vec4 b) {\n    \n    vec2 p1=a.xy, p2=p1+a.zw, p3=b.xy+b.zw, p4=b.xy;\n        \n    float d = 100.;\n    \n    vec2 pb = p1;\n    vec2 ppb;\n    \n    for(int i=0;i<BEZIER_STEPS;i++) {\n    \tfloat t = float(i+1)/float(BEZIER_STEPS);\n        \n        ppb = pb;\n        \n        vec2 p12 = mix(p1, p2, t);\n        vec2 p23 = mix(p2, p3, t);\n        vec2 p34 = mix(p3, p4, t);\n        \n        vec2 p1223 = mix(p12, p23, t);\n        vec2 p2334 = mix(p23, p34, t);\n        \n        pb = mix(p1223, p2334, t);\n        \n        d = min(d, dLineSeg(p, ppb, pb));\n    }\n    \n    return d;\n}\n\n\n// returns position and tangent that we need to draw bezier spline\nvec4 GetVec(float i, float s) {\n    \n    i = mod(i, 8.);\n    // i  ->  0   1   2   3   4   5   6   7\n    // x  -> -1   1   2   2   1  -1  -2  -2\n    // y  ->  2   2   1  -1  -2  -2  -1   1\n     \n    float a = 6.2832*i/(8./9.);\n    vec2 pos = vec2(\n        round(cos(a-.5*3.1415-.3)*2.),\n        round(cos(a-.3)*2.)\n    );\n    \n    i = floor(i/2.);\n    \n    // i  ->  0  1  2  3\n    // x  ->  0 -1  0  1\n    // y  -> -1  0  1  0\n    \n    float m2 = mod(i, 2.); \t\t// 0 1 0 1 0 1\n   \tvec2 tangent = vec2(\n        i==1. ? -1. : m2,\n        i==0. ? -1. : 1.-m2\n    );\n    \n    // you can scale tangent to get different looking splines\n    //tangent *= 3.;//mix(.25, 2.5, fract(sin(s*345.23)*5434.));\n\t \n    return vec4(pos.x, pos.y, tangent.x, tangent.y)*.25;\n}\n\n// draw a spline with a shadow\nvec4 Spline(vec2 uv, float w, int k, float n, float s) {\n\tfloat d = dBezier(uv, GetVec(g[k+0]+n, s+1.), GetVec(g[k+1]+n, s+2.));\n    float m = smoothstep(w, w*SPLINE_SOFTNESS, d);\n    \n    vec3 col = m*SPLINE_COLOR;\n    float shadow = max(m, smoothstep(w*SHADOW_WIDTH, 0., d));\n    \n    return vec4(col, shadow);\n}\n\nvec4 QuadTruchetTex(vec2 uv) {\n    vec2 gv = fract(uv)-.5;\n\tvec2 id = floor(uv);\n    float n = N21(id);  \n    \n    float t = iTime*CYCLE_VARIATIONS;\n    int k = int(floor(fract(n*3425.12+floor(t*3.))*8.))*8;\n    float s = n*10.;\n    n = floor(n*8.)+floor(t*2.);\n    float w = SPLINE_WIDTH;\n\n    // draw four entry-exit splines\n    vec4 s1 = Spline(gv, w, k, n, s);\n    vec4 s2 = Spline(gv, w, k+2, n, s+2.);\n    vec4 s3 = Spline(gv, w, k+4, n, s+4.);\n    vec4 s4 = Spline(gv, w, k+6, n, s+6.);\n    \n    // composite splines\n    vec4 col = mix(s1, s2, s2.a);\n    col = mix(col, s3, s3.a);\n    col = mix(col, s4, s4.a);\n    \n    if(SHOWGRID && (gv.x>.48||gv.y>.48)) col.r = 1.;\n    \n    return col;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 ro) {\n\tvec3 f = normalize(vec3(0)-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-ro);\n    return rd;\n}\n\n// returns cubemap coordinates\n// xy = uv coords for face of cube, z = cube index (-3,-2,-1, 1, 2, 3)\nvec3 WorldToCube(vec3 p) {\n\tvec3 ap = abs(p);\n    vec3 sp = sign(p);\n    float m = max(ap.x, max(ap.y, ap.z));\n    vec3 st;\n    if(m==ap.x)\n        st = vec3(p.zy, 1.*sp.x);\n    else if(m==ap.y)\n        st = vec3(p.zx, 2.*sp.y);\n    else\n        st = vec3(p.xy, 3.*sp.z);\n    \n    st.xy /= m;\n    \n    //mattz' trick for less distortion in the corners\n    // st.xy = atan(st.xy*tan(0.868734829276))/0.868734829276;\n    \n    // iq version, no trig, short and sweet\n    //st.xy *= 3.0/(2.0+abs(st.xy));\n    //st.xy *= 1.25 - 0.25*st.xy*st.xy;\n    \n    // mattz's no trig version\n    st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy));\n    \n    \n    return st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // set up camera\n    vec3 ro = vec3(0,0.,-2.5);\n    ro.yz *= Rot(-M.y*3.+sin(iTime*.1));\n    vec3 rd = GetRayDir(uv, ro);\n    \n    // marching loop\n    float dO=0., dS;\n    vec3 p;\n    for(float i=0.; i<100.; i++) {\n    \tp = ro + rd * dO;\n        dS = length(p)-1.;\n        dS = min(dS, -(length(p)-4.));\t// background\n        \n        if(dS<.001) break;\n        dO += dS;\n    }\n    \n    vec4 col = vec4(0);\n    \n    // handle material\n    if(dS<.001) {\n        float d = length(p-ro);\n        vec3 n = normalize(p);\n        float fresnel = 1.+dot(rd, n);\n        fresnel *= fresnel;\n        fresnel *= fresnel;\n        \n       \tp.xz *= Rot(iTime*.1);\n        vec3 cc = WorldToCube(p);\n        col = QuadTruchetTex(cc.xy*GRID_SIZE+cc.z*10.);\n       \n        // soften edge of main sphere a bit\n        if(length(p)<1.2) col = mix(col, vec4(.5), fresnel);\n        \n        // darken background\n        col /= max(1., d*.3);\n    }\n    \n    // vignette\n    col *= vec4(1.-dot(uv,uv));\n   \t\n    fragColor = vec4(col);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "@BigWIngs\nYour comment regarding a simple formula for the random entry-exit points got my curiosity up, plus I really like this pattern in general, so I put one together -- but only on a flat plane. I think I came up with a simple enough randomization formula (just a basic array shuffle), but I'll let you decide whether it fits the criteria when I put the example up later today. I went out of my way to append smooth Bezier curves, which give the pattern a nice flow. However, my methodology was a bit hacky, so I'm hoping yourself, or someone else, will come up with something more sciency and robust at a later date. :)",
        "date": "1560311924",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "4t2cWK",
        "hidden": 0
      },
      {
        "text": "@shane, mattz  ahh that makes sense. The idea of interlocking rotating gears made it click. I guess I got screwed up because I was trying it on quad truchet that has '+' tiles as well. I bet that flow is only possible without a '+' tile. ",
        "date": "1560098775",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4tBcWV",
        "hidden": 0
      },
      {
        "text": "I managed to get it Truchet flow working in 3D a while back. It was loosely based on what Shane's calling the \"checkerboard\" solution but there's actually two valid \"checkerboards\" on a 3D cubic lattice. https://www.shadertoy.com/view/MtSyRz",
        "date": "1560045278",
        "username": "mattz",
        "userpicture": "/media/users/mattz/profile.jpeg",
        "id": "Mt2cWy",
        "hidden": 0
      },
      {
        "text": "@BigWings\nIn regard to flow, I've only managed to get it working on the simplest of examples. On square grids, you can achieve flow simply by reversing the flow direction in a checkerboard fashion. Stick to one direction on the white tiles, and reverse it on the black tiles, if that makes any sense. I put together a minimal example a while back, [url=https://www.shadertoy.com/view/XtfyDf]here[/url], that should make it more clear. Hexagonal tiles are even easier, since you don't have to do a thing.\n\nThe question remains as to whether it'd be possible on more sophisticated examples, like hexagonal weaves, or this one? I really couldn't say. Perhaps, but only with premapped random sequences, or something along those lines... I've often wondered whether it'd be possible with a Wang tile approach, but that's for another discussion. :)",
        "date": "1560042333",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "MljcWy",
        "hidden": 0
      },
      {
        "text": "really nice!",
        "date": "1560006592",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "lt2yWG",
        "hidden": 0
      },
      {
        "text": "@Shane Yeah its been on my list of things to do for a while: projecting all platonic solids to a sphere. Making fitted circles would have actually been the easier approach but I wanted to try something different. One thing I still don't understand is how to get consistent flow on truchet lines like you seem to have in some examples. I don't understand how this is even possible without having knowledge of the entire line/loop.",
        "date": "1559924178",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "XtjyDG",
        "hidden": 0
      },
      {
        "text": "Awesome. I love stuff like this.\n\nIf you have any energy left over, you could look into the icsosaheral, dodecahedral, etc, versions, which have more spherical mapping qualities. I put together a polyhedral weave example a while back that was mildly reminiscent of this particular technique, but without the randomness, so doesn't look as interesting as this one. However, with a bit of work, I'd imagine you could produce some pretty cool patterns with triangle or pentagonal mappings.\n\nIn regard to the pattern itself. Just thinking aloud, but I wonder what the pattern would look like taking a fitted circular arc approach. I'm too lazy to try it myself, but I do wonder. :D",
        "date": "1559873871",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "ltScDy",
        "hidden": 0
      },
      {
        "text": "Last one, I promise haha. I think this one is less equalizing, but more isotropic: st.xy *= 1.25 - 0.25*st.xy*st.xy;",
        "date": "1559860813",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "MlSyDy",
        "hidden": 0
      },
      {
        "text": "Thanks boys. Added the no trig version.",
        "date": "1559833629",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "ltScWy",
        "hidden": 0
      },
      {
        "text": "st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy))\n\nhas slightly better distortion properties and also avoids trig",
        "date": "1559829764",
        "username": "mattz",
        "userpicture": "/media/users/mattz/profile.jpeg",
        "id": "MtByWy",
        "hidden": 0
      },
      {
        "text": "You can also use\n\nst.xy *= 3.0/(2.0+abs(st.xy));\n\nan avoid transcendentals/trigonometrics.",
        "date": "1559816117",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "ltSyWy",
        "hidden": 0
      },
      {
        "text": "No problem",
        "date": "1559777565",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "ltScDG",
        "hidden": 0
      },
      {
        "text": "Do you mind if I tweet some screenshots of this with a little bit of technical discussion? I would of course credit you & link the shader.",
        "date": "1559774103",
        "username": "mattz",
        "userpicture": "/media/users/mattz/profile.jpeg",
        "id": "MtByDG",
        "hidden": 0
      },
      {
        "text": "thanks :)",
        "date": "1559771267",
        "username": "mattz",
        "userpicture": "/media/users/mattz/profile.jpeg",
        "id": "ltByDG",
        "hidden": 0
      },
      {
        "text": "The uneveness was bugging the hell out of me and your trick made it completely imperceptible.\nNice shader btw!",
        "date": "1559765941",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "llSyDG",
        "hidden": 0
      },
      {
        "text": "I'm honored you included me in the comment there. BTW this trick was discovered doing this https://www.shadertoy.com/view/MtBGRD and is generally useful for procedurally texturing spheres/skydomes via cubemaps ",
        "date": "1559763551",
        "username": "mattz",
        "userpicture": "/media/users/mattz/profile.jpeg",
        "id": "MtSyDG",
        "hidden": 0
      },
      {
        "text": "@mattz Sweeet! ;) added!",
        "date": "1559761723",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "ltBcWG",
        "hidden": 0
      },
      {
        "text": "Sweeeet! Also if you want to get a little less distortion along the cube edges and near cube corners, try adding the line\n[code]    st.xy = atan(st.xy*tan(0.868734829276))/0.868734829276;[/code]\nbefore [code]return st;[/code]",
        "date": "1559757495",
        "username": "mattz",
        "userpicture": "/media/users/mattz/profile.jpeg",
        "id": "MtScWG",
        "hidden": 0
      },
      {
        "text": "wow, i love it",
        "date": "1559733774",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "4lByDy",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wlSGRd",
      "date": "1560701265",
      "viewed": 125,
      "name": "Procedural terrain with grid",
      "username": "PrzemyslawZaworski",
      "description": " ",
      "likes": 14,
      "published": 1,
      "flags": 0,
      "tags": [
        "grid",
        "terrain",
        "derivatives"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// references:\n// http://madebyevan.com/shaders/grid/\n// Hash without sine: https://www.shadertoy.com/view/4djSRW\n\nconst mat3 rotationMatrix = mat3(1.0,0.0,0.0,0.0,0.7,-0.7,0.0,0.7,0.7);\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 10.21);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise (vec2 P)\n{\n    float size = 256.0;\n    float s = (1.0 / size);\n    vec2 pixel = P * size + 0.5;   \n    vec2 f = fract(pixel);\n    pixel = (floor(pixel) / size) - vec2(s/2.0, s/2.0);\n    float C11 = hash(pixel + vec2( 0.0, 0.0));\n    float C21 = hash(pixel + vec2( s, 0.0));\n    float C12 = hash(pixel + vec2( 0.0, s));\n    float C22 = hash(pixel + vec2( s, s));\n    float x1 = mix(C11, C21, f.x);\n    float x2 = mix(C12, C22, f.x);\n    return mix(x1, x2, f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float a = 0.5, b = 0.0, t = 0.0;\n    for (int i=0; i<5; i++)\n    {\n        b *= a; t *= a;\n        b += noise(p);\n        t += 1.0; p /= 2.0;\n    }\n    return b /= t;\n}\n\nfloat map( vec3 p )\n{ \n    float h = p.y - 20.0 * fbm(p.xz*0.003);\n    return max( min( h, 0.55), p.y-20.0 );\n}\n\nbool raymarch( inout vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i=0; i<128; i++)\n    {\n        float d = map(ro+rd*t);\n        t+=d;\n        if (d<t*0.001)\n        {\n        \tro+=t*rd;\n        \treturn true;\n    \t}\n    }\n    return false;\n}\n\nvec3 shading( vec3 ro, vec3 rd )\n{\n    vec3 c = vec3(rd.y*2.0) * 0.1;\n    vec3 sk = ro;\n    if (raymarch(ro,rd))\n    {\n        vec2 p = ro.xz;\n        vec2 g = abs(fract(p - 0.5) - 0.5) / fwidth(p);\n        float s = min(g.x, g.y);\n        float f = min(length(ro-sk)/64.,1.);\n        return mix(1.5-vec3(s,s,s), c, f);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0.5,25.+sin(iTime)*5.0,iTime * 5.0);\n    vec3 rd = normalize(vec3(uv,2.0)) * rotationMatrix;  \n    fragColor = vec4(shading(ro,rd), 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Nice one",
        "date": "1560874036",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4tjcW3",
        "hidden": 0
      },
      {
        "text": "slick",
        "date": "1560738217",
        "username": "jeyko",
        "userpicture": "/media/users/jeyko/profile.jpeg",
        "id": "4lBcDc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wlSGWy",
      "date": "1560902066",
      "viewed": 906,
      "name": "Raymarching in Raymarching",
      "username": "kaneta",
      "description": "Raymarching in Raymarching",
      "likes": 46,
      "published": 3,
      "flags": 0,
      "tags": [
        "3d",
        "raymarching",
        "raymarch"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 99; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 99; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 30; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 99; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 99; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 24; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        float checker = mod(floor(pos.x) + floor(pos.z), 2.0);\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "@kaneta: there is really no need to apologize. I really like your shader (it is very polished!) and it is fun to see that we came up with such a similar idea :)",
        "date": "1560977851",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "Xl2cDc",
        "hidden": 0
      },
      {
        "text": "Thank you for your comments and advices.\n\n@reinder\nThis was created for the Japanese Shader Study Group.\nI apologize for the unintended resemblance.",
        "date": "1560965966",
        "username": "kaneta",
        "userpicture": "/media/users/kaneta/profile.png",
        "id": "4tjcDc",
        "hidden": 0
      },
      {
        "text": "Wow, thats very well done!",
        "date": "1560956404",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4ljyDc",
        "hidden": 0
      },
      {
        "text": "indeed",
        "date": "1560953567",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "4tjyDc",
        "hidden": 0
      },
      {
        "text": "Very nice! (and a bit similar to [url=https://www.shadertoy.com/view/4dSfRc]4dSfRc[/url] :) )",
        "date": "1560950686",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "XtjyDc",
        "hidden": 0
      },
      {
        "text": "This is really cool, very well done!\n\nOf course, GPUs don't rasterie in scal-lines, but in tiles, so the last animation is technically, but that's okey. Man, add filtering to the checkerboard ([url=https://www.shadertoy.com/view/XlcSz2]XlcSz2[/url]) on the floor, then add 2x supersampling and I think I will use this shader when I go out there gives talks :)",
        "date": "1560942960",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XtjcWc",
        "hidden": 0
      },
      {
        "text": "Thank you for your comments.\n\n@FabriceNeyret2\nThank you for the advice. I added a small ball.",
        "date": "1560932441",
        "username": "kaneta",
        "userpicture": "/media/users/kaneta/profile.png",
        "id": "XljyWc",
        "hidden": 0
      },
      {
        "text": "super well done!",
        "date": "1560931254",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "XtjyWc",
        "hidden": 0
      },
      {
        "text": "so great !\nsuggestion: when the ray scans the scene at the end, you may add a small ball at ray-scene intersection to help making the connection with the projection.",
        "date": "1560930854",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "4l2cD3",
        "hidden": 0
      },
      {
        "text": "Wow so cool",
        "date": "1560913179",
        "username": "Plento",
        "userpicture": "/media/users/Plento/profile.jpeg",
        "id": "4t2cD3",
        "hidden": 0
      },
      {
        "text": "awesome!",
        "date": "1560909972",
        "username": "wyatt",
        "userpicture": "/media/users/wyatt/profile.png",
        "id": "Xt2cD3",
        "hidden": 0
      },
      {
        "text": "muy bien la ilustraccion, tecnicas que desconozco...saludos",
        "date": "1560904527",
        "username": "jorge2017a1",
        "userpicture": "/img/profile.jpg",
        "id": "4tjcD3",
        "hidden": 0
      },
      {
        "text": "Mental!",
        "date": "1560902699",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "XtjcD3",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wljGRd",
      "date": "1560807435",
      "viewed": 110,
      "name": "[twitch] Lost Tree",
      "username": "NuSan",
      "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nOriginal Bonzomatic shader can be found here: http://lezanu.fr/LiveCode/LostTree.glsl",
      "likes": 12,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching",
        "tree",
        "stars"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nOriginal Bonzomatic shader can be found here: http://lezanu.fr/LiveCode/LostTree.glsl\n*/\n\n#define time iTime\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,137,235);\n  vec4 val=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v = mix(fract(sin(val)*5672.655), fract(sin(val+st.x)*5672.655), p.x);\n  vec2 v2 = mix(v.xz,v.yw, p.y);\n  return mix(v2.x,v2.y,p.z);\n}\n\nfloat tri(float t) {\n  return abs(fract(t)-0.5);\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 light=vec3(6,0,0);\n\nfloat at=0.0;\nfloat at2=0.0;\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  p.xz *= sign(p.y);\n  \n  float trunk = step(bp.y,0.0);\n  \n  p.y=-abs(p.y);\n  \n  float t=time*2.0;\n  float rotamount = trunk*0.5+0.5;\n  float rot2 = 0.3 + (1.0-trunk)*0.2;\n  float noi = 1.0 + (1.0-trunk)*2.0;\n  p.xy *= rot(sin(t*0.5) * 0.2 * p.y * rotamount);\n  p.zy *= rot(sin(t*0.6) * 0.25 * p.y * rotamount);\n  \n  p.y += 0.53;\n  \n  \n  p+=(noise(p*6.0)-.5)*0.05 * noi;\n  p+=(noise(p*2.0)-.5)*0.2 * noi;  \n  vec3 bp2=p;\n    \n  float d = 10000.0;\n  for(int i=0; i<7; ++i) {\n    p.xz = abs(p.xz);\n    float sizey = 0.2 - 0.005*float(i) - (1.0-trunk)*0.03;\n    float sizex = 0.53 - 0.07*float(i);\n    d = min(d, max(length(p.xz)-0.1*sizex, abs(p.y-sizey)-sizey));\n    p.xy *= rot(rot2);\n    p.zy *= rot(rot2);\n    p.y += sizey*1.9;    \n  }\n  \n  d = min(d, max(length(p.xz)-0.01, abs(p.y-0.3)-0.3));\n  \n  d += (1.0-trunk)*0.007;\n    \n  float leaf = length(p-vec3(0,0,0.1))-0.2;\n  leaf = max(leaf, 0.3-length(p-vec3(0,0.31,0)));\n  \n  leaf += -0.1+noise(bp2*3.0)/7.0 + (1.0-trunk);\n    \n  d = min(d, leaf);\n  d *= 0.5;\n  \n  float planet = length(bp-vec3(0,3,0))-3.2;\n  float tris = tri(bp.x)*0.2 + tri(bp.z*0.7+.2)*0.3 + tri(bp.z*1.8+.2)*0.1;\n  float pdist = 5.6 + tris;\n  planet = max(planet, pdist-length(bp-vec3(0,6.0,0)));\n  d=min(d, planet);\n  \n  float ast = (length(bp-light) - 1.0);\n  at += 0.2/(0.2+ast);\n  \n  float ast2 = (length(bp+light) - 1.2);\n  at2 += 0.2/(0.2+ast2);\n  \n  d=min(d, ast*0.6);\n  d=min(d, ast2*0.6);\n    \n  return d;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(sin(time*.5)*0.4-0.2);\n  p.xz *= rot(time*0.2);\n  \n}\n\nvec3 sky(vec3 r) {\n  return mix(vec3(0), vec3(0.5,0.6,1.0), pow(clamp(-r.y*0.5+0.7,0.0,1.0),5.0));\n}\n\nfloat getao(vec3 p, vec3 n, float d) {\n  return clamp(map(p+n*d)/d,0.0,1.0)*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0,0,-8);\n  vec3 r=normalize(vec3(-uv, 0.8));\n  \n  cam(s);\n  cam(r);\n  \n  s.y -= 1.0;\n  \n  \n  \n  light.xy *= rot(time);\n  light.yz *= rot(time*.7);\n  \n  vec3 p=s;\n  float i=0.0;\n  bool outside = false;\n  for(i=0.0; i<100.0; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      i += d/0.001;\n      break;\n    }\n    if(d>100.0) {\n      outside = true;\n      break;\n    }\n    p+=r*d;\n  }\n  \n  \n  vec3 col = vec3(0);\n  \n  vec3 lcol = vec3(1.0,0.7,0.2);\n  vec3 lcol2 = vec3(0.3,1.0,0.5);\n  \n  col += pow(at * 0.1,0.6) * 0.8*lcol;\n  col += pow(at2 * 0.1,0.6) * 0.4*lcol2;\n  \n  float fog=1.0-clamp(length(p-s)/100.0,0.0,1.0);\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l = normalize(light-p);\n  \n  float fre = pow(1.0-abs(dot(n,r)), 4.0);\n  \n  float ao = pow(getao(p, n, 1.0) * getao(p, n, 0.5) * pow(getao(p, n, 0.05),3.0), 0.4);\n  \n  // hack: if close to one of the lights, we direct the normal toward the light to get full illumination\n  if(length(light-p)<2.0) n = l;\n  if(length(-light-p)<2.0) n = -l;\n  \n  col += max(0.0, dot(n,l)) * fog * lcol * 40.0 * ao / pow(length(light-p),2.0);\n  col += max(0.0, dot(n,-l)) * fog * lcol2 * 30.0 * ao / pow(length(-light-p),2.0);\n   \n  \n  if(outside) {\n    col += sky(r);\n    vec3 stars = vec3(smoothstep(0.0,1.0,noise(r*53.0)), smoothstep(0.0,1.0,noise(r*33.0)), smoothstep(0.0,1.0,noise(r*127.0)));\n    stars = mix(vec3(1.0), pow(stars, vec3(10.0)), 0.7);\n    col += vec3(6) * smoothstep(0.9,1.0,noise(r*120.0)) * stars;\n  } else {\n    col += sky(reflect(r,n)) * fre * ao;\n    col += sky(n) * fre * ao;\n  }\n    \n  fragColor = vec4(col, 1);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Nice one !",
        "date": "1560956744",
        "username": "XT95",
        "userpicture": "/media/users/XT95/profile.png",
        "id": "Xt2yDc",
        "hidden": 0
      },
      {
        "text": "cool one",
        "date": "1560895760",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "Xt2yD3",
        "hidden": 0
      },
      {
        "text": "wow :D Caan't wait to watch the video :3",
        "date": "1560847533",
        "username": "Flopine",
        "userpicture": "/media/users/Flopine/profile.png",
        "id": "llSyDc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wlsGD7",
      "date": "1560841532",
      "viewed": 69,
      "name": "The big bang theory!",
      "username": "zxxuan1001",
      "description": "The first attempt for ray marching + SDF primitives, and the last episode of The Big Bang Theory : (\n\nSDF functions from: https://www.shadertoy.com/view/Xds3zN\n\n",
      "likes": 3,
      "published": 1,
      "flags": 32,
      "tags": [
        "raymarching",
        "sdf",
        "primitives"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 tex = texture(iChannel0, fragCoord.xy/iResolution.xy);\n  fragColor = vec4 (tex);\n}\n\n\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4sfGzn",
            "filepath": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png",
            "previewfilepath": "/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png",
            "type": "cubemap",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "clamp",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "const float EPSILON = 0.0001;\nconst float PI = 3.1415926;\nconst float MAX_DIST = 100.0;\nconst int MAX_STEPS = 60;\nconst vec3 LIGHTBLUE = vec3(154.0, 247.0, 247.0)/255.0;\nconst vec3 GREEN = vec3(125.0, 245.0, 217.0)/255.0;\nconst vec3 YELLOW = vec3(0.2, 0.2, 0.0);\nconst vec3 PINK = vec3(255.0, 94.0, 186.0)/255.0;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shiness;\n};\n\n#define BLINN 1\n#define AA 0\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nvec2 intersectSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x > dist1.x? dist0 : dist1;\n}\n\nvec2 unionSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x < dist1.x? dist0 : dist1;\n}\n\nvec2 diffSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x > -dist1.x? dist0 : vec2(-dist1.x, dist1.y);\n}\n\nvec3 rotX(vec3 p, float d) {\n    mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, cos(d), -sin(d), 0.0, \n                    0.0, sin(d), cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\nvec3 rotY(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), 0.0, sin(d), 0.0, \n                    0.0, 1.0, 0.0, 0.0,\n                    -sin(d), 0.0, cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 rotZ(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), -sin(d), 0.0, 0.0, \n                    sin(d), cos(d), 0.0, 0.0, \n                    0.0, 0.0, 1.0, 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 doTranslate(vec3 p, vec3 t) {\n    return p - t;\n}\n\nvec2 sceneSDF(vec3 p) {\n    float deg = 90.0;\n    float sr = 2.0;\n    float lr = 2.0;\n    float SR = 1.8;\n    float LR = 1.5;\n    float spheres[12];\n    float vTime = iTime;\n    \n    float id = 1.0;\n    for (int i = 0; i < 4; i ++) {\n        float dx = SR * cos(90.0 * id * PI / 180.0);\n        float dz = SR * sin(90.0 * id * PI / 180.0);\n        vec3 v = vec3(p.x + dx, p.y, p.z + dz);\n        spheres[i] = sphereSDF(v, sr);\n        id += 1.0;\n    }\n    spheres[4] = sphereSDF(vec3(p.x, p.y + LR, p.z), lr);\n    spheres[5] = sphereSDF(vec3(p.x, p.y - LR, p.z), lr);\n    \n    \n    \n    float torus[3];\n    float t_ry = 0.1;\n    float t_rxl = 16.0;\n    float t_rxs = 12.0;\n    float alpha0 = vTime;\n    float alpha1 = vTime + 90.0 * PI / 180.0;\n    torus[0] = sdTorus( rotX(p, alpha0), vec2(t_rxl, t_ry) );\n    torus[1] = sdTorus( rotZ(p, alpha0), vec2(t_rxs, t_ry) );\n    torus[2] = sdTorus( rotZ(p, alpha1), vec2(t_rxs, t_ry) );\n    \n    float ssr = 0.3;\n    spheres[6] = sphereSDF(vec3(p.x, p.y - t_rxl * sin(alpha0), p.z + t_rxl * cos(alpha0)), ssr);\n    spheres[7] = sphereSDF(vec3(p.x, p.y + t_rxl * sin(alpha0), p.z - t_rxl * cos(alpha0)), ssr);\n    spheres[8] = sphereSDF(vec3(p.x - t_rxl, p.y, p.z), ssr);\n    spheres[9] = sphereSDF(vec3(p.x + t_rxl, p.y, p.z), ssr);\n    \n    spheres[10] = sphereSDF(vec3(p.x - t_rxs * cos(alpha0), p.y - t_rxs* sin(alpha0), p.z), ssr);\n    spheres[11] = sphereSDF(vec3(p.x - t_rxs * cos(alpha1), p.y - t_rxs* sin(alpha1), p.z), ssr);\n    \n    float objId = 0.0;\n    //horizontal spheres\n    vec2 combined = unionSDF(vec2(spheres[0], objId), vec2(spheres[1], objId));\n    combined = unionSDF(combined, vec2(spheres[2], objId));\n    combined = unionSDF(combined, vec2(spheres[3], objId));\n    \n    //lower sphere\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[4], objId));\n    \n    //upper sphere\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[5], objId));\n    \n    //small spheres\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[6], objId));\n    combined = unionSDF(combined, vec2(spheres[7], objId));\n    combined = unionSDF(combined, vec2(spheres[8], objId));\n    combined = unionSDF(combined, vec2(spheres[9], objId));\n    combined = unionSDF(combined, vec2(spheres[10], objId));\n    combined = unionSDF(combined, vec2(spheres[11], objId));\n    \n    //large tortus\n    objId++;\n    combined = unionSDF(combined, vec2(torus[0], objId));\n    \n    //small tortus\n    objId++;\n    combined = unionSDF(combined, vec2(torus[1], objId));\n    combined = unionSDF(combined, vec2(torus[2], objId));\n    \n  \n    \n   return combined;\n}\n\nvec2 rayMarching(vec3 ro, vec3 rd) {\n    float tmax = MAX_DIST;\n    float t = 0.0;\n    vec2 result = vec2(-1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 res = sceneSDF(p);\n        if (res.x < EPSILON)\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.y = -1.0;\n            result.x = -1.0;\n            return result;\n        }\n        t += res.x;\n        result.x = t;\n        result.y = res.y;\n    }\n    \n    //return result;\n}\n\nconst vec3 AMBIENT_COLOR = vec3(0.1);\nconst vec3 DIFFUSE_COLOR = vec3(0.6);\nconst vec3 SPEC_COLOR = vec3(0.5);\nconst vec3 LIGHT_COLOR = vec3(1.0, 1.0, 0.0);\n\nvec3 shading(vec3 normal, vec3 viewDir, vec3 lightDir, Material mat) {\n    \n    vec3 ambCol = AMBIENT_COLOR * mat.ambient;\n    vec3 V = normalize(viewDir);\n    vec3 L = normalize(lightDir);\n    vec3 N = normalize(normal);\n    float diff = max(dot(N, L), 0.0);\n    vec3 diffCol = DIFFUSE_COLOR * diff * mat.diffuse;\n    \n    vec3 R = normalize(reflect(-L, N));  \n    vec3 VR = normalize(reflect(-V, N)); \n    \n#if BLINN == 1\n    vec3 H = normalize(L + V);\n    float spec = pow(max(dot(N, H), 0.0), mat.shiness);\n#else    \n      \n    float spec = pow(max(dot(V, R), 0.0), mat.shiness);\n#endif   \n    \n    vec3 speCol = SPEC_COLOR * spec * mat.specular;\n    \n    vec3 refl = texture(iChannel0, VR, -100.0).rgb;\n    \n    return refl * mat.diffuse + speCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getNormals(vec3 p) {\n    float x = sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x;\n    float y = sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x;\n    float z = sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x;\n    return normalize(vec3(x, y, z));\n}\n\nvec3 background(vec2 p) {\n    return mix(YELLOW, GREEN, p.y + 0.5);\n}\n\nvec3 render(in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  uv -= 0.5;\n    \n  uv.x *= iResolution.x/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy - 0.5;\n  \n  vec3 ro = vec3 (cos(iTime) * 10.0 + 10.0, 3.0, sin(iTime) * 10.0 + 20.0);\n  //vec3 ro = vec3 (0.0, 5.0, 25.0);\n  vec3 ta = vec3 (0.0, 0.0, -1.0);\n  mat3 cam = getCamera(ro, ta, 0.0);\n  \n  vec3 rd = normalize(cam * vec3(uv, 1.0));\n  vec2 h = rayMarching(ro, rd);\n \n  vec3 col = vec3(0.0);\n  \n  if (h.x > -1.0) {\n    \n    vec3 p = ro + rd * h.x;\n    vec3 nor = getNormals(p);\n    vec3 lightPos = vec3(20.0 * sin(iTime), 10.0, -20.0);\n    vec3 lightDir = lightPos - p;\n    vec3 viewDir = ro - p;\n        \n    Material mat;\n    //chrome\n    mat.ambient = vec3(0.25);\n    mat.diffuse = vec3(0.5);\n    mat.specular = vec3(0.674597);\n    mat.shiness = 1.2;\n    \n    \n    if (h.y == 1.0 || h.y == 2.0) {\n      //pink\n      mat.ambient = PINK;\n      mat.diffuse = PINK;\n      mat.specular = PINK;\n    } else if (h.y == 0.0) {\n      //gold\n      mat.ambient = vec3(0.24725, 0.1995, 0.0745);\n      mat.diffuse = vec3(0.75164, 0.60648, 0.12648);\n      mat.specular = vec3(0.628281, 0.555802, 0.366065);\n      mat.shiness = 1.2;\n    } \n    col += shading(nor, viewDir, lightDir, mat) ;\n  \n    \n  } else {\n      col = background(uv);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n#if AA==1\n    const float AA_size = 2.0;\n    float count = 0.0;\n    for (float aaY = 0.0; aaY < AA_size; aaY++)\n    {\n        for (float aaX = 0.0; aaX < AA_size; aaX++)\n        {\n            col += render(fragCoord + vec2(aaX, aaY) / AA_size);\n            count += 1.0;\n        }\n    }\n    col /= count;\n#else\n    col += render(fragCoord);\n#endif\n    \n    col = pow( col, vec3(1.0/2.2) );\n    \n    \n    vec2 p = fragCoord/iResolution.xy ;\n    col *= 0.2 + 0.8 * pow(32.0 * p.x * p.y * (1.0 - p.x) * (1.0 - p.y), 0.2);\n    \n    fragColor = vec4 (col, 1.);\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wsSXzz",
      "date": "1552678123",
      "viewed": 4392,
      "name": "SF Shadertoy party invite",
      "username": "otaviogood",
      "description": "You're invited to a Shadertoy party! San Francisco, March 19th 2019, 18:30, Figma headquarters, 116 New Montgomery St, 9th floor. Check the meetup site for details/RSVP. meetup.com/San-Francisco-shadertoy",
      "likes": 65,
      "published": 3,
      "flags": 0,
      "tags": [
        "meetup",
        "sanfrancisco",
        "shadertoyparty"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "XsfGzn",
            "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
            "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
            "type": "cubemap",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "clamp",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "Xsf3zn",
            "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4dXGzr",
            "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
            "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
            "type": "texture",
            "channel": 2,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// THIS NEEDS A WEBGL 2.0 CAPABLE BROWSER OR IT WILL NOT WORK.\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\n#ifdef NON_REALTIME_HQ_RENDER\nfloat seed = 1.0;\n#endif\n\n// Animation variables\nvec3 sunDir;\nint currentText;\n\n// Animation key frames\nconst int numKeyFrames = 8;\nconst float keys[numKeyFrames] = float[numKeyFrames]\n    (0.0, 14.0, 16.0, 24.0, 32.0, 40.0, 50.0, 59.0);\n\n// Deterministic hash that should work the same on all video cards. Just something I made up.\n// Should return a number [0..1)\nfloat JankyHash(uint seed) {\n    seed ^= ((seed ^ uint(1000000207)) * uint(1000000007)) >> 7;\n    seed = (seed ^ uint(1000000409)) * uint(1000000531);\n    return float(seed & uint(0xffff)) / (65536.0);\n}\n\nvec2 JankyHash2(uint seed) {\n    seed ^= ((seed ^ uint(1000000207)) * uint(1000000007)) >> 7;\n    seed = (seed ^ uint(1000000409)) * uint(1000000531);\n    return vec2(seed & uint(0xffff), seed >> 16) / (65536.0);\n}\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nvec2 NoiseTex(in vec3 x) {\n    vec3 fr = fract(x);\n    vec3 fl = floor(x);\n\tfr.xy = fr.xy * fr.xy * (3.0 - 2.0 * fr.xy);\n\tvec2 uva = (fl.xy + vec2(37.0, 17.0)*fl.z) + fr.xy;\n\tvec2 uvb = (fl.xy + vec2(37.0, 17.0)*fl.z + vec2(37.0, 17.0)) + fr.xy;\n\tvec2 a = textureLod( iChannel1, (uva + 0.5) / 256.0, 0.0).yx;\n\tvec2 b = textureLod( iChannel1, (uvb + 0.5) / 256.0, 0.0).yx;\n    return mix(a, b, fr.z) - 0.5;\n}\n\nconst float PI=3.14159265;\n\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Noise generator from https://otaviogood.github.io/noisegen/\n// Params: 2D, Seed 10, Waves 8, Octaves 5, Smooth 1\nfloat NoiseGen(vec2 p) {\n    // This is a bit faster if we use 2 accumulators instead of 1.\n    // Timed on Linux/Chrome/TitanX Pascal\n    float wave0 = 0.0;\n    float wave1 = 0.0;\n    wave0 += sin(dot(p, vec2(0.600, -2.119))) * 0.2939877018;\n    wave1 += sin(dot(p, vec2(0.972, 2.283))) * 0.2387554666;\n    wave0 += sin(dot(p, vec2(3.511, 0.119))) * 0.1406977328;\n    wave1 += sin(dot(p, vec2(0.494, -5.303))) * 0.0817366769;\n    wave0 += sin(dot(p, vec2(8.383, -1.242))) * 0.0473036532;\n    wave1 += sin(dot(p, vec2(3.356, -7.905))) * 0.0465956513;\n    wave0 += sin(dot(p, vec2(-7.794, 10.606))) * 0.0290698451;\n    wave1 += sin(dot(p, vec2(15.407, -2.728))) * 0.0241393549;\n    return wave0+wave1;\n}\n\n// Returns gradient of the noise function at position p.\nvec2 NoiseGenGrad(vec2 p) {\n    vec2 dWave0 = vec2(0.0);\n    vec2 dWave1 = vec2(0.0);\n    vec2 dir = vec2(0.0);\n    dir = vec2(0.600, -2.119);    dWave0 += dir * cos(dot(p, dir)) * 0.2939877018;\n    dir = vec2(0.972, 2.283);    dWave1 += dir * cos(dot(p, dir)) * 0.2387554666;\n    dir = vec2(3.511, 0.119);    dWave0 += dir * cos(dot(p, dir)) * 0.1406977328;\n    dir = vec2(0.494, -5.303);    dWave1 += dir * cos(dot(p, dir)) * 0.0817366769;\n    dir = vec2(8.383, -1.242);    dWave0 += dir * cos(dot(p, dir)) * 0.0473036532;\n    dir = vec2(3.356, -7.905);    dWave1 += dir * cos(dot(p, dir)) * 0.0465956513;\n    dir = vec2(-7.794, 10.606);    dWave0 += dir * cos(dot(p, dir)) * 0.0290698451;\n    dir = vec2(15.407, -2.728);    dWave1 += dir * cos(dot(p, dir)) * 0.0241393549;\n    return dWave0+dWave1;\n}\n\nvec3 RotateY(vec3 v, float rad)\n{\n  float c = cos(rad);\n  float s = sin(rad);\n  return vec3(c * v.x - s * v.z, v.y, s * v.x + c * v.z);\n}\n\nvec2 Rotate(vec2 v, float rad)\n{\n  float c = cos(rad);\n  float s = sin(rad);\n  return vec2(c * v.x - s * v.y, s * v.x + c * v.y);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir, vec3 sunCol)\n{\n\tvec3 localRay = rayDir;\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*150.0)*7000.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.002;\n}\n\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir,\n               vec3 sunCol, vec3 groundCol, vec3 horizonCol, vec3 skyCol)\n{\n    // fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.25))*0.95;\n    // make clouds - just a horizontal plane with noise\n    //float n = noise2d(rayDir.xz/rayDir.y*1.0);\n    //n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\n    //n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\n    //n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\n    float n = NoiseGen(rayDir.xz/rayDir.y)*2.0+0.6;\n    vec2 ng = NoiseGenGrad(rayDir.xz/rayDir.y);\n    n = pow(abs(n), 3.0);\n    n = n * saturate(abs(rayDir.y * 4.0));  // fade clouds in distance\n\tfloat dist = 1.0 - (dot(rayDir, sunDir) * 0.5 + 0.5);\n    float cloudShadow = -dot(ng, sunDir.xz)*0.5+0.5;\n    vec3 cloudCol = (vec3(0.5,0.3,0.1)/dist+sunCol*cloudShadow)*saturate((rayDir.y+0.2)*5.0);\n    finalColor = mix(finalColor, cloudCol, saturate(n*0.0625));\n\n    // Background mountains\n    float n2 = NoiseGen(rayDir.xz*16.0)*0.75;\n    n2 += 1.5 - saturate(-rayDir.x)*3.0;\n    vec3 mountainCol = (horizonCol * 0.75 + skyCol * 0.25) * 0.55 - rayDir.y*3.0;\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.025-rayDir.y)*512.0));\n\n    // Foreground mountains\n    n2 = NoiseGen(-rayDir.xz*16.0)*1.0;\n    n2 += 1.8 - saturate(-rayDir.x)*3.0;;\n    mountainCol = (horizonCol * 0.8 + skyCol * 0.2) * 0.40 + vec3(0.035, 0.0, 0.0);\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.0125-rayDir.y)*512.0));\n\n    // Foreground mountains\n    n2 = NoiseGen(-rayDir.zx*16.0)*1.0;\n    n2 += 0.6 - saturate(-rayDir.x)*3.0;;\n    mountainCol = (horizonCol * 0.5 + groundCol * 0.5) * 0.45 + vec3(0.0, 0.025, 0.0);\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.0125-rayDir.y)*512.0));\n\n    // Ground color fade\n    finalColor = mix(finalColor, (groundCol + horizonCol)*0.4, saturate(-rayDir.y*16.0));\n    finalColor = mix(finalColor, groundCol*0.4, saturate(-5.0-rayDir.y*8.0));\n\n    // add the sun\n    finalColor += GetSunColorSmall(rayDir, sunDir, sunCol);\n    return finalColor;\n}\n\nvec3 GetEnvMapSimple(vec3 rayDir, vec3 sunDir, vec3 sunCol, vec3 horizonCol, vec3 skyCol)\n{\n    // fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.25))*0.95;\n    // make clouds - just a horizontal plane with noise\n    float n = NoiseGen(rayDir.xz/rayDir.y)*2.0+0.6;\n    n = pow(abs(n), 3.0);\n    n = n * saturate(abs(rayDir.y * 4.0));  // fade clouds in distance\n\tfloat dist = 1.0 - (dot(rayDir, sunDir) * 0.5 + 0.5);\n    vec3 cloudCol = (vec3(0.5,0.3,0.1)/dist+sunCol)*saturate((rayDir.y+0.2)*5.0);\n    finalColor = mix(finalColor, cloudCol, saturate(n*0.0625));\n\n    // Background mountains\n    float n2 = NoiseGen(rayDir.xz*16.0)*0.75;\n    n2 += 1.5 - saturate(-rayDir.x)*3.0;\n    vec3 mountainCol = (horizonCol * 0.75 + skyCol * 0.25) * 0.55 - rayDir.y*3.0;\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.025-rayDir.y)*512.0));\n\n    // Ground color fade\n    //finalColor = mix(finalColor, (groundCol + horizonCol)*0.4, saturate(-rayDir.y*16.0));\n    //finalColor = mix(finalColor, groundCol*0.4, saturate(-5.0-rayDir.y*8.0));\n\n    // add the sun\n    finalColor += GetSunColorSmall(rayDir, sunDir, sunCol);\n    return finalColor;\n}\n\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height,\n                      vec3 sunCol, vec3 horizonCol, vec3 skyCol)\n{\n    vec3 finalColor = GetEnvMapSimple(rayDir, sunDir, sunCol, horizonCol, skyCol);\n\n    // Make a skyscraper skyline reflection.\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\n    radial *= 4.0;\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\n\n\treturn finalColor;\n}\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n\n// -------- Ray intersection functions and data structures --------\nconst float farPlane = 1024.0;\n\nvec4 Union(vec4 a, vec4 b)\n{\n    if (a.w < b.w) return a;\n    else return b;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// Return value is normal in xyz, t in w.\n// outside is 1 to intersect from the outside of the sphere, -1 to intersect from inside of sphere.\nvec4 SphereIntersect3(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, int outside)\n{\n    vec4 rh = vec4(farPlane);\n    vec3 delta = spherePos - pos;\n    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);\n    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;\n    vec3 bv = proj - delta;\n    float b2 = dot(bv, bv);\n    if (b2 > rad*rad) return rh;  // Ray missed the sphere\n    float x = sqrt(rad*rad - b2);\n    rh.w = projdist - (x * float(outside));\n    vec3 hitPos = pos + dirVecPLZNormalizeMeFirst * rh.w;\n    rh.xyz = normalize(hitPos - spherePos);  // Normal still points outwards if collision from inside.\n    return rh;\n}\n\n// Return value is normal in xyz, t in w.\nvec4 PlaneIntersect(vec3 camPos, vec3 dirVecPLZNormalizeMeFirst, vec3 planeNormal, vec3 pointOnPlane) {\n    vec4 rh = vec4(farPlane);\n    float denom = dot(planeNormal, dirVecPLZNormalizeMeFirst);\n    if (denom != 0.0) {\n        vec3 p0l0 = pointOnPlane - camPos;\n        rh.w = dot(p0l0, planeNormal) / denom;\n        //rh.hit = camPos + dirVecPLZNormalizeMeFirst * rh.t;\n        rh.xyz = planeNormal * sign(-denom);\n    }\n    if (rh.w <= 0.0) rh.w = farPlane;\n    return rh;\n}\n\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\n// Return value is normal in xyz, t in w.\n// rayInv is 1.0 / direction vector\nvec4 BoxIntersect(vec3 pos, vec3 rayInv, vec3 boxPos, vec3 rad)\n{\n    vec3 bmin = boxPos - rad;\n    vec3 bmax = boxPos + rad;\n//    vec3 rayInv = 1.0 / dirVecPLZNormalizeMeFirst;\n\n    vec3 t1 = (bmin - pos) * rayInv;\n    vec3 t2 = (bmax - pos) * rayInv;\n\n    vec3 vmin = min(t1, t2);\n    vec3 vmax = max(t1, t2);\n\n    float tmin = max(vmin.z, max(vmin.x, vmin.y));\n    float tmax = min(vmax.z, min(vmax.x, vmax.y));\n\n    vec4 rh = vec4(0,1,0,farPlane);\n    if ((tmax <= tmin)) return rh;\n    if ((tmin <= 0.0)) return rh;\n    rh.w = tmin;\n    // optimize me!\n    if (t1.x == tmin) rh.xyz = vec3(-1.0, 0.0, 0.0);\n    if (t2.x == tmin) rh.xyz = vec3(1.0, 0.0, 0.0);\n    if (t1.y == tmin) rh.xyz = vec3(0.0, -1.0, 0.0);\n    if (t2.y == tmin) rh.xyz = vec3(0.0, 1.0, 0.0);\n    if (t1.z == tmin) rh.xyz = vec3(0.0, 0.0, -1.0);\n    if (t2.z == tmin) rh.xyz = vec3(0.0, 0.0, 1.0);\n    return rh;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// capped cylinder distance field\nfloat cylCap(vec3 p, float r, float lenRad)\n{\n    float a = length(p.xy) - r;\n    a = max(a, abs(p.z) - lenRad);\n    return a;\n}\n\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\nfloat Repeat(float a, float len)\n{\n    return mod(a, len) - 0.5 * len;\n}\n\n// Font rendering macros (ASCII codes)\n#define _SPACE 32\n#define _EXCLAMATION 33\n#define _COMMA 44\n#define _DASH 45\n#define _PERIOD 46\n#define _SLASH 47\n#define _COLON 58\n#define _AT 64\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\n// San Francisco\n// Shadertoy party\n// March 19 2019 18:30\n// @ Figma\n// 116 New Montgomery, 9th floor\n// meetup.com/San-Francisco-shadertoy\n\nconst int numLetters = 118;\nconst int wordStarts[6] = int[6] (0, 14, 31, 44, 62, 94);  // This is weird. Oh well. Bugs.\nconst int wordLens[6] = int[6] (13, 15, 19, 7, 28, 35);\nconst float wordScales[6] = float[6] (2.0, 0.35, 0.5, 0.087, 0.044, 1.0);\nconst vec3 currentTextPos[6] = vec3[6] (\n    vec3(-12.0,6.0,29.0),\n    vec3(-1.35,0.11,16.5),\n    vec3(-2.0,3.5,2.2),\n    vec3(16.795, 0.88, 2.5),\n    vec3(10.83, 0.02, 0.948),\n    vec3(-19.5,8.0,33.2));\nconst int letterArray[numLetters] = int[numLetters]\n    (_S,_a,_n,_SPACE,_F,_r,_a,_n,_c,_i,_s,_c,_o,  // 13\n     _S,_H,_A,_D,_E,_R,_T,_O,_Y,_SPACE,_P,_A,_R,_T,_Y,  // 15\n    _M,_a,_r,_c,_h,_SPACE,_1,_9,_SPACE,_2,_0,_1,_9,_SPACE,_1,_8,_COLON,_3,_0,  // 19\n    _AT,_SPACE,_F,_I,_G,_M,_A,  // 7\n    _1,_1,_6,_SPACE,_N,_e,_w,_SPACE,_M,_o,_n,_t,_g,_o,_m,_e,_r,_y,_COMMA,_9,_t,_h,_SPACE,_f,_l,_o,_o,_r, _SPACE,  // 29\n    _m,_e,_e,_t,_u,_p,_PERIOD,_c,_o,_m,_SLASH,_S,_a,_n,_DASH,_F,_r,_a,_n,_c,_i,_s,_c,_o,_DASH,_s,_h,_a,_d,_e,_r,_t,_o,_y, _SPACE);  // 35\n\nvec4 SampleFontTex(vec2 uv)\n{\n    float fl = floor(uv + 0.5).x;\n    float cursorPos = fl;\n    int letter = 0;\n\n    letter = letterArray[int(cursorPos - 0.0)];\n    vec2 lp = vec2(letter % 16, 15 - letter/16);\n    vec2 uvl = lp + fract(uv+0.5)-0.5;\n\n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    return texture(iChannel2, (uvl+0.5)*(1.0/16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\n// Distance function that defines the car.\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\nvec2 Car(vec3 baseCenter, float unique)\n{\n    // bottom box\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.002), vec3(0.009, 0.00225, 0.0275)) - 0.0015;\n    // top box smooth blended\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.0075), vec3(0.004, 0.0005, 0.007)), -160.0);\n    // mirror the z axis to duplicate the cylinders for wheels\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.002);\n    wMirror.z = abs(wMirror.z)-0.02;\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\n    // Set materials\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\n    // Car material is some big number that's unique to each car\n    // so I can have each car be a different color\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\n    return distAndMat;\n}\n\nconst float parkHeight = 0.1;\nfloat Hills(vec3 p) {\n    vec2 tempP = p.xz;\n    tempP.y = abs(tempP.y - 29.6) - 29.6;\n    float pxz2 = dot(tempP.xy, tempP.xy);\n    float noise = NoiseGen(-p.zx*0.125)*0.2;\n    float height = p.y;\n    height -= 2.0f / exp(pxz2*0.008);\n    return height + 0.13 + noise ;\n}\n\n// How much space between voxel borders and geometry for voxel ray march optimization\nconst float voxelPad = 0.2;\n// p should be in [0..1] range on xz plane\n// pint is an integer pair saying which city block you are on\nvec2 CityBlock(vec3 p, vec2 pint)\n{\n    // Get random numbers for this block by hashing the city block variable\n    vec4 rand;\n    //rand.xy = Hash22(pint);\n    //rand.zw = Hash22(rand.xy);\n    //vec2 rand2 = Hash22(rand.zw);\n    rand.xy = JankyHash2(uint(pint.x + pint.y * 103.0 + 10009.0));\n    rand.zw = JankyHash2(uint(pint.x + pint.y * 103.0 + 10007.0 + rand.x*211.0));\n    vec2 rand2 = JankyHash2(uint(pint.x + pint.y * 103.0 + 10007.0 + rand.y*211.0));\n\n    // Radius of the building\n    float baseRad = 0.2 + (rand.x) * 0.1;\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\n\n    // make position relative to the middle of the block\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\n    float height = rand.w*rand.z + 0.1; // height of first building block\n    // Make the city skyline higher in the middle of the city.\n    float downtown = saturate(4.0 / length(pint.xy));\n    height *= downtown;\n    height *= 0.5+(baseRad-0.15)*20.0;\n    height += 0.1;\t// minimum building height\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\n\n    // road\n    d = min(d, p.y);\n\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\n\n    // height of second building section\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\n    height2 = floor(height2*20.0)*0.05;\t// floor units\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\n    // size pieces of building\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\n    // second building section\n    if (rand2.y > 0.25)\n    {\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\n        // subtract off piece from top so it looks like there's a wall around the roof.\n        float topWidth = baseRad;\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\n    }\n    else\n    {\n        // Cylinder top section of building\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\n    }\n    // mini elevator shaft boxes on top of building\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\n    float big = sign(boxPos.x);\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\n\td = min(d, sdBox(boxPos,\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\n\n    // Put domes on some building tops for variety\n    if (rand.y < 0.04)\n    {\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\n    }\n\n    // Transamerica pyramid special-case building.\n    if ((pint.x == 0.0) && (pint.y == 1.0)) {\n        vec3 slice = abs(baseCenter) - 0.25;\n    \td = max(max(slice.x + slice.y * 0.1, slice.z + slice.y * 0.1), baseCenter.y - 2.55);\n        d = min(d, sdBox(baseCenter - vec3(0.0, 1.2, 0.0), vec3(0.05, 0.9, 0.17)));\n\n    } //else\n    //d = max(d, p.y);  // flatten the city for debugging cars\n\n    // Need to make a material variable.\n    vec2 distAndMat = vec2(d, 0.0);\n    // sidewalk box with material\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\n\n    return distAndMat;\n}\n\n// landmark ideas\n// gg bridge\n// lombard\n// pier 39\n// transamerica\n// salesforce tower?\n// alcatraz\n// coit tower\n// figma office\n\nvec2 Render3dText(vec3 p, vec3 textOrigin, float angle, int start, int len, float scale) {\n\t// Load the font texture's distance field.\n    vec3 p2 = p - textOrigin;\n    vec3 pr = RotateY(p2.xyz, angle)/scale + vec3(6+start, 0.0, 0.0);\n    float letterDistField = ((SampleFontTex(pr.xy).w - 0.5) + 1.0 / 256.0)*wordScales[currentText];\n    vec3 boxDim = abs(RotateY(vec3(float(len) * 0.5, 0.5, 0.1025), angle)) * scale;\n    float cropBox = sdBox(p + vec3(0.0, 0.0, 0.0) - textOrigin, boxDim);\n    return vec2(max(cropBox, letterDistField), 5.0);\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nvec2 DistanceToObject(vec3 p)\n{\n    vec3 origp = p;\n    p.y = Hills(p);\n    vec3 rep = p;\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\n    vec2 pint = floor(p.xz);\n    vec2 distAndMat = CityBlock(rep, pint);\n\n    float blockHill = Hills(vec3(pint.x, 0, pint.y));\n    if ((blockHill > -parkHeight) || (pint.y > 15.0)) distAndMat = matmax(distAndMat, vec2(p.y, 4.0));\n\n    // Make an extra hill (mirrored) at the 2 ends of the Golden Gate Bridge\n    vec3 hillPos = p + vec3(6.0, 3.65, -20.0);\n    hillPos.z = abs(hillPos.z-12.8)-12.8;\n    //float d = length(hillPos * vec3(2.0, 1.0, 1.0)) / vec3(2.0,1.0,1.0) - 4.0;\n    vec3 r = vec3(8.0, 4.0, 1.0);\n    // Ellipse distance field\n    float k0 = length(hillPos/r);\n    float k1 = length(hillPos/(r*r));\n    float d = k0*(k0-1.0)/k1;\n\n    // Add noise and smooth blend it into the landscape.\n    float noiseTemp = NoiseGen(hillPos.xz*2.0)*0.25;\n    noiseTemp += NoiseGen(hillPos.xz*16.0)*0.0625*0.25;\n    distAndMat.x = smin(distAndMat.x, d + noiseTemp, -2.2);\n\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\n    // only want to do a single call to the car distance function for all the\n    // cars in the scene. And there's a lot of traffic!\n    vec3 p2 = p;\n    rep.xyz = p2;\n    float carTime = localTime*0.2;  // Speed of car driving\n    float crossStreet = 1.0;  // whether we are north/south or east/west\n    float repeatDist = 0.25;  // Car density bumper to bumper\n    // If we are going north/south instead of east/west (?) make cars that are\n    // stopped in the street so we don't have collisions.\n    if (abs(fract(rep.x)-0.5) < 0.35)\n    {\n        p2.x += 0.05;\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\n        rep.xz = p2.xz;\n        crossStreet = 0.0;\n        repeatDist = 0.1;  // Denser traffic on cross streets\n    }\n\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\n    rep.x = (rep.x*sign(rep.x))-0.09;\n    rep.z -= carTime * crossStreet;\t// make cars move\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\n    frontBack *= sin(localTime*2.0 + uniqueID);\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\n    float isBridge = 0.0;\n    if ((p.x > -7.15) && (p.x < -6.85)){\n        isBridge = 0.7;\n        rep.y = origp.y;\n    }\n    vec2 carDist = Car(rep-vec3(0.0, isBridge, 0.0), uniqueID); // car distance function\n\n    // Drop the cars in the scene with materials\n    if ((blockHill < -parkHeight) && (pint.y < 15.0) || (isBridge > 0.0)) distAndMat = matmin(distAndMat, carDist);\n\n    // ******************** Render the text ********************\n    int startIndex = wordStarts[currentText];\n    int len = wordLens[currentText];\n    vec3 tp = currentTextPos[currentText];\n    float rot = PI;\n    if ((currentText >= 2)) rot = -PI * 0.5;\n    distAndMat = matmin(distAndMat, Render3dText(p, tp, rot,\n        startIndex, len, wordScales[currentText]));\n\n    return distAndMat;\n}\n\n// This basically makes a procedural texture map for the sides of the buildings.\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\n{\n    bool pyramid =((block.x == 0.0) && (block.y == 1.0));\n\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\n    if (pyramid) hue = vec3(2.5, 1.6, 1.0)*0.8;\n    texColor += hue*0.4;\n    texColor *= 0.75;\n    float window = 0.0;\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\n    if (pos.y < 0.05) window = 1.0;\n    float winWidth = Hash21(block*4.321)*2.0;\n    if (pyramid) winWidth = 1.0;\n    if ((winWidth < 1.2) && (winWidth >= 1.0)) winWidth = 1.2;\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\n    if (window < 0.5)\n    {\n        windowRef += 1.0;\n    }\n    if (!pyramid) window *= Hash21(block*1.123);\n    texColor *= window;\n\n    if (!pyramid) {\n        float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\n        normal.y -= max(-1.0, min(1.0, -wave*0.5));\n        float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\n        normal.z += pits*0.25;\n        pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\n        normal.x += pits*0.25;\n    }\n}\n\nvec4 RayTraceBridgeTower(vec3 pos, vec3 dirVecN) {\n    vec3 rayInv = 1.0 / dirVecN;\n    vec4 rh = BoxIntersect(pos, rayInv, vec3(0.0, 1.135, 0.0), vec3(0.03, 2.27, 0.08)*0.5);\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 1.135, 0.0), vec3(0.03, 2.27, 0.08)*0.5));\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.6, 0.0), vec3(0.08, 1.2, 0.14)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.6, 0.0), vec3(0.08, 1.2, 0.14)*0.5));\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.775, 0.0), vec3(0.06, 1.55, 0.12)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.775, 0.0), vec3(0.06, 1.55, 0.12)*0.5));\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.95, 0.0), vec3(0.04, 1.9, 0.10)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.95, 0.0), vec3(0.04, 1.9, 0.10)*0.5));\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.325, 0.0), vec3(0.1, 0.65, 0.16)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.325, 0.0), vec3(0.1, 0.65, 0.16)*0.5));\n    return rh;\n}\n\nvoid MakeCables(inout vec4 cables, vec3 hitPos) {\n    if ((hitPos.y > 2.3) || (hitPos.y < 0.65) || (abs(hitPos.z) > 12.8)) cables.w = farPlane;\n    else {\n        vec3 tempNormal = cables.xyz;\n        float repz = Repeat(hitPos.z+6.4, 12.8);\n        float base = hitPos.y - 0.75;\n        float curve = 0.0365;\n        bool isSmallCable = (abs(repz * repz) * curve) > base;\n        float reps = Repeat(repz, 0.15);\n        if (reps < 0.065) isSmallCable = false;\n        bool isBigCable = abs((abs(repz * repz) * curve) - base) < 0.0125;\n        float cablePosY = -((abs(repz * repz) * curve) - base)*50.0;\n        if (isBigCable) tempNormal = normalize(tempNormal + vec3(0.0, cablePosY, 0.0));\n        //tempNormal = vec3(0.0, -1.0, 0.0);\n        if ((!isBigCable) && (!isSmallCable)) cables.w = farPlane;\n        else cables.xyz = tempNormal;\n    }\n}\n\nvec4 RayTraceGoldenGateBridge(vec3 pos, vec3 dirVecN) {\n    vec3 rayInv = 1.0 / dirVecN;\n    vec4 rh = BoxIntersect(pos, rayInv, vec3(0.0, 0.65, 0.0), vec3(0.27, 0.1, 25.6)*0.5);\n    rh = Union(rh, RayTraceBridgeTower(pos + vec3(-0.15, 0.0, -6.4), dirVecN));\n    rh = Union(rh, RayTraceBridgeTower(pos + vec3(0.15, 0.0, -6.4), dirVecN));\n\n    rh = Union(rh, RayTraceBridgeTower(pos + vec3(-0.15, 0.0, 6.4), dirVecN));\n    rh = Union(rh, RayTraceBridgeTower(pos + vec3(0.15, 0.0, 6.4), dirVecN));\n\n    vec4 struts = PlaneIntersect(pos, dirVecN, vec3(0.0, 0, 1.0), vec3(-6.4));\n    vec3 hitPos = pos + dirVecN * struts.w;\n    if ((abs(hitPos.x) < 0.135) && (hitPos.y < 2.27) && (hitPos.y > 1.0)) {\n        float repy = Repeat(hitPos.y, 0.35);\n\t\tif (repy < -0.05) rh = Union(rh, struts);\n    }\n    struts = PlaneIntersect(pos, dirVecN, vec3(0.0, 0, 1.0), vec3(6.4));\n    hitPos = pos + dirVecN * struts.w;\n    if ((abs(hitPos.x) < 0.135) && (hitPos.y < 2.27) && (hitPos.y > 1.0)) {\n        float repy = Repeat(hitPos.y, 0.35);\n\t\tif (repy < -0.05) rh = Union(rh, struts);\n    }\n    hitPos = pos + dirVecN * rh.w;\n    if (abs(rh.z) > 0.9) {\n\t\trh.xyz = normalize(rh.xyz + vec3(abs(Repeat(hitPos.x, 0.05)), 0.0, 0.0)*75.0);\n    }\n\n    vec4 cables = PlaneIntersect(pos, dirVecN, vec3(1.0, 0.0, 0.0), vec3(0.135, 0.0, 0.0));\n    hitPos = pos + dirVecN * cables.w;\n    MakeCables(cables, hitPos);\n    rh = Union(rh, cables);\n\n    cables = PlaneIntersect(pos, dirVecN, vec3(1.0, 0.0, 0.0), vec3(-0.135, 0.0, 0.0));\n    hitPos = pos + dirVecN * cables.w;\n    MakeCables(cables, hitPos);\n    rh = Union(rh, cables);\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.0, -6.4), vec3(0.8, 0.1, 0.3)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.0, 6.4), vec3(0.8, 0.1, 0.3)*0.5));\n\n    return rh;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n\t// -------------------------------- animate ---------------------------------------\n\tsunDir = normalize(vec3(0.2, 1.0, 0.9));\n    vec3 sunCol = vec3(250.0, 220.0, 200.0) / 155.0;\n    vec3 horizonCol = vec3(0.75, 0.7, 0.85)*1.5;\n    vec3 skyCol = vec3(0.02,0.45,1.0)*0.7;\n\tvec3 groundCol = vec3(0.8,0.75,0.67)*0.45;\n    currentText = 0;\n    float exposure = 1.0;\n\n\tvec3 camPos, camUp, camLookat;\n    camUp = vec3(0,1,0);\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 2.0;  // zoom in\n\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    // Repeat the animation after time t6\n    float keyEnd = keys[numKeyFrames - 1];\n    localTime = fract(localTime / keyEnd) * keyEnd;// + keys[6];\n    if (localTime < keys[1])\n    {\n        currentText = 0;\n        float time = localTime - keys[0];\n        exposure = saturate(time+0.1);\n        float alpha = time / (keys[1] - keys[0]);\n        camPos = vec3(7.0, 1.4, 27.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 11.5;\n        camPos.z += smoothstep(0.0, 1.0, alpha) * 15.0;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(-8,1.5,32.0);\n    } else if (localTime < keys[2]) {\n        currentText = 0;\n        camPos = vec3(7.0, 1.4, 27.5);\n        camPos.x -= 11.5;\n        camPos.z += 15.0;\n        camLookat=vec3(-8,1.5,32.0);\n    } else if (localTime < keys[3]) {\n        float time = localTime - keys[2];\n        float alpha = time / (keys[3] - keys[2]);\n        alpha = saturate(alpha*1.4);\n        if (alpha > 0.33) currentText = 1;\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(-4.5, 1.4, 42.5);\n        camPos += vec3(2.0, -0.5, -23) * salpha;\n\n        camLookat=vec3(-8,1.5,32.0);\n        camLookat += vec3(8, -1.5, -24) * salpha;\n    } else if (localTime < keys[4]) {\n        currentText = 2;\n        float time = localTime - keys[3];\n        float alpha = time / (keys[4] - keys[3]);\n        alpha = saturate(alpha*1.4);\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(2, 2.3, 2.5);\n        camPos += vec3(0, 2.0, -2.1) * salpha;\n        camLookat=vec3(0.5,3.2,1.5);\n        camLookat.y += 1.0 * salpha;\n    } else if (localTime < keys[5]) {\n        currentText = 3;\n        float time = localTime - keys[4];\n        float alpha = time / (keys[5] - keys[4]);\n        alpha = saturate(alpha*1.4);\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(21, 0.1, 1.5);\n        camPos += vec3(-3.6, 0.6, 1.0) * salpha;\n        camLookat=vec3(0.5,3.2,1.5);\n        sunDir = normalize(vec3(3,1,1));\n    } else if (localTime < keys[6]) {\n        currentText = 4;\n        float time = localTime - keys[5];\n        float alpha = time / (keys[6] - keys[5]);\n        alpha = saturate(alpha*1.4);\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(14.5, 0.3, 1.0);\n        camPos += vec3(-2.97, 0.4, -0.1) * salpha;\n        camLookat=vec3(0.5,0.2,1.0);\n        sunDir = normalize(vec3(1.3,1,1.1));\n    } else if (localTime < keys[7]) {\n        currentText = 5;\n        float time = localTime - keys[6];\n        float alpha = time / (keys[7] - keys[6]);\n        alpha = saturate(alpha*1.7);\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(12.0, 0.5, 32.7);\n        camPos += vec3(-11.0, 0.0, 0.0) * salpha;\n        camLookat=vec3(-10.5,0.2,32.7);\n\n        sunDir = normalize(vec3(-10.95, -1.3, 0.1));\n        sunCol = vec3(258.0, 60.0, 10.0) / 35.0;\n        exposure *= 0.2;\n        horizonCol = vec3(1.0, 0.25, 0.08)*1.95;\n        skyCol = vec3(0.15,0.5,0.95);\n    }\n#ifdef MANUAL_CAMERA\n    if (length(iMouse.xy) > 10.0) {\n        // Camera up vector.\n        camUp=vec3(0,1,0);\n\n        // Camera lookat.\n        camLookat=vec3(0.0,0.0,12.0);\n\n        // debugging camera\n        float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\n        float my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n        camPos = camLookat + vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.0;\n    }\n#endif\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distAndMat;  // Distance and material\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tfloat maxDepth = 55.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0.0);\n    const float smallVal = 0.000625;\n\n    int rtMaterial = 0;\n\tvec4 rh = RayTraceGoldenGateBridge(camPos + vec3(7.0, 0.0, -32.7), rayVec);\n\n    if (rh.w < maxDepth) {\n        maxDepth = min(maxDepth, rh.w);\n        rtMaterial = 1;\n    }\n    vec4 waterPlane = PlaneIntersect(camPos, rayVec, vec3(0.0, 1.0, 0.0), vec3(0.0));\n    rh = Union(rh, waterPlane);\n    if ((waterPlane.w == rh.w) && (waterPlane.w < farPlane)) {\n        rtMaterial = 2;\n        maxDepth = min(maxDepth, rh.w);\n    }\n\n    // ray marching time\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(pos);\n\n        // 2d voxel walk through the city blocks.\n        // The distance function is not continuous at city block boundaries,\n        // so we have to pause our ray march at each voxel boundary.\n        float walk = distAndMat.x;\n        float dx = -fract(pos.x);\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\n        float dz = -fract(pos.z);\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\n        walk = min(walk, nearestVoxel);\n\n        // move down the ray a safe amount\n        t += walk;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\n    }\n    \n    // Combine ry tracing and ray marching results.\n    if (abs(distAndMat.x) < smallVal) rtMaterial = 0;\n    else {\n        t = rh.w;\n        pos = camPos + rayVec * t;\n    } \n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if ((t <= maxDepth) || (rtMaterial > 0))\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n/*        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\n        vec3 normal = normalize(normalU);*/\n        vec3 normalU = vec3(0.0);\n        for( int i=min(0,iFrame); i<4; i++ )\n        {\n            vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n            normalU += e*DistanceToObject(pos+0.0005*e).x;\n        }\n\n        vec3 normal = normalize(normalU);\n        if (rtMaterial > 0) normal = rh.xyz;\n\n        // calculate ambient occlusion.\n        float ff = 0.0125;\n        float aa = 80.0;\n        float ambient = 1.0;\n        for( int i=min(0,iFrame); i<6; i++ )\n        {\n            ambient *= saturate(DistanceToObject(pos + normal * ff).x*aa);\n            ff *= 2.0;\n            aa /= 2.0;\n        }\n\n/*        float ambient = 1.0;\n        ambient *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);*/\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n        float ambientAvg = ambient;// (ambient*3.0 + ambientS) * 0.25;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        if (length(pos.xz) < 20.0) {\n            float iter = 0.01;\n            vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n            for (int i = 0; i < 40; i++)\n            {\n                vec3 shadowPos = nudgePos + sunDir * iter;\n                float tempDist = DistanceToObject(shadowPos).x;\n                sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n                if (tempDist <= 0.0) break;\n\n                float walk = tempDist;\n                float dx = -fract(shadowPos.x);\n                if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\n                float dz = -fract(shadowPos.z);\n                if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\n                float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\n                nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\n                walk = min(walk, nearestVoxel);\n\n                iter += max(0.01, walk);\n                if (iter > 4.5) break;\n            }\n            sunShadow = saturate(sunShadow);\n        \t// Raytraced shadows\n\t\t\t//vec4 rhs = RayTraceGoldenGateBridge(nudgePos + vec3(7.0, 0.0, -32.7), sunDir);\n        \t//if (rhs.w < farPlane) sunShadow = 0.0;\n        }\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise2d(pos.xz*32.0);\n        n += noise2d(pos.xz*64.0);\n        n += noise(fract(pos)*128.0);\n        n += noise(fract(pos)*256.0);\n        n += noise(fract(pos)*512.0);\n        n = mix(0.7, 0.95, n);\n\n        // ------ Calculate texture color  ------\n    \tfloat posHilly = Hills(pos);\n        vec2 block = floor(pos.xz);\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        texColor *= 0.8;\n        float windowRef = 0.0;\n        // texture map the sides of buildings\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\n        {\n            vec3 posdx = dFdx(pos);\n            vec3 posdy = dFdy(pos);\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\n\n            // Quincunx antialias the building texture and normal map.\n            // I guess procedural textures are hard to mipmap.\n            vec3 colTotal = vec3(0.0);\n            vec3 colTemp = texColor;\n            vec3 nTemp = vec3(0.0);\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\n            colTotal = colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            texColor = colTotal * 0.2;\n            windowRef *= 0.2;\n\n            normal = normalize(normal + nTemp * 0.2);\n        }\n        else\n        {\n            // Draw the road\n            float xroad = abs(fract(pos.x+0.5)-0.5);\n            float zroad = abs(fract(pos.z+0.5)-0.5);\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\n            texColor *= mix(0.1, 1.0, road);\n\n            // double yellow line in middle of road\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\n\n            // white dashed lines on road\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\n            texColor = mix(texColor, vec3(0.5), whiteLine);\n\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\n            texColor = mix(texColor, vec3(0.5), whiteLine);\n\n            // crosswalk\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\n            crossWalk *= saturate((zroad-0.15)*880.0);\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\n            crossWalk *= n*n;\n            texColor = mix(texColor, vec3(0.25), crossWalk);\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\n            crossWalk *= saturate((xroad-0.15)*880.0);\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\n            crossWalk *= n*n;\n            texColor = mix(texColor, vec3(0.25), crossWalk);\n\n            {\n                // sidewalk cracks\n                float sidewalk = 1.0;\n                vec2 blockSize = vec2(100.0);\n                if (posHilly > 0.1) blockSize = vec2(10.0, 50);\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\n                sidewalk = saturate((1.0-road) + sidewalk);\n                texColor *= sidewalk;\n            }\n        }\n        // Car tires are almost black to not call attention to their ugly.\n        if (distAndMat.y == 3.0)\n        {\n            texColor = vec3(0.05);\n        }\n\n        // apply noise\n        texColor *= vec3(1.0)*n;//*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        float windowMask = 0.0;\n        if (distAndMat.y >= 100.0)\n        {\n            // car texture and windows\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\n            windowMask = saturate( max(0.0, abs(posHilly - 0.0175)*3800.0)-10.0);\n            vec2 dirNorm = abs(normalize(normal.xz));\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\n            windowMask = max(windowMask, pillars);\n            texColor *= windowMask;\n            texColor *= 10.0;\n            //if (normal.x > .995) texColor = vec3(0.02);\n        } else\n        // Parks, beach\n        if (distAndMat.y == 4.0) {\n            vec3 grassCol = vec3(0.45, 0.7, 0.3)*0.345;\n            vec3 dirtCol = vec3(1.0, 0.8, 0.5)*0.46;\n            texColor = mix(dirtCol, grassCol, saturate(n-0.4));\n            dirtCol = vec3(1.3, 0.45, 0.2)*0.1;\n            texColor = mix(dirtCol, texColor, saturate(normal.y*normal.y*normal.y*normal.y));\n            //texColor = mix(vec3(0.35, 0.32, 0.3), grassCol, saturate(normal.y-0.4));\n            // Fade to beach\n            vec3 beachCol = vec3(1.0, 0.85, 0.7)*0.3*(n+0.8);\n            texColor = mix(texColor, beachCol, saturate((0.015-pos.y)*200.0));\n            //if (pos.y < 0.003) texColor = vec3(1.0, 0.9, 0.8)*0.04;\n        } else if (distAndMat.y == 5.0) {\n            // Letters\n            texColor = mix(vec3(0.97, 0.2, 0.1), vec3(1.0, 1.0, 0.1), abs(normal.z));\n        }\n\n        // Golden Gate Bridge\n        if (rtMaterial == 1) {\n\t        if (rtMaterial > 0) normal = rh.xyz;\n            float bridgeX = 7.0;\n            texColor = vec3(1.0, 0.2, 0.1)*0.6;\n            ambient = 1.0;\n            if (pos.y < 0.125) texColor = vec3(0.55, 0.4, 0.3)*0.5*n*saturate(pos.y*10.0);\n            if ((pos.y > 0.62) && (pos.y < 0.68) && (abs(pos.x+bridgeX) < 0.14)) {\n                texColor = mix(texColor, texColor * 0.2, saturate((abs(Repeat(pos.z, 0.15))-0.02) * 30.0));\n            }\n            if ((pos.y > 0.68) && (pos.y < 0.72) && (abs(pos.x+bridgeX) < 0.128) && (normal.y == 1.0)) {\n                // Road pavement on bridge\n                texColor = vec3(0.1);\n\n                float xroad = abs(fract(pos.x+bridgeX+0.5)-0.5);\n                float zroad = abs(fract(pos.z+0.5)-0.5);\n                //float road = saturate((min(xroad, zroad)-0.143)*480.0);\n                // double yellow line in middle of road\n                float yellowLine = saturate(1.0-(xroad-0.002)*480.0);\n                yellowLine *= saturate((xroad-0.0005)*480.0);\n                //yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\n                texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\n\n                // white dashed lines on road\n                float whiteLine = saturate(1.0-(xroad-0.06)*480.0);\n                whiteLine *= saturate((xroad-0.056)*480.0);\n                whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\n                //whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\n                texColor = mix(texColor, vec3(0.45), whiteLine);\n\n                whiteLine = saturate(1.0-(xroad-0.11)*480.0);\n                whiteLine *= saturate((xroad-0.106)*480.0);\n                texColor = mix(texColor, vec3(0.5), whiteLine);\n                texColor *= vec3(0.7)*n;\n                texColor = saturate(texColor);\n            }\n        }\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = (sunCol * saturate(dot(normal, sunDir))) * sunShadow;\n        // Add sky color with ambient acclusion\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*0.35;\n        // Ground light\n        lightColor += (groundCol * saturate(-normal.y *0.5+0.5)) * 0.25 * ambientAvg;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // Reflections for cars\n        if ((distAndMat.y >= 100.0) && (rtMaterial == 0))\n        {\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\n            finalColor += GetEnvMapSkyline(ref, sunDir, posHilly-1.5, sunCol, horizonCol, skyCol)*\n                0.3*yfade*max(0.4,sunShadow);\n            finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\n        }\n        // reflections for building windows\n        if ((windowRef != 0.0) && (rtMaterial == 0))\n        {\n            finalColor *= mix(1.0, 0.6, windowRef);\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\n            finalColor += GetEnvMapSkyline(ref, sunDir, posHilly-0.5, sunCol, horizonCol, skyCol)\n                *0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\n            finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\n        }\n        // water\n        if ((pos.y <= 0.001f) || (rtMaterial == 2)) {\n            if (rtMaterial == 2){\n                pos.y = -10.1f;\n                //finalColor = vec3(0.0);\n            }\n            /*float waterNoise = noise2d(pos.xz*4.0+localTime)*0.1 +\n                noise2d(pos.xz*8.0+localTime)*0.03 +\n                noise2d(pos.xz*16.0-localTime)*0.015 +\n                noise2d(pos.xz*32.0-localTime)*0.005 +\n                noise2d(pos.xz*64.0-localTime)*0.002;\n            // Fade the waves a bit in the distance.\n            float r = dot(pos.xz, pos.xz);\n            waterNoise = waterNoise * saturate(1.0/(r));\n            vec3 dx = vec3(1.0, dFdx(waterNoise)*8000.0, 0.0);\n            vec3 dy = vec3(0.0, dFdy(waterNoise)*8000.0, 1.0);\n            normal = -cross(dx, dy);*/\n\n            vec2 sp = pos.xz * 2.0;\n            vec2 waterNoise = NoiseTex(vec3(sp.x*32.0, sp.y*32.0 + localTime, localTime))*0.125;\n            waterNoise += NoiseTex(vec3(sp.x*16.0 + localTime, sp.y*16.0, localTime+0.2))*0.25;\n            waterNoise += NoiseTex(vec3(sp.x*8.0, sp.y*8.0 - localTime, localTime+0.4))*0.5;\n            waterNoise += NoiseTex(vec3(sp.x*4.0 - localTime, sp.y*4.0, localTime+0.6));\n\t        ref = reflect(rayVec, normalize(normal + vec3(waterNoise.x, 0.0, waterNoise.y)* 0.4));\n            ref.y = abs(ref.y);\n\n            // This make the water either reflect or refract with the right amount\n            // Schlick's approximation\n            float oneMinusCos = 1.0 - saturate(dot(rayVec, -normal));\n            float fresnel = 0.02;  // reflectance\n            float reflectProb = fresnel + (1.0-fresnel) * pow(oneMinusCos, 5.0);\n\n            float waterDepth = saturate(1.0+pos.y*256.0);\n            vec3 waterColor = mix(vec3(0.025, 0.35, 0.1)*0.2 * lightColor, finalColor, waterDepth);\n            vec3 env = GetEnvMapSimple(ref, sunDir, sunCol, horizonCol, skyCol);\n            float bridgeX = 7.0;\n\t\t\tvec4 rh = BoxIntersect(pos, 1.0/normalize(ref), -vec3(7.0, 10.0, -32.7+6.4), vec3(0.3, 1.55*2.0, 0.1));\n\t\t\trh = Union(rh, BoxIntersect(pos, 1.0/normalize(ref), -vec3(7.0, 10.0, -32.7-6.4), vec3(0.3, 1.55*2.0, 0.1)));\n\t\t\trh = Union(rh, BoxIntersect(pos, 1.0/normalize(ref), -vec3(7.0, 9.3, -32.7), vec3(0.2, 0.1, 32.7)));\n            if (rh.w < farPlane) env *= vec3(0.3, 0.15, 0.15);\n            waterColor = mix(waterColor*0.75, env, reflectProb);\n        \tfinalColor = mix(finalColor, waterColor, saturate((0.0-pos.y)*2048.0));\n        }\n        // fog\n        vec3 rv2 = rayVec;\n        rv2.y *= saturate(sign(rv2.y));\n        vec3 fogColor = groundCol*0.7 + horizonCol * 0.3;\n        fogColor = min(vec3(9.0), fogColor);\n        finalColor = mix(fogColor, finalColor, exp(-t*0.013));\n\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n        //finalColor = normal * 0.5 + 0.5;\n        //finalColor = vec3(ambientAvg)*0.7;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        finalColor = GetEnvMap(rayVec, sunDir, sunCol, groundCol, horizonCol, skyCol);\n    }\n\n    // vignette FTW\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/1.3));\n    finalColor *= 1.3*exposure;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Absolutely Awesome and Amazing shader.  I wish you all a great time at the party.  (A bit far for me in New Zealand though ;->)",
        "date": "1553577485",
        "username": "AndrewNZ",
        "userpicture": "/media/users/AndrewNZ/profile.jpeg",
        "id": "ltXcDj",
        "hidden": 0
      },
      {
        "text": "Nice. Glad you finally got to use your own fonts. :)",
        "date": "1553423825",
        "username": "dr2",
        "userpicture": "/img/profile.jpg",
        "id": "llscWB",
        "hidden": 0
      },
      {
        "text": "Very cool",
        "date": "1553381638",
        "username": "Geklmin",
        "userpicture": "/img/profile.jpg",
        "id": "MllyWB",
        "hidden": 0
      },
      {
        "text": "I wish I could have come ... maybe next time.",
        "date": "1553287934",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "XtscWB",
        "hidden": 0
      },
      {
        "text": "as far as procedural generation of skyscrapers/vehicles/sequencers go, i am currently working on abstract concepts, to make many things [look/sound much more complex than they really are] and [absolute control over any entropy] . And it seems that all solutions point towards golomb-rulers and (symmetric) costas arrays of orders [3,5,7,8,9,11,13,16,17,21,27], within less than 5 fractal iterations, with a [linear shoft register] as wrapper around that. Other gostas-orders and g-symmetry are fine, too, but memory limits are begging for a bias in favor of higher compression, maximum apparent complexity from minimum actually defined complexity.",
        "date": "1553166694",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "llfcWB",
        "hidden": 0
      },
      {
        "text": "By the way, if anyone reading this is thinking \"I'd love to go, but I live in LA\", there is at least one smaller related meetup in the LA area : http://www.slimshader.com/",
        "date": "1553118984",
        "username": "mds2",
        "userpicture": "/media/users/mds2/profile.png",
        "id": "ltfyDS",
        "hidden": 0
      },
      {
        "text": "Extremely great :)",
        "date": "1552912986",
        "username": "jt",
        "userpicture": "/img/profile.jpg",
        "id": "4tlyzs",
        "hidden": 0
      },
      {
        "text": "good old min(0,iFrame) , takes ANGEL parsetrs and loop-optimizers hostage, so they can not do more harm than good, and not waste time in fruitless optimization attempts.",
        "date": "1552873059",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4lsyRl",
        "hidden": 0
      },
      {
        "text": "jjxtra, the faster rayBox intersection trick asserts a standardized NaN-definitoion to be worksafe, and this is opengl, where no such thing exists.\nby the time you define a worksafe wrapper around it, you may as well not use that trick.",
        "date": "1552872879",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "XlsyRl",
        "hidden": 0
      },
      {
        "text": "the cityscale is a nieat trick, i saw many parts of it in other shaders.\n\nits fast for being a pMod() 2d square lattice. see mercury.sexy for basics of that.\nso, this works more for usa planned cities and less for paris/london (but has been done, with more kifs-city-approaches, a kifs is just slower and less continuous)\n\nits cars are a bit trickier, theres a LOT of spatial folding happening. its all just one car, with many parametric (tree hierarchy) reflections of it, and each reflection has an ID to uniquely color it. for performance, cars only move along one domain, and wait forever on an endless red light on the other domain, the street light never changes!  (shaders that dont use this trick exist, but they have a lot less cars in them)\n\nthe houses also have an id, it sets many parameters of the skyscraper block.\nthere exist various tutorials and papers on how to define parametric skyscrapers.\nthe main challenge is to keep it simple and fast.\n\nthis one nicely extends the set for some scenic bridges and whatever those famous towers are all called.\n\nusually city-shemed shaders like this have no ocean and no contextual heightmap for a coastline, they rarele even care to have taller buildings in a city center than near a border, because pMod() invites borderless infinity.\n\n3d diegetic glyphs are a rarity in shadertoy, use this more often!",
        "date": "1552872620",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "4tsyRl",
        "hidden": 0
      },
      {
        "text": "My testure loaded in alowly, and that distorts the water shader to a point, where thee shadow of the bridge becomes logarithmic.\n\njust set ichannel1 to a black texture, this hash deform is not at the right level of its code.",
        "date": "1552871965",
        "username": "ollj",
        "userpicture": "/media/users/ollj/profile.jpeg",
        "id": "XtsyRl",
        "hidden": 0
      },
      {
        "text": "If statement on line 321 and 322 of sphere intersect can be consolidated to sqrt(max(0.0, discr));\nIt's possible the optimizer will already to this. And as I search the code it's not being referenced anyway :)",
        "date": "1552852745",
        "username": "jjxtra",
        "userpicture": "/img/profile.jpg",
        "id": "MlXcRs",
        "hidden": 0
      },
      {
        "text": "Amazing! reminds me of the Tokyo Demo fest 2018 invitation, only this is done in a single shader!\nAnd it compiles really fast.\nVery sad to miss the party.",
        "date": "1552842698",
        "username": "EvilRyu",
        "userpicture": "/media/users/EvilRyu/profile.jpeg",
        "id": "ltXyRs",
        "hidden": 0
      },
      {
        "text": "really nice! I'll be at GDC tho",
        "date": "1552789051",
        "username": "KylBlz",
        "userpicture": "/media/users/KylBlz/profile.jpeg",
        "id": "ltfyRl",
        "hidden": 0
      },
      {
        "text": "@jjxtra, thanks for the code. You are the second person to try to help optimize that function, but I'm currently afraid to fix it. I had a mysterious compiler bug in that function earlier that only happened on certain machines. So I think as long as this is shader of the week, I'm gonna just try not to break it again.",
        "date": "1552785884",
        "username": "otaviogood",
        "userpicture": "/media/users/otaviogood/profile.jpeg",
        "id": "MtXyRl",
        "hidden": 0
      },
      {
        "text": "@Shane, thanks! Inigo helped me double the compile times. They were kinda terrible and was causing much trouble. What I learned is to never unroll loops, even small ones. You can see in the code anywhere it says min(0,iFrame) is where the stuff got loopified.",
        "date": "1552785777",
        "username": "otaviogood",
        "userpicture": "/media/users/otaviogood/profile.jpeg",
        "id": "ltXyRl",
        "hidden": 0
      },
      {
        "text": "Wow. So much work. That is really impressive, and it compiles confusingly fast on my machine. :)",
        "date": "1552781683",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "4tfczs",
        "hidden": 0
      },
      {
        "text": "Faster ray/box intersect (in C++, just needs conversion):\n\n\tAos::Vector3 t1(Aos::mulPerElem(m_min - ray.m_pos, ray.m_invDir));\n\tAos::Vector3 t2(Aos::mulPerElem(m_max - ray.m_pos, ray.m_invDir));\n\n\tAos::Vector3 tmin1(Aos::minPerElem(t1, t2));\n\tAos::Vector3 tmax1(Aos::maxPerElem(t1, t2));\n\n\tfloat tmin = Aos::maxElem(tmin1);\n\tfloat tmax = Aos::minElem(tmax1);\n\n\treturn tmax >= std::max(ray.m_min, tmin) && tmin < ray.m_max;",
        "date": "1552773727",
        "username": "jjxtra",
        "userpicture": "/img/profile.jpg",
        "id": "Xlfyzs",
        "hidden": 0
      },
      {
        "text": "Sorry everyone who is far away and can't make it. We overlapped the party date and location with Game Developers Conference in the hopes that people would be in town. :)",
        "date": "1552767514",
        "username": "otaviogood",
        "userpicture": "/media/users/otaviogood/profile.jpeg",
        "id": "4tXyzs",
        "hidden": 0
      },
      {
        "text": "@mackycheese21 - the meetup.com link goes over what will happen at the party.",
        "date": "1552767454",
        "username": "otaviogood",
        "userpicture": "/media/users/otaviogood/profile.jpeg",
        "id": "XtXyzs",
        "hidden": 0
      },
      {
        "text": "If it won't be on other side of the globe I would come.",
        "date": "1552751264",
        "username": "lovelyH",
        "userpicture": "/media/users/lovelyH/profile.png",
        "id": "XtXcRs",
        "hidden": 0
      },
      {
        "text": "whats happening at the party?",
        "date": "1552747347",
        "username": "mackycheese21",
        "userpicture": "/media/users/mackycheese21/profile.png",
        "id": "XtfyRs",
        "hidden": 0
      },
      {
        "text": "Such a cityscape???? How?????",
        "date": "1552727772",
        "username": "FMS_Cat",
        "userpicture": "/media/users/FMS_Cat/profile.png",
        "id": "4lfczl",
        "hidden": 0
      },
      {
        "text": "Fantastic shader and event. Have fun!",
        "date": "1552720035",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "4lfyzl",
        "hidden": 0
      },
      {
        "text": "Totaly awesome.",
        "date": "1552698415",
        "username": "duvengar",
        "userpicture": "/img/profile.jpg",
        "id": "4tfcRl",
        "hidden": 0
      },
      {
        "text": "If you hire me I will come !",
        "date": "1552696800",
        "username": "saidwho12",
        "userpicture": "/img/profile.jpg",
        "id": "4lXcRl",
        "hidden": 0
      },
      {
        "text": "huh, awesome shader! wish i could be there...",
        "date": "1552692486",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "4lfyRl",
        "hidden": 0
      },
      {
        "text": "Wow, wow, wow! This is indeed masterpiece!! The next milestone after your Skyline shader!",
        "date": "1552688868",
        "username": "starea",
        "userpicture": "/media/users/starea/profile.jpeg",
        "id": "4lXyRl",
        "hidden": 0
      },
      {
        "text": "It's over 5000 miles for me. Oh well \ud83d\ude22",
        "date": "1552687550",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "XlXyRl",
        "hidden": 0
      },
      {
        "text": "I wish I could come. Why are these parties always thousands of miles from Montreal? ;)",
        "date": "1552687316",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "4tXyRl",
        "hidden": 0
      },
      {
        "text": "Wow... this is incredible!!! :-D Wish I could go to that party... :-) ",
        "date": "1552685268",
        "username": "marsipan",
        "userpicture": "/img/profile.jpg",
        "id": "XtXyRl",
        "hidden": 0
      },
      {
        "text": "insane! ",
        "date": "1552683166",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "llsczf",
        "hidden": 0
      },
      {
        "text": "Hah, this is superb. Looking forward to it!",
        "date": "1552682193",
        "username": "P_Malin",
        "userpicture": "/media/users/P_Malin/profile.jpeg",
        "id": "ltsczf",
        "hidden": 0
      },
      {
        "text": "The sunset over Golden Gate Bridge is mind-blowing",
        "date": "1552681387",
        "username": "orangish",
        "userpicture": "/img/profile.jpg",
        "id": "Mllczf",
        "hidden": 0
      },
      {
        "text": "Wow, nice shader! :love: it.",
        "date": "1552680471",
        "username": "Dave_Hoskins",
        "userpicture": "/media/users/Dave_Hoskins/profile.jpeg",
        "id": "lllczf",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wsl3WB",
      "date": "1547449100",
      "viewed": 6216,
      "name": "Hexagone",
      "username": "BigWIngs",
      "description": "What you get when you screw with hexagons for too long. Scrub time with the mouse. Watch fullscreen!",
      "likes": 93,
      "published": 1,
      "flags": 64,
      "tags": [
        "psychedelic",
        "hexagon",
        "trippy",
        "dmt"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "lll3z7",
            "filepath": "https://soundcloud.com/buku/front-to-back",
            "previewfilepath": "https://soundcloud.com/buku/front-to-back",
            "type": "musicstream",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 0
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Hexagone by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This started as an idea to do the effect below, but with hexagons:\n// https://www.shadertoy.com/view/wdlGRM\n//\n// Turns out that really doesn't look very nice so I just made it\n// into a dance party instead ;)\n//\n// Music: https://soundcloud.com/buku/front-to-back\n\n\n#define R3 1.732051\n\nvec4 HexCoords(vec2 uv) {\n    vec2 s = vec2(1, R3);\n    vec2 h = .5*s;\n\n    vec2 gv = s*uv;\n    \n    vec2 a = mod(gv, s)-h;\n    vec2 b = mod(gv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    vec2 st = ab;\n    vec2 id = gv-ab;\n    \n   // ab = abs(ab);\n    //st.x = .5-max(dot(ab, normalize(s)), ab.x);\n\tst = ab;\n    return vec4(st, id);\n}\n\nfloat GetSize(vec2 id, float seed) {\n    float d = length(id);\n    float t = iTime*.5;\n    float a = sin(d*seed+t)+sin(d*seed*seed*10.+t*2.);\n    return a/2. +.5;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hexagon(vec2 uv, float r, vec2 offs) {\n    \n    uv *= Rot(mix(0., 3.1415, r));\n    \n    r /= 1./sqrt(2.);\n    uv = vec2(-uv.y, uv.x);\n    uv.x *= R3;\n    uv = abs(uv);\n    \n    vec2 n = normalize(vec2(1,1));\n    float d = dot(uv, n)-r;\n    d = max(d, uv.y-r*.707);\n    \n    d = smoothstep(.06, .02, abs(d));\n    \n    d += smoothstep(.1, .09, abs(r-.5))*sin(iTime);\n    return d;\n}\n\nfloat Xor(float a, float b) {\n\treturn a+b;\n    //return a*(1.-b) + b*(1.-a);\n}\n\nfloat Layer(vec2 uv, float s) {\n    vec4 hu = HexCoords(uv*2.);\n\n    float d = Hexagon(hu.xy, GetSize(hu.zw, s), vec2(0));\n    vec2 offs = vec2(1,0);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    offs = vec2(.5,.8725);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    offs = vec2(-.5,.8725);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    \n    return d;\n}\n\nfloat N(float p) {\n    return fract(sin(p*123.34)*345.456);\n}\n\nvec3 Col(float p, float offs) {\n    float n = N(p)*1234.34;\n    \n    return sin(n*vec3(12.23,45.23,56.2)+offs*3.)*.5+.5;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 lookat, float zoom) {\n    vec3 f = normalize(lookat-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = p+f*zoom,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 UV = fragCoord.xy/iResolution.xy-.5;\n    float duv= dot(UV, UV);\n    vec2 m = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.2+m.x*10.+5.;\n    \n    float y = sin(t*.5);//+sin(1.5*t)/3.;\n    vec3 ro = vec3(0, 20.*y, -5);\n    vec3 lookat = vec3(0,0,-10);\n    vec3 rd = GetRayDir(uv, ro, lookat, 1.);\n    \n    vec3 col = vec3(0);\n    \n    vec3 p = ro+rd*(ro.y/rd.y);\n    float dp = length(p.xz);\n    \n    if((ro.y/rd.y)>0.)\n    \tcol *= 0.;\n    else {\n        uv = p.xz*.1;\n\n        uv *= mix(1., 5., sin(t*.5)*.5+.5);\n\n        uv *= Rot(t);\n        m *= Rot(t);\n\n        uv.x *= R3;\n        \n\n        for(float i=0.; i<1.; i+=1./3.) {\n            float id = floor(i+t);\n            float t = fract(i+t);\n            float z = mix(5., .1, t);\n            float fade = smoothstep(0., .3, t)*smoothstep(1., .7, t);\n\n            col += fade*t*Layer(uv*z, N(i+id))*Col(id,duv);\n        }\n    }\n    col *= 2.;\n    \n    if(ro.y<0.) col = 1.-col;\n    \n    col *= smoothstep(18., 5., dp);\n    col *= 1.-duv*2.;\n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "OH YEAH!!!",
        "date": "1550933095",
        "username": "GregRostami",
        "userpicture": "/media/users/GregRostami/profile.jpeg",
        "id": "ltXcDN",
        "hidden": 0
      },
      {
        "text": "Lot's of content for such a small code.",
        "date": "1549617151",
        "username": "archee",
        "userpicture": "/img/profile.jpg",
        "id": "ltscz4",
        "hidden": 0
      },
      {
        "text": "Wow, impressive!",
        "date": "1548535179",
        "username": "movAX13h",
        "userpicture": "/media/users/movAX13h/profile.png",
        "id": "Xs2fDd",
        "hidden": 0
      },
      {
        "text": "So goooooooood, love it! :D",
        "date": "1547683162",
        "username": "jaszunio15",
        "userpicture": "/img/profile.jpg",
        "id": "MsSfDV",
        "hidden": 0
      },
      {
        "text": "Very cool, so much hexagons variations !",
        "date": "1547561552",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "ls2fDy",
        "hidden": 0
      },
      {
        "text": "Whoa... My feel-good-shader-of-the-week! :love:",
        "date": "1547554911",
        "username": "grinist",
        "userpicture": "/img/profile.jpg",
        "id": "Ms2fWy",
        "hidden": 0
      },
      {
        "text": "super cool!",
        "date": "1547517577",
        "username": "kaneta",
        "userpicture": "/media/users/kaneta/profile.png",
        "id": "Md2BDG",
        "hidden": 0
      },
      {
        "text": "WOW! Superb!",
        "date": "1547507360",
        "username": "PauloFalcao",
        "userpicture": "/media/users/PauloFalcao/profile.jpeg",
        "id": "Md2fWG",
        "hidden": 0
      },
      {
        "text": "This is super trippy!",
        "date": "1547504529",
        "username": "Polygon",
        "userpicture": "/img/profile.jpg",
        "id": "lsjfWG",
        "hidden": 0
      },
      {
        "text": "super nice",
        "date": "1547497022",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "MdjBWG",
        "hidden": 0
      },
      {
        "text": "Very nice",
        "date": "1547495908",
        "username": "shau",
        "userpicture": "/media/users/shau/profile.png",
        "id": "Xs2fDy",
        "hidden": 0
      },
      {
        "text": "Wow, this is sick! Runs fast too.",
        "date": "1547494522",
        "username": "Passion",
        "userpicture": "/img/profile.jpg",
        "id": "4d2fDy",
        "hidden": 0
      },
      {
        "text": "Simple principle, but super nicely done! As usual...\n(for info, line 53, float rand = N21(offs); is not used)",
        "date": "1547458710",
        "username": "ocb",
        "userpicture": "/media/users/ocb/profile.jpeg",
        "id": "XsjBWy",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wt2GWG",
      "date": "1560984538",
      "viewed": 2,
      "name": "Colored Blob",
      "username": "badjano",
      "description": "colored blob",
      "likes": 0,
      "published": 1,
      "flags": 0,
      "tags": [
        "noise",
        "blob",
        "fract"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) - vec2(0.5);\n    uv *= vec2(iResolution.x/iResolution.y,1.);\n    float d = length(uv);\n    float n = perlin_noise(vec3(uv,iTime*0.1) * 5.)*0.5 + 0.5;\n    d += n * 0.2;\n    d *= 5.;\n    d = pow(d,3.);\n    float e = 1.-d;\n    int m = int(-d);\n    e = fract(e)/(fwidth(e)*2.);\n    float r = perlin_noise(vec3(float(m)+iTime,1026.7392,7492.1264));\n    float g = perlin_noise(vec3(float(m)+iTime,5669.3867,2691.1925));\n    float b = perlin_noise(vec3(float(m)+iTime,3075.1297,8495.8535));\n    fragColor = vec4(r,g,b,1.) * vec4(clamp(e,0.,1.));\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wtB3Wy",
      "date": "1560920313",
      "viewed": 42,
      "name": "triplanar mapping test",
      "username": "bitnenfer",
      "description": "Applying a texture to a raymarched volume",
      "likes": 3,
      "published": 1,
      "flags": 0,
      "tags": [
        "raymarching",
        "textures"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGRn",
            "filepath": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg",
            "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "const vec2 E = vec2(0.0001, 0.0);\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nmat2 rot(float r)\n{\n    float cr = cos(r);\n    float sr = sin(r);\n\treturn mat2(cr, sr, -sr, cr);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 d = abs(p) - s;\n    return length(max(d,0.0)) - min(max(d.x,max(d.y, d.z)),0.0);\n}\n\nmat2 tr;\nvec3 P;\nfloat map(vec3 p)\n{\n    vec3 pA = p + vec3(1.2+sin(iTime)*0.8, 0.0, 0.0);\n    vec3 pB = p - vec3(1.2+sin(iTime)*0.8, 0.0, 0.0);\n    mat2 r0 = rot(iTime);\n    mat2 r1 = rot(-iTime);\n    pA.xz *= r0;\n    pB.xz *= r1;\n\tfloat a = box(pA, vec3(1.0, 6.0, 1.0))-0.3;\n    float b = length(pB) - 1.2;\n    float dist = fOpUnionRound(a,b,0.5);\n    if (a < b) \n    {\n    \tP = pA;\n        tr = r0;\n    }\n    else\n    {\n    \tP = pB;\n    \ttr = r1;\n    }\n\treturn dist;\n}\n\nvec3 normal(vec3 p)\n{\n\treturn normalize(vec3(\n    \tmap(p + E.xyy) - map(p - E.xyy),\n    \tmap(p + E.yxy) - map(p - E.yxy),\n    \tmap(p + E.yyx) - map(p - E.yyx)\n    ));\n}\n\nfloat LOD(in vec2 uv)\n{\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n    float dp = max(dot(dx,dx), dot(dy,dy));\n    return max(0.0, 0.5 * log2(dp) - 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ar = vec2(iResolution.x/iResolution.y,1.0);\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * ar;\n    vec3 ro = vec3(0.0, 2.0, -8.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.8, 3.0));\n    vec3 col = vec3(0.0);\n    vec3 ld = normalize(vec3(0.5, 1.0, -0.8));\n    float t = 0.0;    \n    const float texScale = 0.5;\n    const vec2 texOffset = vec2(1.0, 1.0);\n    tr = rot(iTime);\n    \n    ro.yz *= rot(iTime*0.2);\n    rd.yz *= rot(iTime*0.2);\n    \n    for (int i = 0; i < 500; ++i) \n    {\n        vec3 p = ro + rd * t;\n    \tfloat d = map(p);\n        if (d < 0.0001) \n        {\n            vec2 uvX = (P.zy + texOffset) * texScale;\n            vec2 uvY = (P.xz + texOffset) * texScale;\n            vec2 uvZ = (P.xy + texOffset) * texScale;\n            vec3 colX = texture(iChannel0, uvX).rgb;\n            vec3 colY = texture(iChannel0, uvY).rgb;\n            vec3 colZ = texture(iChannel0, uvZ).rgb;\n            vec3 n = normal(p);\n            vec3 n2 = n;\n            n2.xz *= -tr;\n            vec3 bw = abs(n2);\n            bw = bw / (bw.x + bw.y + bw.z);\n            col += colX * bw.x + colY * bw.y + colZ * bw.z;\n            col *= 0.1 + max(dot(n, ld), 0.0);\n            break;\n        }\n        t += d;\n        if (t > 100.0)\n        {\n        \tbreak;\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wtB3zt",
      "date": "1560711338",
      "viewed": 137,
      "name": "Coast",
      "username": "dagbrynildsentholander",
      "description": "mainly made to experiment with coloring.",
      "likes": 7,
      "published": 3,
      "flags": 0,
      "tags": [
        "terrain",
        "raymarch"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4sfGRn",
            "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
            "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "Xsf3Rr",
            "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
            "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "float maxDist = 500.;\nvec3 camRot = vec3(0, 0, 0);\nvec3 lightDir = vec3(.2,1,.2);\nvec3 lightColor = vec3(1.2,.9,.5);\nvec3 ambientLight = vec3(0);\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x*2.+p.y*2463.)*8732.);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    vec2 id = floor(p*10.);\n    vec2 ld = fract(p*10.);\n    \n    ld = ld*ld*(3.-2.*ld);\n    \n    float bl = noise(id);\n    float br = noise(id+vec2(1., 0.));\n    float b = mix(bl, br, ld.x);\n    \n    float tl = noise(id+vec2(0., 1.));\n    float tr = noise(id+vec2(1., 1.));\n    float t = mix(tl, tr, ld.x);\n    \n    float bt = mix(b, t, ld.y);\n    \n    return abs(bt);\n}\n\nfloat ridged(float x)\n{\n    return abs(1.-abs(x));\n}\n\nvec2 map(vec3 p)\n{\n    float a = p.y/10.;\n    p += vec3(sin(a), 1, cos(a))*15.;\n    float height = 40.;\n    float base = 90.-length(p.xz)/5.;\n    base-=ridged(smoothNoise(p.xz/500.))*height;\n    base+=.5*ridged(smoothNoise(p.xz/250.))*height;\n    base-=.1*ridged(smoothNoise(p.xz/100.))*height;\n    base-=.01*ridged(smoothNoise(p.xz/40.))*height;\n    base+=.008*ridged(smoothNoise(p.xz/15.))*height;\n    return vec2(base-p.y, 0);\n}\n\nfloat plaIntersect( in vec3 ro, in vec3 rd)\n{\n    return -(dot(ro,vec3(0, 1., 0))-5.)/dot(rd,vec3(0, 1., 0));\n}\n\nvec3 ray(vec3 ro, vec3 rd, float minD, float maxD, float stepSize) // x channel - distance to hit, y channel - material\n{\n    float t = minD;\n    float ut = 0.;\n    float lastVal = 0.; \n    \n    while(t < maxD)\n    {\n        vec2 mapSample = map(ro+rd*t);\n        \n        if((ro+rd*t).y <= 5.)\n            ut = t-plaIntersect(ro, rd);\n\t\t\n        if(mapSample.x > 0.)\n            return vec3(t-(abs(mapSample.x)/(abs(mapSample.x)+abs(lastVal)))*stepSize, mapSample.y, ut);\n        t+=stepSize;\n        stepSize*=1.01;\n        lastVal = mapSample.x;\n    }\n    \n    return vec3(maxD, 0, maxD-plaIntersect(ro, rd));\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.01;\n    vec3 x = vec3 (delta, 0.00, 0.00);\n\tvec3 y = vec3 (0.00, delta, 0.00);\n\tvec3 z = vec3 (0.00, 0.00, delta);\n    \n    float val = map(p).x;\n    vec3 grad = vec3(val - map(p - x).x, val - map(p - y).x, val - map(p - z).x);\n    return -normalize(grad);\n}\n\n\nvec3 lighting(vec3 n)\n{\n    return  max(pow(dot(normalize(lightDir), n), 2.), 0.0) * lightColor +ambientLight;\n}\n\nvec3 doFog(vec3 rgb, float dist, float maxD, vec3 rd, vec3 p)\n{\n    lightDir = normalize(lightDir);\n    vec3 fogColor = vec3(.5, .5, .7);\n    fogColor += .5*vec3(.7, .1, 0)*pow(abs(1.-abs(rd.y)), 6.);\n    fogColor += .3*lightColor*pow(clamp(dot(rd, lightDir), 0., 1.), 3.);\n    if(dist == maxD)\n    {\n    \tfogColor += vec3(.5, .4, .5)*smoothNoise(vec2(p.x, p.z)/rd.y/3000.)*smoothNoise(vec2(p.x, p.z)/5./rd.y/3000.)*pow(abs(rd.y), .5);\n        fogColor += .4*lightColor*pow(clamp(dot(rd, lightDir), 0., 1.), 50.); \n    }\n    return mix(rgb, fogColor, pow(abs(dist/maxD), 1.));\n}\n\nvec3 terrainColor(vec3 p)\n{\n    vec3 n = normal(p);\n    float yAlpha = pow(abs(n.y), 6.);\n    float xAlpha = pow(abs(n.x), 6.);\n    float zAlpha = pow(abs(n.z), 6.);\n    vec3 terrainColor = vec3(0);\n    vec3 heightColor = vec3(1);\n    \n    heightColor = mix(vec3(3), vec3(1), clamp(abs(p.y-6.)/3., 0., 1.));\n    heightColor = mix(vec3(.7, .8, 0.), heightColor, clamp(abs(p.y-30.)/20., 0., 1.));\n    \n    terrainColor += texture(iChannel0, vec2(p.z, p.y)/15.).xyz*xAlpha*.5;\n    terrainColor += .3*texture(iChannel1, vec2(p.x, p.z)/10.).xyz*yAlpha*heightColor;\n    terrainColor += .2*texture(iChannel1, vec2(p.x, p.z)/3.).xyz*yAlpha*heightColor;\n    terrainColor += texture(iChannel0, vec2(p.x, p.y)/15.).xyz*zAlpha*.5;\n    terrainColor += vec3(smoothNoise((p.xz+p.y)/100.), .5, .5)/15.;\n    return terrainColor*lighting(n);\n}\n\nvec3 water(vec3 rgb, vec3 p, float ut, float dist, vec3 rd)\n{\n    vec3 surfacePoint = p-rd*ut;\n    float waterBump = smoothNoise(surfacePoint.xz/5.+iTime/10.)/20.;\n    vec3 waterNormal = normalize(vec3(waterBump, 1.-waterBump, waterBump));\n    vec3 reflectedRd = reflect(rd, waterNormal);\n    vec3 rayResult = ray(surfacePoint, reflectedRd, .5, maxDist, 1.);\n    vec3 reflection = doFog(terrainColor(surfacePoint+rayResult.x*reflectedRd), rayResult.x, maxDist, reflectedRd, p);\n    vec3 underwaterColor = rgb*mix(vec3(.6, 1.2, 1.5), vec3(.1, .1, .2), clamp(abs(p.y-5.)/10., 0., 1.));\n    vec3 result = mix(underwaterColor, reflection, 1.-abs(rd.y));\n    result += vec3(.6)*pow(clamp(p.y-3.8, 0., 1.), 10.)*texture(iChannel0, vec2(surfacePoint.xz+iTime/10.)/3.).x;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -  iResolution.xy*.5)/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float lastXInput = 0.;\n    float lastYInput = 0.;\n    float deltaXInput = iMouse.x-lastXInput;\n    float deltaYInput = iMouse.y-lastYInput;\n    \tcamRot+=vec3(deltaYInput/100., deltaXInput/100., 0);\n    \n    vec3 camP = vec3(cos(iTime/20.+68.)*350., 16., sin(iTime/20.+68.)*350.);\n    vec3 camDir = normalize(vec3(sin(camRot.y), sin(camRot.x), cos(camRot.y)));\n    vec3 camRight = cross(camDir, vec3(0, 1., 0));\n    vec3 rd = normalize(camDir + camRight*1.*uv.x + vec3(0,1.,0)*1.*uv.y);\n    vec3 rayResult = ray(camP, rd, .3, maxDist, 0.1);\n    vec3 p = camP+rd*rayResult.x;\n\tvec3 col = vec3(0);\n\t\n    if(p.y > 5.)\n    \tcol = doFog(terrainColor(p), rayResult.x, maxDist, rd, p);\n    else\n    \tcol = doFog(water(terrainColor(p), p, rayResult.z, rayResult.x, rd), rayResult.x-rayResult.z, maxDist, rd, p);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    lastXInput = iMouse.x;\n    lastYInput = iMouse.y;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "Looks like the new wallpaper of mac os catalina :D",
        "date": "1560956835",
        "username": "XT95",
        "userpicture": "/media/users/XT95/profile.png",
        "id": "4t2yDc",
        "hidden": 0
      },
      {
        "text": "super nice",
        "date": "1560895795",
        "username": "aiekick",
        "userpicture": "/media/users/aiekick/profile.png",
        "id": "4t2yD3",
        "hidden": 0
      },
      {
        "text": "I like coloring on this one also. It's a nice scene all together. I enjoy playing around with various terrain formulae. I get a lot of mileage out of smooth noise and sinusoidal combinations.",
        "date": "1560866556",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "llBcDc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wtS3Dy",
      "date": "1560926293",
      "viewed": 45,
      "name": "Birefringence Gradient",
      "username": "blackle",
      "description": "This is a small function that emulates the Michel-L\u00e9vy interference gradient, as one would see in many birefringent effects, such as viewing stressed plastic through cross polarizers. It was used in my demo \"scaleMARK\"",
      "likes": 4,
      "published": 1,
      "flags": 0,
      "tags": [
        "birefringence"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4sf3Rr",
            "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
            "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
            "type": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Michel-L\u00e9vy interference in linear sRGB, given path difference F expressed in micrometers.\n// Note that for some F this function will return colours with some channels in the negative.\n// This is because some interference colours are outside the linear sRGB gamut, and therefore\n// must be represented with negative values for some channels.\nvec3 ML(float F) {\n    return mat3(1.5,-.2,-.1,-.6,1.1,.2,-.1,.1,1.5)*(.5-.5*cos(2.*F*vec3(5.2,5.7,7.2)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.yy;\n\n    vec3 col = ML(pow(texture(iChannel0, uv*0.5).x*(0.5+sin(iTime)*0.5),cos(iTime)+2.0)*1.6);\n\n    col *= pow(max(1.0 - pow(length(uv)*1.1, 4.0), 0.0),3.0); //vingetting lol\n    if (uv.y > 0.4) col = ML((fragCoord.x/iResolution.x)*1.5);\n    fragColor.xyz = sqrt(log(max(col+0.002,0.0)*1.3+1.0));\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wtS3zd",
      "date": "1560723288",
      "viewed": 132,
      "name": "Swirly Substance",
      "username": "wyatt",
      "description": "\n[url]javascript:  (function(){if(Effect.prototype.Paint.toString().length>1000){_Paint=Effect.prototype.Paint;} Effect.prototype.Paint = function(...args){for(var i=0; i<4;i++){_Paint.apply(this,args);}}})()[/url]",
      "likes": 5,
      "published": 3,
      "flags": 32,
      "tags": [
        "fluid",
        "automata",
        "physics"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "float ln (vec3 p, vec3 a, vec3 b) {return length(p-a-(b-a)*min(dot(p-a,b-a),0.)/dot(b-a,b-a));}\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = (C(U).xxxx);\n    Q = .5*abs(Q.x)+.6*vec4(Q.x,0,-Q.x,1);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "XsXGR8",
            "filepath": "/media/previz/buffer01.png",
            "previewfilepath": "/media/previz/buffer01.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "// Calculate forces and pressure\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = A(U);\n    vec4 \n        d = D(U),\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    Q.xy -= \n        // electric force\n        -d.zw*(.9-abs(d.x))*d.x+\n        // pressure force\n        0.25*vec2(e.z-w.z,n.z-s.z)+\n        // magnus force\n        0.25*Q.w*vec2(n.w-s.w,e.w-w.w);\n    // divergence\n    Q.z  = 0.25*(s.y-n.y+w.x-e.x+n.z+e.z+s.z+w.z);\n    // curl\n    Q.w = 0.25*(s.x-n.x+w.y-e.y);\n    \n    //Boundary conditions\n    if ((iMouse.z>0.)&&length(iMouse.xy-iMouse.zw)>0.) Q.xy = mix(Q.xy,.7*normalize(iMouse.xy-iMouse.zw),0.3*smoothstep(1.,-1.,length(U-iMouse.xy)-6.));\n    if (iFrame < 10 && length(U-0.5*R)<30.) Q.x = .5;\n    if (iFrame<1) Q = vec4(0);\n    }",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "#define R iResolution.xy\n#define A(U) texture(iChannel0, (U)/R)\n#define C(U) texture(iChannel2, (U)/R)\n#define D(U) texture(iChannel3, (U)/R)\n\n#define N 3.",
        "name": "Common",
        "description": "",
        "type": "common"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XsXGR8",
            "channel": 0
          }
        ],
        "code": "// Advect along velocity and curl feild\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    for (float i = 0.; i< N;i++) {\n        Q = A(U);\n        float co = cos(Q.w/N), si = sin(Q.w/N);\n        U -= Q.xy*mat2(co,-si,si,co)/N;\n    }\n    Q = A(U);\n}",
        "name": "Buffer B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "XdfGR8",
            "filepath": "/media/previz/buffer03.png",
            "previewfilepath": "/media/previz/buffer03.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4sXGR8",
            "channel": 0
          }
        ],
        "code": "// Advect along velocity and curl feild\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    for (float i = 0.; i< N;i++) {\n        Q = A(U);\n        float co = cos(Q.w/N), si = sin(Q.w/N);\n        U -= Q.xy*mat2(co,-si,si,co)/N;\n    }\n    Q = C(U);\n}",
        "name": "Buffer C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4sXGR8",
            "filepath": "/media/previz/buffer02.png",
            "previewfilepath": "/media/previz/buffer02.png",
            "type": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "XdfGR8",
            "channel": 0
          }
        ],
        "code": "// draw color and acount for divergence\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = C(U);\n    // neighborhood\n    vec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0)),\n    \tnc = C(U+vec2(0,1)),\n        ec = C(U+vec2(1,0)),\n        sc = C(U-vec2(0,1)),\n        wc = C(U-vec2(1,0)),\n        m = 0.25*(nc+ec+sc+wc);\n    // divergence \n    Q += 0.25*(s.y*sc-n.y*nc+w.x*wc-e.x*ec);\n    // sim\n    Q.x += 0.005*(1.-abs(Q.y))*Q.y;\n    Q.x = mix(Q.x,m.x,.1);\n    Q.y = mix(Q.x,m.y,.9);\n    Q.zw = vec2(ec.y-wc.y,nc.y-sc.y);\n    // boundary conditions\n    if (iFrame<1) Q = vec4(cos(.1*U.x),0,0,0);\n    }",
        "name": "Buffer D",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "Beautiful (again)!",
        "date": "1560762415",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "MtScW3",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wtSGWy",
      "date": "1560899420",
      "viewed": 42,
      "name": "Mandelbrot set test - 19/06/2019",
      "username": "clepirelli",
      "description": "simple test of the mandelbrot set",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "mandelbrot"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "const int MAX_ITER = 500;\n\nvec3 BASE_COLOR = vec3(205.0,100.0, 128.0) / 255.0;\n\n\nstruct complexNumber\n{\n    float real;\n    float imaginary;\n};\n\ncomplexNumber multiplyComplex(complexNumber a, complexNumber b)\n{\n\t//(x + yi) * (u + vi) = (xu - yv) + (xv + yu)i\n    \n    return complexNumber\n        (\n        \ta.real*b.real - a.imaginary*b.imaginary,\n            a.real*b.imaginary + b.real*a.imaginary\n        );\n}\n\ncomplexNumber toComplex(vec2 a)\n{\n\treturn complexNumber(a.x, a.y);\n}\n\ncomplexNumber addComplex(complexNumber a, complexNumber b)\n{\n\treturn complexNumber(a.real + b.real, a.imaginary + b.imaginary);\n}\n\nfloat modulusComplex(complexNumber a)\n{\n\treturn sqrt(a.real*a.real + a.imaginary*a.imaginary);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nconst float Epsilon = 1e-10;\n \nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + Epsilon) + Q.z);\n\treturn vec3(H, C, Q.x);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + Epsilon);\n    return vec3(HCV.x, S, HCV.z);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HUEtoRGB(in float H)\n{\n\tfloat R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B), .0, 1.);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n}\n\n//code from Unity's Mathf.PingPong\nfloat pingpong(float t, float l)\n{\n    t = mod(t, l * 2.);\n    return l - abs(t - l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 1.0/ pow(2.0, pingpong(iTime+1.0, 16.0));\n\tcomplexNumber C = toComplex(uv);\n\tC.real += 0.281717921930775;\n    C.imaginary += 0.5771052841488505;\n    \n    complexNumber Z = toComplex(vec2(.0));\n    int itn = 0;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        Z =  addComplex(multiplyComplex(Z,Z), C);\n        \n        if(modulusComplex(Z) >= 2.0) \n        {\n        \titn = i;\n            break;\n        }\n    }\n    \n    float itRatio = float(itn) / float(MAX_ITER);\n    \n    vec3 col = BASE_COLOR;\n    col = RGBtoHSV(col);\n    col.x *= itRatio;\n    col = HSVtoRGB(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": []
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wtj3Rd",
      "date": "1560812534",
      "viewed": 76,
      "name": "Mina",
      "username": "dubu",
      "description": "Mina mina minari mina mina ri ri",
      "likes": 3,
      "published": 3,
      "flags": 32,
      "tags": [
        "2d",
        "text",
        "lines",
        "laser",
        "korean",
        "twice",
        "mina"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    fragColor = vec4(texture(iChannel0, uv).rgb,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "#define PI 3.14159\n\nfloat Dip(float time, float range){\n    return smoothstep(time-range,time,iTime) - smoothstep(time,time+range,iTime);\n}\n\nfloat Cross(in vec2 a, in vec2 b){\n    return a.x*b.y-a.y*b.x;\n}\n\nvec3 Pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nconst mat2 m2 = mat2(\n    cos(PI/4.), -sin(PI/4.),\n    sin(PI/4.), cos(PI/4.)\n);\n\nfloat sdLine(in vec2 a, in vec2 b, in vec2 p){\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    vec2 c = a + normalize(ba)*clamp(dot(pa, normalize(ba)), 0.0, length(ba));\n    vec2 pc = p-c;\n    return \tabs(dot(pc,normalize(m2*ba))) +\n        \tabs(dot(pc,normalize(ba*m2)));\n}\n\nfloat sdLineShadow(in vec2 a, in vec2 b, in vec2 p, in vec2 o){\n    vec2 oa = o-a;\n    vec2 ob = o-b;\n    vec2 op = o-p;\n    float s = sign(Cross(ob,oa));\n    vec2 ba = normalize(b-a);\n    vec2 pa = p-a;\n    vec2 c = a + ba*dot(pa, ba);\n    vec2 pc = p-c;\n    return (clamp(-s*pc.y, 0.0, 1.0))\n        \t* sign(min(s*Cross(ob, op), s*Cross(op, oa)));\n\n}\n\nvec3 DrawLine(in vec2 a, in vec2 b, in vec2 p, in vec2 o){\n    float d = sdLine(a, b, p);\n    float l = sdLineShadow(a, b, p, o);\n    \n    vec3 col = vec3(0.0);\n    \n    col += 0.02 * clamp(sign(l), 0.0, 1.0)\n        * Pal(l*2.+iTime*5., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    \n    col += smoothstep(0.015, 0.01, d);\n    \n    return col;\n}\n\nvec3 DrawLetterM(vec2 p, vec2 o, in float s, in vec2 of){\n    return vec3(0.0)\n        + DrawLine((vec2(-1., 1.)+of)*s, (vec2(1., 1.)+of)*s, p, o)\n        + DrawLine((vec2(-1., -1.)+of)*s, (vec2(1., -1.)+of)*s, p, o)\n        + DrawLine(m2*(vec2(-1., -1.)+of)*s, m2*(vec2(-1., 1.)+of)*s, m2*p, o)\n        + DrawLine(m2*(vec2(1., -1.)+of)*s, m2*(vec2(1., 1.)+of)*s, m2*p, o)\n    ;\n}\nvec3 DrawLetterI(vec2 p, vec2 o, in float s, in vec2 of){\n    return vec3(0.0)\n        + DrawLine(m2*(vec2(0., -1.4)+of)*s, m2*(vec2(0., 1.2)+of)*s, m2*p, o)\n    ;\n}\nvec3 DrawLetterN(vec2 p, vec2 o, in float s, in vec2 of){\n    return vec3(0.0)\n        + DrawLine((vec2(-1., -1.)+of)*s, (vec2(1., -1.)+of)*s, p, o)\n        + DrawLine(m2*(vec2(-1., -1.)+of)*s, m2*(vec2(-1., 1.)+of)*s, m2*p, o)\n    ;\n}\nvec3 DrawLetterA(vec2 p, vec2 o, in float s, in vec2 of){\n    return vec3(0.0)\n        + DrawLine(m2*(vec2(0., -1.4)+of)*s, m2*(vec2(0., 1.2)+of)*s, m2*p, o)\n        + DrawLine(m2*(vec2(0., -0.1)+of)*s, m2*(vec2(0.5, -0.1)+of)*s, m2*p, o)\n    ;\n}\n\nvec3 DrawMina(in vec2 p, in vec2 o, in vec2 of){\n    return vec3(0.0)\n        + DrawLetterM(p, o, 0.5, vec2(-1.9, 0.5)-of)\n        + DrawLetterI(p, o, 0.5, vec2(-0.6, 0.5)-of)\n        + DrawLetterN(p, o, 0.5, vec2(1.0, 0.5)-of)\n        + DrawLetterA(p, o, 0.5, vec2(2.3, 0.5)-of)\n\t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uvs = fragCoord/iResolution.xy;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n\n    vec3 col = vec3(0.0);\n    \n    float f = 1.0\n        - Dip(1.0, 0.25)\n        - Dip(4.0, 0.25)\n\t;\n    \n    \n    vec2 p = uv*(2.5+0.5*sin(iTime));\n    vec2 o = vec2(0.);\n    \n    col += DrawMina(p, o, sin(iTime*vec2(1.71, 1.37))*3.);\n    \n    vec3 lastFrame = texture(iChannel0, uvs).rgb;\n    \n    fragColor = vec4(pow(col, vec3(0.4545)) + lastFrame*(0.8+0.1*sin(iTime*2.)),1.0);\n}",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "\ubbf8\ub098\ud83d\udc95",
        "date": "1560813090",
        "username": "komorebi",
        "userpicture": "/img/profile.jpg",
        "id": "ltByWc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wtj3Ry",
      "date": "1560695410",
      "viewed": 262,
      "name": "Hyperbolic Wythoff explorer",
      "username": "mattz",
      "description": "It's [url]https://www.shadertoy.com/view/Md3yRB[/url] but in the hyperbolic plane! \nDrag the red generator point to change tiling. Press SPACE to toggle UI, C to center view. Press M or click outside circle to resume motion. ",
      "likes": 37,
      "published": 3,
      "flags": 48,
      "tags": [
        "geometry",
        "tesselation",
        "hyperbolic",
        "wythoff",
        "pqr"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": "4dXGzr",
            "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
            "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
            "type": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "/* Hyperbolic Wythoff explorer, by mattz\n   License https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n   Based on:\n\n     - \"Wythoff explorer\" \n       https://www.shadertoy.com/view/Md3yRB\n\n     - \"Fun with the Poincar\u00e9 disk\" \n       https://www.shadertoy.com/view/3tBGDD\n\n   These links were helpful when creating this shader:\n\n     - https://en.wikipedia.org/wiki/Wythoff_construction\n     - https://en.wikipedia.org/wiki/Wythoff_symbol\n\n*/\n\n///////////////////////////////////////////////////\n// global vars for drawing\n\nfloat textDist;\nvec2 textPos;\n\nfloat lineWidth;\nfloat inkDist;\nvec3 colorOut;\n\nivec3 drawCodes;\n\nconst vec3 colors[3] = vec3[3](PCOLOR, QCOLOR, RCOLOR);\n\n///////////////////////////////////////////////////\n// utility functions for drawing:\n\n// construct a line from 2 points\nvec3 line2D(vec2 a, vec2 b) {\n    vec2 n = perp(b - a);\n    return vec3(n, -dot(n, a));\n}\n\n// 2D distance to line\nfloat lineDist2D(vec3 l, vec2 p) {\n    float s = length(l.xy);\n    return (dot(l.xy, p) + l.z)/s;\n}\n\n// 2D distance to line\nfloat lineDist2D(vec2 a, vec2 b, vec2 p) {\n    return lineDist2D(line2D(a, b), p);\n}\n\n// 2D distances to line and line segment\nvec2 lineSegDist2D(vec2 a, vec2 b, vec2 p) {\n\n    p -= a;\n    b -= a;\n    \n    vec2 n = normalize(perp(b));\n    \n    float u = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    \n    return vec2(dot(b, n) - dot(p, n), length(p-u*b));\n    \n}\n\n// mix src into dst by smoothstepping k with threshold d\nvoid ink(vec3 src) {\n    colorOut = mix(src, colorOut, smoothstep(0.0, 1.0, inkDist));\n    inkDist = 1e5;\n}\n\n// draw either line or circle (using geodesicDist above)\nvoid drawLine(in vec3 l, in vec3 p) {\n    inkDist = min(inkDist, (abs(geodesicDist(l, p.xy))-lineWidth)/p.z);\n}\n\n// draw a 2D point\nvoid drawPoint(in vec2 x, in vec3 p) {\n\tinkDist = min(inkDist, (length(x-p.xy)-pointSize)/p.z);\n}\n\n// draw an open dot\nvoid drawDot(in vec2 x, in vec3 p) {\n    float d = (length(x-p.xy)-pointSize)/p.z;\n    colorOut = mix(colorOut, WHITE, smoothstep(1.0, 0.0, d));\n\tinkDist = min(inkDist, abs(d)-0.5);\n}\n\n// draw a geodesic segment between two points\nvoid drawSeg(vec2 p, vec2 q, vec3 cpq, vec3 uv) {\n    \n    float d = abs(geodesicDist(cpq, uv.xy))-lineWidth;\n    \n    vec2 diff = normalize(q - p);\n    \n    d = max(d, dot(p - uv.xy, diff)-lineWidth);\n    d = max(d, dot(uv.xy - q, diff)-lineWidth);\n    d = max(d, length(uv.xy)-1.);\n    \n    inkDist = min(inkDist, d/uv.z);\n\n}\n\n// distance to character in SDF font texture\nfloat fontDist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n      \n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+offset+0.5)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv)-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n// distance to triangle for spin box\nfloat spinIconDist(vec2 pos, float size, bool flip, bool dim) {\n    \n    if (flip) { pos.y = -pos.y; }  \n    pos.x = abs(pos.x);\n    \n    vec2 p0 = vec2(0, -0.7)*textSize;\n    vec2 p1 = vec2(0.35, -0.7)*textSize;\n    vec2 p2 = vec2(0.0, -1.1)*textSize;\n    \n    float d = max(lineDist2D(p0, p1, pos), \n                  lineDist2D(p1, p2, pos));\n    \n    if (dim) { \n        d = abs(d + 0.02*textSize) - 0.02*textSize;\n    }\n    \n    return d;\n       \n}\n\n// draw color icon (RGB or facet-shaded selectors)\nvoid drawColorIcon(vec2 p, float sz, int i, bool enable, inout vec3 color) {\n    \n    const float k = 0.8660254037844387;\n    \n    mat2 R = mat2(-0.5, k, -k, -0.5);\n    \n    vec2 p1 = vec2(k*sz, 0);\n    vec2 p2 = vec2(0, 0.5*sz);\n    \n    mat3 colors;\n    \n    if (i == 0) {\n        colors = mat3(vec3(1, 0, 0),\n                      vec3(1, 1, 0),\n                      vec3(0, 0, 1));\n    } else {\n        colors = mat3(vec3(0.6, 0, 0.6),\n                      vec3(0.7, 0.4, 0.7),\n                      vec3(0.1, 0.5, 0.5));\n    }\n    \n    float ue = enable ? 1. : 0.3;\n    float ds = 1e5;\n    \n    for (int j=0; j<3; ++j) {\n        \n        vec2 ap = vec2(abs(p.x), abs(p.y-0.5*sz));\n        \n        vec2 dls = lineSegDist2D(p2, p1, ap);\n        \n        p = R*p;\n        \n        color = mix(color, colors[j], smoothstep(1.0, 0.0, -dls.x+0.5) * ue);\n        ds = min(ds, dls.y);\n    \n    }\n\n    color = mix(color, vec3(0), smoothstep(1.0, 0.0, ds-0.05*sz) * ue);\n    \n}\n\n// distance to decor icon\nfloat decorIconDist(vec2 p, float sz, int style) {\n    \n    float s = sign(p.x*p.y);\n    \n    p = abs(p);\n    \n    vec2 a = vec2(0, sz);\n    vec2 b = vec2(sz, 0);\n    \n    float l = lineDist2D(a, b, p);\n    float c = length( p - (p.x > p.y ? b : a)*0.8 );\n    \n    if (style == 0) {\n        return c - 0.2*sz;\n    } else if (style == 1) {\n        return abs(l + 0.04*sz) - 0.08*sz;\n    } else if (style == 2) {\n        return min(abs(l), max(min(p.x, p.y), l)) - 0.03*sz;\n    } else {\n        return min(max(min(s*p.x, s*p.y), l), abs(l)-0.03*sz);\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// hyperbolic tiling drawing functions\n\n// decide between two region colors\nvec3 decide2(vec3 uv, int i, int j) {\n    \n    int k = 3 - i - j;\n    \n    float d = geodesicDist(perps[k], uv.xy);\n    \n    vec3 fg, bg;\n    \n    if (d * geodesicDist(perps[k], verts[i]) >= 0.) {\n        fg = colors[i];\n        bg = colors[j];\n    } else {\n        fg = colors[j];\n        bg = colors[i];\n    }\n    \n    return mix(fg, bg, 0.5*smoothstep(0.5*uv.z, 0.0, abs(d)));\n    \n}\n\n// decide between three region colors when generator on edge\nvec3 decide3Edge(vec3 uv, int i, int j) {\n    \n    int k = 3 - i - j;\n    vec3 g = geodesicFromPoints(generator, verts[k]);\n    \n    if (geodesicDist(g, uv.xy) * geodesicDist(g, verts[j]) >= 0.) {\n        return decide2(uv, j, k);\n    } else {\n        return decide2(uv, i, k);\n    }\n    \n}\n\n\n// decide between three region colors\nvec3 decide3(vec3 uv) {\n\n    int perpCode = drawCodes.y;\n\n    if (perpCode == 3) {\n        return decide3Edge(uv, 0, 1);\n    } else if (perpCode == 5) {\n        return decide3Edge(uv, 0, 2);\n    } else if (perpCode == 6) {\n        return decide3Edge(uv, 1, 2);\n    } else {\n        \n        int j;\n        \n        if (geodesicDist(perps[0], uv.xy)*geodesicDist(perps[0], verts[1]) >= 0.) {\n            j = 1;\n        } else {\n            j = 2;\n        }\n        \n        vec3 g = geodesicFromPoints(verts[j], generator);\n        \n        if (geodesicDist(g, uv.xy)*geodesicDist(g, verts[0]) >= 0.) {\n            return decide2(uv, 0, j);\n        } else {\n            return decide2(uv, 1, 2);\n        }\n        \n    }\n    \n}\n\n// decide region color based on triangle setup\nvec3 getFaceColor(vec3 uv) {\n    \n    int regionCode = drawCodes.x;\n    \n    if (regionCode == 1) {\n        return colors[0];\n    } else if (regionCode == 2) {\n        return colors[1];\n    } else if (regionCode == 4) {\n        return colors[2];\n    } else if (regionCode == 3) {\n        return decide2(uv, 0, 1);\n    } else if (regionCode == 5) {\n        return decide2(uv, 0, 2);\n    } else if (regionCode == 6) { \n        return decide2(uv, 1, 2);\n    } else {\n        return decide3(uv);\n    }\n    \n}\n\n// 16 repeated involutions to flip a point into the fundamental domain\n// covers the entire visible circle\nvoid flipIntoFundamental(inout vec4 uvsf) {\n\t\n    for (int i=0; i<16; ++i) {\n        \n        vec2 diff = uvsf.xy - edges[0].xy;\n        float d0 = dot(diff, diff);\n                \n        if (d0 < edges[0].z) {\n                        \n            float k = edges[0].z / d0;\n            uvsf.xy = edges[0].xy + k*diff;\n            uvsf.z *= k;\n            uvsf.w = -uvsf.w;\n            \n        }\n        \n        float d1 = dot(uvsf.xy, edges[1].xy);\n        \n        if (d1 < 0.) {\n\n            uvsf.xy -= 2.*d1*edges[1].xy;\n            uvsf.w = -uvsf.w;            \n \n        }\n        \n        float d2 = dot(uvsf.xy, edges[2].xy);\n\n        if (d2 < 0.) {\n            \n            uvsf.xy -= 2.*d2*edges[2].xy;\n            uvsf.w = -uvsf.w;   \n                        \n        }        \n\n    }\n    \n}\n\n// for shading alternate triangles and coloring triangle edges\nvec2 getEdgeDistAndShading(vec4 uvsf) {\n    \n    float d = abs(geodesicDist(edges[2], uvsf.xy));\n    d = min(d, abs(geodesicDist(edges[1], uvsf.xy)));\n    d = min(d, abs(geodesicDist(edges[0], uvsf.xy)));\n    \n    return vec2(d, mix(uvsf.w < 0. ? 0.8 : 1.0, 0.9, smoothstep(0.5*uvsf.z, 0.0, d)));\n\n}\n\n// hue from color in [0, 1]\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n// convert triplet of bools to bitmask\nint intFromBool3(bool v[3]) {\n    return ((v[0] ? 1 : 0) | (v[1] ? 2 : 0) | (v[2] ? 4 : 0));\n}\n\n// compute some globals to help with triangle drawing\nvoid setupTriangleDrawing(vec3 gbary) {\n    \n    if (gbary.z >= 0.) {\n        generator = verts[int(gbary.z)];  \n    } else {\n        generator = diskFromBary(gbary.xy);\n    }\n    \n    bool regionValid[3] = bool[3](true, true, true);\n    bool perpValid[3];\n    bool perpDrawable[3];\n    \n    for (int i=0; i<3; ++i) {\n        \n        perps[i] = geodesicPerpThruPoint(edges[i], generator.xy);\n        perpValid[i] = abs(geodesicDist(edges[i], generator.xy)) > TOL;\n        perpDrawable[i] = perpValid[i];\n        \n        int j = (i + 1) % 3;\n        int k = (i + 2) % 3;\n                \n        if (abs(geodesicDist(perps[i], verts[j])) < TOL) { \n            regionValid[j] = false; \n            perpValid[i] = false;\n        }\n        \n        if (abs(geodesicDist(perps[i], verts[k])) < TOL) { \n            regionValid[k] = false;\n            perpValid[i] = false;\n        }\n        \n    }\n    \n    drawCodes = ivec3(intFromBool3(regionValid),\n                      intFromBool3(perpValid),\n                      intFromBool3(perpDrawable));\n    \n    \n}\n\n// draw the image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // load variables from buffer A\n    vec4 pqrg = LOAD(PQR);\n    vec3 gbary = LOAD(GENERATOR).xyz;\n    int style = int(LOAD(STYLE).x);\n    vec2 m = LOAD(SCROLL).yx; // note flip along y=x line\n\n    // set up options from loaded things\n    pqr = pqrg.xyz;\n    \n    bool gui = (pqrg.w != 0.);\n    bool colorByRegion = bool(style & STYLE_COLOR_BY_REGION);\n    bool shadeTriangles = bool(style & STYLE_SHADE_TRIANGLES);\n    bool drawPolygonEdges = bool(style & STYLE_DRAW_POLYGONS);\n    bool drawTriangleEdges = bool(style & STYLE_DRAW_TRIANGLES);\n    bool drawGenerator = bool(style & STYLE_DRAW_GENERATOR);\n    \n    // set up coordinate transforms\n    setupScene(iResolution.xy);\n    \n    // note flip along y=x line\n    vec4 uvsf = vec4(sceneFromFrag(fragCoord).yxz, -1.);\n         \n    // set up drawing globals\n    colorOut = WHITE;\n\n    textDist = 1e5;\n    inkDist = 1e5;\n            \n    // don't do triangle setup math if not needed\n    bool insideUnit = dot(uvsf.xy, uvsf.xy) < 1.;\n    bool insideInset = boxDist(fragCoord, insetBox) <= 0.;\n\n    if (insideUnit || (insideInset && gui)) {\n        setupTriangle(pqr);\n        setupTriangleDrawing(gbary);\n    }\n\n\t// draw unit circle\n    const vec3 unitCircle = vec3(0., 0., 1.);\n    lineWidth = 0.005;\n    drawLine(unitCircle, uvsf.xyz);\n    \n    // are we in the poincare disk?\n    if (insideUnit) {\n            \n        // apply scrolling transform\n        uvsf.xyz = hyperTranslate(uvsf.xyz, m);\n\n        // stash where we were for coloring, before we flip into fundamental domain\n        vec3 shadeUV = uvsf.xyz;\n        \n        // flip into fundamental domain\n        flipIntoFundamental(uvsf);\n        \n        // get edge distance and shading fraction\n        vec2 es = getEdgeDistAndShading(uvsf);\n        \n        // choose background color\n        if (colorByRegion) {\n            \n            colorOut = getFaceColor(uvsf.xyz);\n            \n        } else {\n            \n            vec3 rgb = hue(0.5*atan(shadeUV.x, shadeUV.y)/PI);\n            colorOut = mix(rgb, WHITE, 1.-dot(shadeUV.xy, shadeUV.xy));\n            \n        }\n\n        // shade triangles if needed\n        if (shadeTriangles) { colorOut *= es.y; }\n        \n        // draw polygon edges if needed\n        if (drawPolygonEdges) {\n            lineWidth = 0.01;\n            for (int i=0; i<3; ++i) {\n                if (bool(drawCodes.z & (1 << i))) {\n                    vec2 pinter = intersectGG(perps[i], edges[i]).xy;\n                    drawSeg(generator.xy, pinter, perps[i], uvsf.xyz);\n                }\n            }\n        }\n        \n        // draw generator point if needed\n        if (drawGenerator) { drawPoint(generator.xy, uvsf.xyz); }\n        \n        // draw triangle edges if needed\n        if (drawTriangleEdges) {\n            lineWidth = 0.005;\n            inkDist = min(inkDist, (es.x-lineWidth)/uvsf.z);\n        }\n        \n    } // done drawing inside circle\n    \n    // ink the lines that were drawn\n    ink(BLACK);\n\n    if (gui) {\n\n        // inset triangle\n        if (insideInset) {\n\n            vec3 ipos = insetFromFrag(fragCoord);\n\n            // shade triangle\n            colorOut = mix(colorOut, LIGHTGRAY, step(insetTriDist(ipos), 0.));\n\n            // draw triangle outline\n            lineWidth = 0.5*ipos.z;\n\n            for (int i=0; i<3; ++i) {\n\n                int j = (i+1)%3;\n                int k = 3-i-j;\n                vec3 edge = geodesicFromPoints(insetVerts[j], insetVerts[k]);\n\n                drawSeg(insetVerts[j], insetVerts[k], edge, ipos.xyz);\n\n            }\n\n            // ink the lines\n            ink(BLACK);\n\n            // draw all 7 vertices\n            pointSize = max(4.0*ipos.z, 0.06*insetBox.z*insetOffsetPx.z);\n\n            for (int i=0; i<7; ++i) {\n                drawDot(insetVerts[i], ipos.xyz);\n            }\n\n            // ink outlines\n            ink(BLACK);\n            \n            // draw generator in red\n            vec2 insetGenerator = insetFromOrig(vec3(generator,0)).xy;\n\n            pointSize -= ipos.z;\n            drawPoint(insetGenerator, ipos.xyz);\n            ink(vec3(0.7, 0, 0));    \n\n        } // done drawing inset\n\n\n        float dBlack = 1e5;\n        float dGray = 1e5;\n\n        // text and spin icons\n        for (int i=0; i<3; ++i) {\n\n            textPos = fragCoord.xy - digitUIBox(i).xy;\n            dBlack = min(dBlack, fontDist(textPos, textSize, vec2(pqr[i], 12.0)));\n\n            dGray = min(dGray, spinIconDist(textPos, textSize, true, pqr[i] == MAX_PQR));\n            dGray = min(dGray, spinIconDist(textPos, textSize, false, pqr[i] == MIN_PQR));\n\n        }\n\n\n        // top row of clickable icons\n        for (int i=0; i<4; ++i) {\n\n            vec2 p = iconUIBox(ivec2(i, 0)).xy;\n            float idist = decorIconDist(fragCoord - p, iconSize, i);\n\n            if (bool(style & (1 << i))) {\n                dBlack = min(dBlack, idist);\n            } else {\n                dGray = min(dGray, idist);\n            }\n\n        }\n\n        // bottom row of clickable icons\n        for (int i=0; i<2; ++i) {\n            bool enable = (colorByRegion && i == 0) || (!colorByRegion && i == 1); \n            vec2 pos = iconUIBox(ivec2(i+1, 1)).xy;\n            drawColorIcon(fragCoord - pos, iconSize, i, enable, colorOut);\n        }\n\n        // draw the things\n        colorOut = mix(GRAY, colorOut, smoothstep(0.0, 1.0, dGray));\n        colorOut = mix(BLACK, colorOut, smoothstep(0.0, 1.0, dBlack));\n        \n    }\n\n    // gamma correction & display\n    colorOut = sqrt(colorOut);\n    fragColor = vec4(colorOut, 1);\n \n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "//#define DEMO_MODE 1\n\n#define PQR ivec2(0,0)\n#define MOUSE ivec2(0,1)\n#define GENERATOR ivec2(0,2)\n#define STYLE ivec2(0,3)\n#define SCROLL ivec2(0,4)\n#define TIME ivec2(0,5)\n\n#define STYLE_DRAW_GENERATOR  1\n#define STYLE_DRAW_POLYGONS   2\n#define STYLE_DRAW_TRIANGLES  4\n#define STYLE_SHADE_TRIANGLES 8\n#define STYLE_COLOR_BY_REGION 16\n\n#define LOADC(c, var) texelFetch(c, var, 0)\n#define LOAD(var) texelFetch(iChannel0, var, 0)\n\n#define PCOLOR vec3(1, 0, 0)\n#define QCOLOR vec3(1, 1, 0)\n#define RCOLOR vec3(0, 0, 1)\n\n#define BLACK vec3(0)\n#define GRAY vec3(.5)\n#define LIGHTGRAY vec3(.8)\n#define WHITE vec3(1)\n\n\n#define PI 3.141592653589793\n\n#define MIN_PQR 2.\n#define MAX_PQR 9.\n\nconst vec4 NO_INTERSECT = vec4(-1e5);\n\nconst float TOL = 1e-3;\nconst float TOL_SQR = TOL*TOL;\n\nconst float SNAP_TOL = 12.0;\n\n//////////////////////////////////////////////////\n// drawing globals\n\nvec2 theResolution; \n\nfloat px;\nfloat perpSize;\n\nfloat textSize;\nfloat pointSize;\nfloat insetSize;\nfloat iconSize;\n\nvec2 sceneCenter;\nvec4 insetBox;\nvec2 textCenter;\nvec2 iconCenter;\n\n//////////////////////////////////////////////////\n// triangle globals\n\nvec3 pqr;     \nvec2 verts[7];  // 0,1,2 are triangle vertices near origin; 3,4,5,6 are special points\n\nvec3 edges[3];\nvec2 generator;\n\nvec3 perps[3];\n\nmat2 insetR; \nvec3 insetOffsetPx;\n\nvec2 insetVerts[7];\n\n//////////////////////////////////////////////////\n// setup transforms and sizes\n\nvoid setupScene(vec2 res) {\n        \n    const float diam = 2.0;\n        \n    theResolution = res;\n\n    float rmax = max(res.x, res.y);\n    float rmin = min(res.x, res.y);\n\n    float csize = (rmin * 0.98);\n    \n    insetSize = 0.5*(rmax - csize);\n\n    if (res.x > res.y) {\n        insetBox = vec4(0.5*insetSize);\n        textCenter = vec2(0.5*insetSize, 0.5*res.y);\n    } else {\n        insetBox = vec4(res-vec2(0.5*insetSize), vec2(0.5*insetSize));\n        textCenter = vec2(0.5*res.x, res.y-0.5*insetSize);\n    }\n\n    iconCenter = vec2(0.5*insetSize, res.y-0.5*insetSize);\n    \n    textSize = insetSize * 0.2;\n        \n    px = diam / csize;\n    pointSize = max(0.025, 4.0 * px);\n    perpSize = textSize * px;\n    \n    iconSize = insetSize * 0.08;\n\n}\n\n// scene coords + pixel size from fragment\nvec3 sceneFromFrag(vec2 frag) {\n    return vec3((frag.xy - 0.5*theResolution) * px, px);\n}\n\n// distance to 2D box given by (ctr, radius)\nfloat boxDist(vec2 p, vec4 b) {\n    \n    p = abs(p - b.xy) - b.zw;\n    return max(p.x, p.y);\n    \n}\n\n// box for icon in grid\nvec4 iconUIBox(ivec2 idx) {\n    \n    vec2 iconCtr = iconCenter;\n    \n    iconCtr = floor(iconCtr+0.5);\n    \n    vec2 scl = vec2(2.5*iconSize, 3.*iconSize);\n    iconCtr += vec2(float(idx.x), float(-idx.y))*scl + vec2(-1.5, 0.5)*scl; \n    \n    return vec4(iconCtr, vec2(iconSize));\n    \n}\n\n// box for digit in triplet\nvec4 digitUIBox(int idx) {\n    \n    const vec2 digitRad = vec2(0.35, 0.5);\n    \n    return vec4(textCenter.x + (float(idx - 1))*textSize,\n                textCenter.y,\n                digitRad*textSize);\n\n}\n\n// box for triangle above digit\nvec4 triUIBox(int idx, float delta) {\n    \n    return vec4(digitUIBox(idx).xy + vec2(0, 0.9*delta*textSize), \n                0.4*textSize, 0.3*textSize);\n    \n}\n\n//////////////////////////////////////////////////\n// geometric utility functions\n\n// are two points on the same diameter of the unit circle?\nbool alongDiameter(vec2 p, vec2 q) {\n   \n    vec4 pq = abs(vec4(p, q));\n    float m = max(max(pq.x, pq.y), max(pq.z, pq.w));\n    \n    float k = abs(p.x*q.y - p.y*q.x);\n    \n    return k < TOL*m;\n    \n}\n\n// are two points the same length?\nbool sameLength(float pp, float qq) {\n    return abs(pp - qq) < TOL*max(pp, qq);\n}\n\n// rotate by 90 degrees\nvec2 perp(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n// circle centered at center containing point p\nvec3 compass2D(vec2 ctr, vec2 p) {\n    vec2 diff = p - ctr;\n    return vec3(ctr, dot(diff, diff));\n}\n\n// Construction 1.2: invert a point through a circle\nvec2 invertPC(vec2 p, vec3 c) {\n    vec2 po = p - c.xy;    \n    return c.xy + po * c.z / dot(po, po);\n}\n\n//////////////////////////////////////////////////\n// hyperbolic geometry functions\n\n// distance from a point to a line or circle\nfloat geodesicDist(vec3 l, vec2 p) {\n\tif (l.z > 0.0) {\n\t\treturn length(p-l.xy) - sqrt(l.z);\n\t} else {\n\t\treturn dot(normalize(l.xy), p);\n\t}\n}\n\n// return the point of the pair with the smaller norm\nvec3 smaller(vec4 ab) {\n    return vec3(dot(ab.xy, ab.xy) < dot(ab.zw, ab.zw) ? ab.xy : ab.zw,\n                ab == NO_INTERSECT ? 0 : 1);\n}\n\n// intersection of a circle with a line thru the origin perpendicular\n// to normal n (must be a unit vector)\nvec4 intersectCL(vec3 c, vec2 n) {\n\n    float d = dot(n, c.xy);\n    vec2 p = c.xy - d * n;\n    \n    float d2 = d*d;\n    \n    if (d2 >= c.z) {\n        return NO_INTERSECT;\n    }\n    \n    vec2 t = perp(n);\n    \n    float a = sqrt(c.z - d2);\n    \n    return vec4(p + a*t, p - a*t);\n    \n}\n\n// intersection of two circles\nvec4 intersectCC(vec3 c1, vec3 c2) {\n    \n    vec2 diff = c2.xy - c1.xy;\n    \n    float d2 = dot(diff, diff);\n    float d2inv = 1.0/d2;\n\n    vec2 n = perp(diff);\n\n    float ad = 0.5*(c1.z - c2.z + d2);\n\n    float a2 = ad*ad*d2inv;\n    \n    if (c1.z < a2) {\n        return NO_INTERSECT;\n    }\n\n    float h = sqrt((c1.z - a2)*d2inv);\n\n    vec2 mid = c1.xy + (ad*d2inv)*diff;\n    \n    return vec4(mid + h*n, mid - h*n);\n    \n}\n\n// intersection of two geodesics\nvec3 intersectGG(vec3 c1, vec3 c2) {\n    if (c1.z == 0.) {\n        if (c2.z == 0.) {\n            return vec3(0, 0, 1);\n        } else {\n            return smaller(intersectCL(c2, c1.xy));\n        }\n    } else if (c2.z == 0.) {\n        return smaller(intersectCL(c1, c2.xy));\n    } else {\n        return smaller(intersectCC(c1, c2));\n    }\n}\n\n\n// special case of Construction 1.6 for unit circle\nvec3 geodesicFromPole(vec2 p) {\n    float h2 = dot(p, p);\n    float r2 = (h2 - 1.);\n    return vec3(p, r2);\n}\n\n// Polar of a point p about the unit circle\n// 2D line passing thru the midpoint of p and its inverse, perp. to p.\nvec3 polarFromPoint(vec2 p) {\n    return vec3(p, -0.5*dot(p, p) - 0.5);\n}\n\n// invert point about geodesic (either arc or line)\nvec2 reflectPG(vec2 p, vec3 c) {\n    if (c.z == 0.) {\n        return p - (2.*dot(p, c.xy))*c.xy;\n    } else {\n        return invertPC(p, c);\n    }\n}\n\n// Construction 2.2: geodesic from polars of points\nvec3 geodesicFromPoints(vec2 p, vec2 q) {\n    \n    if (alongDiameter(p, q)) {\n        vec2 n = normalize(perp(p - q));\n        return vec3(n, 0);\n    }\n\n    vec3 ppolar = polarFromPoint(p);\n    vec3 qpolar = polarFromPoint(q);\n    vec3 inter = cross(ppolar, qpolar);\n\n    return compass2D(inter.xy/inter.z, p);\n    \n}\n\n// Construction 3.4: geodesic from point & direction\nvec3 geodesicFromPointDir(vec2 p, vec2 d) {\n    \n    if (alongDiameter(p, d)) {\n        return vec3(normalize(perp(d)), 0);\n    } \n        \n    vec3 ppolar = polarFromPoint(p);\n    vec3 l = vec3(d, -dot(d, p));\n    \n    vec3 pinter = cross(ppolar, l);\n    \n    return geodesicFromPole(pinter.xy/pinter.z);\n    \n}   \n\n// return the geodesic passing through p that is perpendicular to g\nvec3 geodesicPerpThruPoint(vec3 g, vec2 p) {\n\n    if (abs(geodesicDist(g, p)) > TOL) {\n        return geodesicFromPoints(p, reflectPG(p, g));\n    } else if (g.z > 0.) {\n        return geodesicFromPointDir(p, p - g.xy);\n    } else {\n        return geodesicFromPointDir(p, g.xy);\n    }\n    \n}\n\n\n// Construction 3.1: Perpendicular bisector\nvec3 hyperbolicBisector(vec2 p, vec2 q) {\n\n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) { \n        \n        // p is at origin\n        float h2 = 1.0/qq;\n        return vec3(q*h2, (h2 - 1.));\n       \n    } else if (qq < TOL_SQR) { \n        \n        // q is at origin                \n        float h2 = 1.0/pp;\n        return vec3(p*h2, (h2 - 1.));\n        \n    } else if (sameLength(pp, qq)) {\n        \n        // p and q are same length, return the diameter\n        return vec3(normalize(p - q), 0);\n        \n    }\n    \n    // this remarkably small piece of code reflects the following algebra:\n    //\n    // let d = q - p be the difference between p & q\n    // let x be the pole of the bisector\n    //\n    // since the pole of the bisector is on the line from p to q, we know\n    //\n    //   x = p + k*d\n    //\n    // for some unknown k with abs(k) > 1 (because the pole isn't between p & q)\n    //\n    // now let's try to solve for k.\n    //\n    // we know that since the pole x is orthogonal to the unit circle, \n    // the radius of the bisector circle is governed by\n    //\n    //   r^2 = ||x||^2 - 1\n    //       = ||p + k*d ||^2 - 1\n    //       = p.p + 2k*p.d + k^2*d.d\n    //\n    // also since p and q are inverted through the bisector circle with radius\n    // r we know\n    //\n    //   r^2 = || x-p || * || x-q || = ||d|| * || k*d - d ||\n    //       = k*(k-1)*d.d \n    //\n    // now we can set the two equations equal and solve for k\n\n    vec2 d = q - p;\n    float k = (1.0 - dot(p,p))/(dot(d,d) + 2.0*dot(p,d));\n    \n    return geodesicFromPole( p + k*d );\n    \n}\n\n// hyperbolic translation to move the origin to point m\nvec3 hyperTranslate(vec3 uv, vec2 m) {\n\n    float mm = dot(m, m);\n    if (mm < TOL_SQR || mm >= 1.) { return uv; }\n\n    vec3 g1 = hyperbolicBisector(vec2(0), m);\n\n    vec2 diff = uv.xy - g1.xy;\n    float k = g1.z / dot(diff, diff);\n    uv.xy = g1.xy + k*diff; \n    uv.z *= k;\n\n    vec2 n = m / sqrt(mm);\n    uv.xy -= 2.*dot(uv.xy, n)*n;\n    \n    return uv;\n    \n}\n\n// is this a valid pqr for hyperbolic tiling (such that 1/p + 1/q + 1/r < 1)?\nbool isValidPQR(vec3 pqr) {\n    return (pqr.x*pqr.y + pqr.x*pqr.z + pqr.y*pqr.z) < pqr.x*pqr.y*pqr.z;   \n}\n\n// setup the fundamental triangle domain for tiling\nvoid setupTriangle(vec3 scenePQR) {\n\n    // setup triangle\n\n    pqr = scenePQR;\n    vec3 angles = PI/pqr;\n    \n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n\n    float cpqr = (c.x*c.y + c.z);\n    \n    float f2 = 1./(cpqr*cpqr - s.x*s.x*s.y*s.y);\n    float f = sqrt(f2);\n   \n    float d2 = s.x*s.x*f2;\n    \n    float k = (cpqr - s.x*s.y)*f;\n\n    float bsz = (c.x*c.z + c.y - s.x*s.z)*f;\n\n    edges[0] = vec3(f*cpqr, s.x*f*c.y, d2);    \n    edges[1] = vec3(s.x, -c.x, 0);\n    edges[2] = vec3(0, 1, 0);\n\n    verts[0] = vec2(0);\n    verts[1] = vec2(k, 0);\n    verts[2] = bsz*vec2(c.x, s.x);\n    \n    vec2 dA = normalize(perp(verts[1] - edges[0].xy));\n    vec2 dB = normalize(perp(edges[0].xy - verts[2]));\n\n    vec3 bisectors[3];\n\n    bisectors[0] = vec3(sin(0.5*angles.x), -cos(0.5*angles.x), 0);\n    bisectors[1] = geodesicFromPointDir(verts[1], dA + vec2(1, 0));\n    bisectors[2] = geodesicFromPointDir(verts[2], dB + vec2(c.x, s.x));\n    \n    verts[3] = intersectGG(bisectors[0], edges[0]).xy;\n    verts[4] = intersectGG(bisectors[1], edges[1]).xy;\n    verts[5] = intersectGG(bisectors[2], edges[2]).xy;\n    verts[6] = intersectGG(bisectors[0], bisectors[1]).xy;\n    \n    \n    //////////////////////////////////////////////////\n        \n    for (int i=0; i<7; ++i) {\n        insetVerts[i] = hyperTranslate(vec3(verts[i], 0), verts[6]).xy;\n    }\n    \n    float pqrMin = min(pqr.x, min(pqr.y, pqr.z));\n    \n    vec2 b;\n    \n    b = insetVerts[1] - insetVerts[0];\n    \n    b = normalize(b);\n\n    if (theResolution.x > theResolution.y) {\n        insetR = mat2(b.x, -b.y, b.y, b.x);\n    } else {\n        insetR = mat2(b.y, b.x, -b.x, b.y);\n    }\n    \n    vec2 p0 = vec2(1e5);\n    vec2 p1 = vec2(-1e5);\n    \n    for (int i=0; i<7; ++i) {\n        insetVerts[i] = insetR*insetVerts[i];\n        p0 = min(p0, insetVerts[i]);\n        p1 = max(p1, insetVerts[i]);\n    }\n        \n    vec2 psz = p1 - p0;\n    float insetBaseline = max(psz.x, psz.y);\n    \n    float insetMargin = max(20.0, 0.05*theResolution.y);\n    float baselinePx = max(0., insetSize - 2.*insetMargin);\n    \n    insetOffsetPx = vec3(0.5*(p1 + p0), insetBaseline/baselinePx);\n    \n}\n\n// convert from poincare disk coords to barycentric coords within\n// fundamental triangle\nvec2 baryFromDisk(vec2 p) {\n    \n    mat2 m = mat2(verts[1], verts[2]);\n    \n    return inverse(m)*p;\n    \n}\n\n// convert from barycentric coords to poincare disk coords,\n// clamping result to fundamental triangle\nvec2 diskFromBary(vec2 b) {\n        \n    mat2 m = mat2(verts[1], verts[2]);\n    vec2 p = m*b;\n    \n    vec2 diff = p - edges[0].xy;\n    \n    float d0 = dot(diff, diff);\n    float d1 = dot(p, edges[1].xy);\n    float d2 = dot(p, edges[2].xy);\n    \n    if (d0 > edges[0].z && d1 >= 0. && d2 >= 0.) {\n        return p;\n    }\n    \n    vec2 pc[3];\n\n    vec2 d21 = verts[2] - verts[1];\n    pc[0] = edges[0].xy + diff*sqrt(edges[0].z/d0);\n    \n    vec2 dp2 = p - verts[2];\n    vec2 dp1 = p - verts[1];\n    \n    if (dot(dp2, d21) > 0. || dot(dp2, perp(verts[2] - edges[0].xy)) < 0.) {\n        pc[0] = verts[2];\n    } else if (dot(dp1, d21) < 0. || dot(dp1, perp(verts[1] - edges[0].xy)) > 0.) {\n        pc[0] = verts[1];\n    }\n    \n    pc[1] = verts[1]*clamp(dot(p, verts[1])/dot(verts[1], verts[1]), 0., 1.);\n    pc[2] = verts[2]*clamp(dot(p, verts[2])/dot(verts[2], verts[2]), 0., 1.);\n    \n    vec2 pmin = p;\n    float dmin = 1e5;\n    \n    for (int i=0; i<3; ++i) {\n        diff = p - pc[i];\n        float d = dot(diff, diff);\n        if (d < dmin) { \n            dmin = d;\n            pmin = pc[i];\n        }\n    }\n    \n    return pmin;\n    \n}\n\n// convert between original pose (triangle at origin) and inset pose (translated, rotated)\nvec3 origFromInset(vec3 ipos) {\n\n    ipos.xy = ipos.xy * insetR;\n    return hyperTranslate(ipos, -verts[6]);\n\n}\n\n// inverse of above\nvec3 insetFromOrig(vec3 opos) {\n    \n    vec3 ipos = hyperTranslate(opos, verts[6]);\n    ipos.xy = insetR * ipos.xy;\n    \n    return ipos;\n    \n}\n\n// distance to inset triangle\nfloat insetTriDist(vec3 ipos) {\n    \n    vec3 opos = origFromInset(ipos);\n    \n    float d0 = -geodesicDist(edges[0], opos.xy);\n    float d1 = -geodesicDist(edges[1], opos.xy);\n    float d2 = -geodesicDist(edges[2], opos.xy);\n    \n    return max(d0, max(d1, d2)) / opos.z;\n    \n}\n\n// inset triangle coords from fragment coords\nvec3 insetFromFrag(vec2 fragCoord) {\n            \n    vec3 ipos = vec3(fragCoord - insetBox.xy, 1)*insetOffsetPx.z;\n    ipos.xy += insetOffsetPx.xy;\n\n    return ipos;\n    \n}\n",
        "name": "Common",
        "description": "",
        "type": "common"
      },
      {
        "inputs": [
          {
            "id": "4dXGRr",
            "filepath": "/presets/tex00.jpg",
            "previewfilepath": "/presets/tex00.jpg",
            "type": "keyboard",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": "4dXGR8",
            "filepath": "/media/previz/buffer00.png",
            "previewfilepath": "/media/previz/buffer00.png",
            "type": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": "4dXGR8",
            "channel": 0
          }
        ],
        "code": "vec4 data;\nivec2 fc;\n\n#define STORE(oc, value) if(fc == (oc)) { data = (value); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    // set up coordinate conversions\n    setupScene(iResolution.xy);\n\n    // get integer frag coords and texel data from last frame\n    fc = ivec2(fragCoord);\n    \n    data = texelFetch(iChannel0, fc, 0);\n    \n    // load all the important variables\n    pqr = LOAD(PQR).xyz;\n    vec3 gbary = LOAD(GENERATOR).xyz;\n    vec4 mstate = LOAD(MOUSE);\n    float style = LOAD(STYLE).x;\n    vec4 scroll = LOAD(SCROLL);\n    vec4 time = LOAD(TIME);\n    \n    // update time (for pause detection)\n    time.x = time.y;\n    time.y = iTime;\n    \n    \n    // setup for initial frame\n    if (iFrame == 0) { \n\n#ifdef DEMO_MODE\n        pqr = vec3(6,4,3);\n        gbary = vec3(0, 0, 6);\n        style = 43.;\n#else\n        pqr = vec3(5,4,2); \n        gbary = vec3(0, 0, 6);\n        style = 26.;\n#endif\n        \n    } \n    \n    // see https://www.shadertoy.com/view/XdtyWB for explanation of this\n    bool paused = (time.x == iTime);\n    \n    \n#ifdef DEMO_MODE    \n    bool gui = false;\n#else\n    // space toggles GUI\n    bool gui = texelFetch(iChannel1, ivec2(32, 2), 0).x == 0.;\n#endif\n    \n    \n    // update motion if not paused\n    if (!paused && scroll.z == 0.) {\n            \n        scroll.w += iTimeDelta;\n        float t = scroll.w*PI/10.0;\n        float r = 0.5*smoothstep(0.0, 4.0, scroll.w);\n        scroll.xy = r*vec2(cos(t), sin(t));\n        \n    }\n    \n#ifdef DEMO_MODE\n    \n    float t = iTime*2.*PI/5.0;\n    float r = 0.4;\n    scroll.xy = r*vec2(cos(t), sin(t));\n    \n#endif\n\n    // is moue down?\n    bool mouseIsDown = min(iMouse.z, iMouse.w) > 0.; \n    \n    // are we clicking?\n    bool click = mouseIsDown && mstate.w == 0.;\n    \n    // update mouse state\n    if (mouseIsDown) {\n        mstate.w = 1.;\n    } else {\n        mstate = vec4(0); \n    }\n\n\t// handle clicking on triangles\n    if (gui && click && fc == PQR) {\n\n        for (int i=0; i<3; ++i) {\n\n            int j = (i+1)%3;\n            int k = 3-i-j;\n\n            for (float delta=-1.; delta <= 1.; delta += 2.) {\n            \n                bool enabled = (delta < 0.) ? data[i] > MIN_PQR : data[i] < MAX_PQR;\n                if (!enabled) { continue; }\n\n                float d = boxDist(iMouse.xy, triUIBox(i, delta));       \n                if (d > 0.) { continue; }\n\n                pqr[i] += delta;\n                \n                for (int try=0; try<10; ++try) {\n                    if (isValidPQR(pqr)) { continue; }\n                    int m = pqr[j]*delta > pqr[k]*delta ? j : k;\n                    pqr[m] -= delta;\n                }\n                \n            }\n        }\n        \n        \n    }\n    \n    // handle mouse to move generator\n    if (gui && (fc == GENERATOR || fc == MOUSE)) {\n                \n        setupTriangle(pqr);\n\n        if (click && boxDist(iMouse.xy, insetBox) < SNAP_TOL) {\n            \n            vec3 ipos = insetFromFrag(iMouse.xy);\n\n            float dmin = 1e5; \n\n            int imin;\n            vec2 omin;\n\n            for (int i=0; i<7; ++i) {\n                vec2 o = (insetVerts[i] - ipos.xy) / ipos.z;\n                float d = length(o);\n                if (d < dmin) {\n                    dmin = d;\n                    imin = i;\n                    omin = o;\n                }\n            }\n\n            if (dmin < SNAP_TOL) {\n                gbary.xy = baryFromDisk(verts[imin]);\n                gbary.z = float(imin);\n                mstate.xy = omin;\n                mstate.z = 1.;\n            } else {\n                vec3 opos = origFromInset(ipos);\n                vec3 newbary = vec3(baryFromDisk(opos.xy), -1.);\n                vec3 newdisk = vec3(diskFromBary(newbary.xy), opos.z);\n                vec3 newipos = insetFromOrig(newdisk);\n                if (length(newipos.xy - ipos.xy)/ipos.z < SNAP_TOL) {\n                    gbary = newbary;\n                    mstate.z = 2.;\n                } \n            }\n                \n        } else {\n            \n            if (mstate.z == 1.) {\n                if (length(iMouse.xy - iMouse.zw) > 0.25*SNAP_TOL) {\n                    mstate.z = 2.;\n                }\n            } \n                \n            if (mstate.z == 2.) {\n                vec3 ipos = insetFromFrag(iMouse.xy + mstate.xy);\n                vec3 opos = origFromInset(ipos);\n                gbary = vec3(baryFromDisk(opos.xy), -1.);\n            }\n            \n        }\n        \n   \n    }\n    \n    // handle clicking to change display style\n    if (fc == STYLE && click && gui) {\n        \n        int istyle = int(style);\n        \n        for (int i=0; i<4; ++i) {\n            if (boxDist(iMouse.xy, iconUIBox(ivec2(i, 0))) <= 0.) {\n                istyle ^= (1 << i);\n            }\n        }\n        \n        for (int i=0; i<2; ++i) {\n            if (boxDist(iMouse.xy, iconUIBox(ivec2(i+1, 1))) <= 0.) {\n                if (i == 0) {\n                    istyle |= STYLE_COLOR_BY_REGION;\n                } else {\n                    istyle &= ~STYLE_COLOR_BY_REGION;\n                }\n            }\n        }\n\n        style = float(istyle);\n        \n    }\n    \n    // handle mouse to do motion\n    if (fc == SCROLL || fc == MOUSE) {\n        \n        vec3 uv = sceneFromFrag(iMouse.xy);\n        float l = length(uv);\n        bool insideCircle = l < 0.85;\n        \n        if (click) {\n            if (insideCircle) {\n                mstate.z = 3.;\n                scroll.xy = uv.xy;\n                scroll.z = 1.;\n            } else if (!gui || iMouse.x > insetSize) {\n                scroll.z = 0.;\n            }\n        } else if (mstate.z == 3.) {\n            if (l > 0.85) { uv.xy *= 0.85/l; }\n            scroll.xy = uv.xy;\n        } else if (texelFetch(iChannel1, ivec2(67, 1), 0).x == 1.) {\n            scroll.z = 1.;\n            scroll.xy = vec2(0.);\n        } else if (texelFetch(iChannel1, ivec2(77, 1), 0).x == 1.) {\n            scroll.z = 0.;\n        }\n        \n    }\n\n\t// store all of the things\n    STORE(PQR, vec4(pqr, gui ? 1. : 0.));\n    STORE(MOUSE, mstate);\n    STORE(GENERATOR, vec4(gbary, 0));\n    STORE(STYLE, vec4(style, 0, 0, 0));\n    STORE(SCROLL, scroll);\n    STORE(TIME, time);\n        \n    // stash result\n    fragColor = data;\n                \n    \n}\n",
        "name": "Buffer A",
        "description": "",
        "type": "buffer"
      }
    ],
    "comments": [
      {
        "text": "wow",
        "date": "1560874130",
        "username": "iq",
        "userpicture": "/media/users/iq/profile.png",
        "id": "XljcW3",
        "hidden": 0
      },
      {
        "text": "cool!",
        "date": "1560859960",
        "username": "flockaroo",
        "userpicture": "/media/users/flockaroo/profile.jpeg",
        "id": "ltScDc",
        "hidden": 0
      },
      {
        "text": "Yeah haha, just happened to open it on my browser on the portrait monitor and hit fullscreen on that. Obviously not a big issue but just found the behavior interesting =)",
        "date": "1560767003",
        "username": "noby",
        "userpicture": "/media/users/noby/profile.png",
        "id": "MtBcW3",
        "hidden": 0
      },
      {
        "text": "Never imagined anyone would view a shader in portrait mode! It caused some negative lengths for items in the GUI. Should be fixed? Probably still gonna look way better in landscape...",
        "date": "1560765451",
        "username": "mattz",
        "userpicture": "/media/users/mattz/profile.jpeg",
        "id": "ltBcW3",
        "hidden": 0
      },
      {
        "text": "(Just an observation but the shader doesn't seem to work in fullscreen on portrait monitors, just renders black)",
        "date": "1560763181",
        "username": "noby",
        "userpicture": "/media/users/noby/profile.png",
        "id": "llScW3",
        "hidden": 0
      },
      {
        "text": "Thanks everyone! neozhaoliang: nope \u2013 try putting really large numbers into line 37 of Buffer A, it blows up once they get too high. :(",
        "date": "1560751661",
        "username": "mattz",
        "userpicture": "/media/users/mattz/profile.jpeg",
        "id": "ltByW3",
        "hidden": 0
      },
      {
        "text": ":love: This is super pretty, not to mention, informative.",
        "date": "1560741576",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "llSyW3",
        "hidden": 0
      },
      {
        "text": "Can this shader handle the infinity cases?",
        "date": "1560729754",
        "username": "neozhaoliang",
        "userpicture": "/img/profile.jpg",
        "id": "4lScDc",
        "hidden": 0
      },
      {
        "text": "Class class and class",
        "date": "1560715834",
        "username": "iapafoto",
        "userpicture": "/media/users/iapafoto/profile.png",
        "id": "4tByDc",
        "hidden": 0
      },
      {
        "text": "Wonderful!",
        "date": "1560700100",
        "username": "BigWIngs",
        "userpicture": "/media/users/BigWIngs/profile.jpeg",
        "id": "XtBcWc",
        "hidden": 0
      }
    ]
  },
  {
    "ver": "0.1",
    "info": {
      "id": "wtjGzt",
      "date": "1560792314",
      "viewed": 231,
      "name": "antialiasing fract",
      "username": "FabriceNeyret2",
      "description": "left: fract discontinuity creates aliasing.\ntop right: A simple way to get rid of it is to replace the step by a 1 pixel slope, using fwidth.\n\nbottom: if fract is just used for bars (instead of ramps), just use smooth squares thank to simple shift.",
      "likes": 23,
      "published": 3,
      "flags": 0,
      "tags": [
        "antialiasing",
        "fract",
        "tuto",
        "short"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": "4dfGRr",
            "channel": 0
          }
        ],
        "code": "// Self-ref: https://www.shadertoy.com/view/wtjGzt\n\n// Dealing with antialiasing of 2 use-case of fract: ramps and bars\n\n// See also a more complete version here: https://www.shadertoy.com/view/3tSGWy\n// adding the filtering of high frequencies.\n\nfloat aafract(float x) {    // --- antialiased fract\n    float v = fract(x),\n          w = fwidth(x);    // NB: x must not be discontinuous or factor discont out\n    return v < 1.-w ? v/(1.-w) : (1.-v)/w; // replace right step by down slope (-> chainsaw is continuous).\n            // shortened slope : added downslope near v=1 \n}\nfloat aastep(float x) {     // --- antialiased step(.5)\n    float w = fwidth(x);    // pixel width. NB: x must not be discontinuous or factor discont out\n    return smoothstep(.7,-.7,(abs(fract(x-.25)-.5)-.25)/w); // just use (offseted) smooth squares\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y;            // normalized coordinates\n    float a = atan(U.y,U.x), l = length(U); // polar coordinates\n \n    float v = 20.*a/6.28 + 10.*l +iTime; // + sin(10.*l); // some fancy field\n\n    v = U.y > 0.\n            // top:  spiral displayed with ramps, using fract\n            ? U.x < 0. ? fract( v ) : aafract( v )\n            // bottom: spiral displayed with bars, using step(fract)\n            : U.x < 0. ? step(.5,fract(v)) : aastep(v);\n    \n    O = vec4( pow(v, 1./2.2) ); // final conversion to sRGB ( NB: sqrt(v) would be a good approx )\n    if ( abs(U.x) < 1./R.y ) O = vec4(1,0,0,0); // red separator\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ],
    "comments": [
      {
        "text": "new version also dealing with filtering-out the high frequency cases (e.g. near center): [url]https://www.shadertoy.com/view/3tSGWy[/url]",
        "date": "1560859022",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MlByDc",
        "hidden": 0
      },
      {
        "text": "also, my aafract assumes that you always approach 1 to go across and wrap. But if within a spire a sine just go to 1 without crossing then decrease down to 0, the crest will incorrectly start to antialias to 0.",
        "date": "1560840864",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "llBcWc",
        "hidden": 0
      },
      {
        "text": "@Shane: note that my aafract is slightly offseted, for I ate the step only on the right side of the interval instead bothering balancing on 2 sides of the [0,1] range.\n\nfwidth: yes, it's always better (for quality, not perf) when you can get the derivative analytically.\nStill, it won't be sufficient when details get smaller to pixels, or contain fluctuations smaller than pixels: you would then need smarter analytical LOD able to vanish the pattern as it get below 2 pixel width. Which is tracktable only for some formulas (e.g. when wavelength of each term is explicit ).",
        "date": "1560840639",
        "username": "FabriceNeyret2",
        "userpicture": "/media/users/FabriceNeyret2/profile.jpeg",
        "id": "MtBcWc",
        "hidden": 0
      },
      {
        "text": ":love: I've been experimenting with cheap smooth fract formulas for ages, and have gotten close, but have never hit upon the perfect pixel precision being displayed here. On occasion, \"fwidth\" can be a little temperamental, so can I assume, in those cases that you could calculate \"fwidth\" directly and the formula with still work?",
        "date": "1560815929",
        "username": "Shane",
        "userpicture": "/img/profile.jpg",
        "id": "MlByWc",
        "hidden": 0
      },
      {
        "text": "Nice.",
        "date": "1560802931",
        "username": "reinder",
        "userpicture": "/media/users/reinder/profile.jpeg",
        "id": "llSyWc",
        "hidden": 0
      },
      {
        "text": "So cool. I was wondering what an elegant solution to this would be. ",
        "date": "1560798014",
        "username": "CPU",
        "userpicture": "/media/users/CPU/profile.jpeg",
        "id": "llScD3",
        "hidden": 0
      }
    ]
  }
]